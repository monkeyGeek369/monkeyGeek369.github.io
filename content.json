{"pages":[{"title":"","text":"icarus_monkeyGeek_source用于存放hexo主题icarus_monkeyGeek的md文档数据","link":"/README.html"}],"posts":[{"title":"CLI教程","text":"简介CLI即Command Line Interface命令行接口是一个控制台应用,它可以被用来去启动job或等待他们的执行结果返回.其作为Robot服务直接的客户端程序,通信是通过WCF通道完成的. 环境准备 CLI的成功调用需要Robot Service的支持,请确保该进程服务已经开启. 注意点 首先需要将命令行操作导航到UiPath的安装目录,例如导航到默认的安装路径cd C:\\Program Files (x86)\\UiPath\\Studio Studio v2019.4.x以及更低版本可以使用所有的命令行指令 使用CLI需要Robot在有人值守状态 命令详解执行命令1UiRobot.exe execute [--process &lt;Package_ID&gt; | --file &lt;File_Path&gt;] [--folder &lt;Orchestrator_Folder_ID&gt;] [--input &lt;Input_Parameters&gt;] 该命令用于执行一个过程process或一个文件,例如.json/.xaml/.nupkg,需要注意的是–process与–file参数不可同时使用. –process/-p:(必填项)用于执行本地或Orchestrator上的一个process.例如 12UiRobot.exe execute --process UiPathDemoProcessUiRobot.exe execute -p UiPathDemoProcess –file/-f:(必填项)用于执行本地文件,例如.json/.xaml/.nupkg 123UiRobot.exe execute --file &quot;C:\\UiPath\\Automation\\Project.json&quot;UiRobot.exe execute --file &quot;C:\\UiPath\\Automation\\Main.xaml&quot;UiRobot.exe execute --file &quot;C:\\UiPath\\Automation\\Notepad.1.0.6682.21636.nupkg&quot; –folder:(可选项)允许用户指定Orchestractor中的folder(文件夹),通常配合–process一同使用. 1UiRobot.exe -Execute --process UiPathDemoProcess --folder OrchFolder1 –input:(可选项)允许用户指定运行参数json字符串,在运行process或file时有可能会用到传参,此命令参数即可实现 123UiRobot.exe execute --process UiPathDemoProcess --input &quot;{'inArg' : 'value' , 'Integer' : 3}&quot;UiRobot.exe execute --process UiPathDemoProcess --folder OrchFolder1 --input &quot;{'inArg' : 'value' , 'Integer' : 3}&quot;UiRobot.exe execute --file &quot;C:\\UiPath\\Automation\\Main.xaml&quot; --input &quot;{'inArg' : 'value' , 'Integer' : 3}&quot; 打包命令1UiRobot.exe pack &lt;Project_Path&gt; --output &lt;Destination_Folder&gt; [-v &lt;Project_Version&gt;] 该命令用于将rpa项目打包成RPA可运行压缩包.nupkg.众说周知我们在创建RPA项目时,在所建项目的根目录会同步生成Project.json文件,该文件是对本项目名称\\配置\\环境等运行参数的完整描述,因此本打包命令的核心是对Project.json文件的解析. –output/-o:(必填项)指定打包文件的输出路径 1UiRobot.exe pack &quot;C:\\UiPath\\Automation\\Project.json&quot; --output &quot;C:\\UiPath\\Automation\\Packages&quot; -v:(可选项)指定版本 1UiRobot.exe pack &quot;C:\\UiPath\\Automation\\Project.json&quot; --output &quot;C:\\UiPath\\Automation\\Packages&quot; -v 1.0.6820.22047 连接命令1UiRobot.exe connect [--url &lt;Orchestrator_Server_URL&gt; --key &lt;Machine_Key&gt;] | [--connectionString &lt;Connection_String&gt;] 用于连接本地Robot到Orchestrator实例.前提条件是我们的RPA应用依赖于Orchestrator运行与控制,如果是不借助Orchestrator控制rpa,那么此命令用不到.这里不做详细介绍,详情可参考官网.[2] 断开连接命令1UiRobot.exe disconnect 使本地Robot机器人与Orchestrator断开连接.这里不做详细介绍,详情可参考官网.[2] 机器跟踪命令1UiRobot.exe trace --enableLowLevel | --disableLowLevel 该命令用于控制开启或关闭Robot运行期间的低层级信息调用链trace,信息调用链(verbose trace)文件.etl可在事件窗口打开,帮助开发者发现和定位问题. –enableLowLevel:开启调用链,将生成.etl文件,该文件可在事件窗口打开观看. 1UiRobot.exe trace --enableLowLevel –disableLowLevel:关闭调用链,在执行该命令后将在桌面生成.etl文件 1UiRobot.exe trace --disableLowLevel 其它命令下面的这些命令主要用于提供信息查看,其本身对RPA程序不造成影响. -version:输出有关Robot版本的信息 -help:以列表的形式输出当前版本支持的命令行命令以及对应的介绍信息和案例 参考资料: [1]https://docs.uipath.com/robot/docs/robot-command-line-interface [2]https://docs.uipath.com/robot/docs/arguments-description var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/5/26/CLI/"},{"title":"RPA编程常用技巧","text":"1.引入命名空间作用:UiPath可以基于VB和C#进行编程,同样的我们在处理数据的过程中可以利用VB或C#的命名空间(包)来进行数据的高校处理 常用命名空间如下:(新建的RPA文件并不包含如下文件) Microsoft.VisualBasic.CompilerServicesNewtonsoft.JsonNewtonsoft.Json.LinqSystem.Collections.ObjectModelSystem.Net 2.字符串处理 分割字符串:如productVesselLincode.Split({“/“},StringSplitOptions.None) 移除字符串空格:如productVesselLincode=productVesselLincode.Replace(“ “, [String].Empty) 移除字符串换行符:如productVesselLincode=System.Text.RegularExpressions.Regex.Replace(productVesselLincode,”[\\n]”,””) 3.Object对象处理 将字符串转为Jobject对象:如JObject.Parse(inputJson) 将Object对象转为JObject对象:如JObject.FromObject(exsitContainers)(“isAllowSub”).ToObject(Of Boolean) 从Jobject对象获取json对象属性:如JObject.Parse(inputJson)(“data”)(“content”)(“shipper”) —获取Object对象 JObject.Parse(inputJson)(“data”)(“content”)(“fromTerminalEnName”).ToString —获取string 对象格式转换:如JObject.Parse(inputJson)(“data”)(“taskId”).ToObject(Of Int32) 新建对象:如New With{.logDetail=XXX ,.logType=XXX,.taskId=XXX} 4.数组处理 新建数组:如New List(Of String) 从指定数据源新建数组:如New List(Of String)() From { “vgm” } 复杂数组的空判断:如IsNothing(JObject.FromObject(exsitContainers)(“containers”)) Or JObject.FromObject(exsitContainers)(“containers”).Count&lt;=0 初始化集合(数组)对象,例如,ICollection初始化格式为New List(Of UiElement) 5.空对象判断 IsNothing方法:该方法可用于判断对象是否等于Nothing(相当于java重的null),通常用在例如find children控件的输出值验证(如果找不到对应的子元素,则接收对象为Nothing).但是这个方法也有很大的局限性,很多情况下即使Object对象为空但是其并不等于Nothing,通过此方法无法辨别.这是可以借助字符方法进行判断,例如IsNothing(tableHeaderTh) or String.IsNullOrEmpty(shipper.ToString) String.IsNullOrEmpty方法:用于判断字符串是否为空,即”” String.IsNullOrWhiteSpace方法:用于判断字符串是否为空,即””或者” “ 数组对象空判断:数组比较特殊,空判断也相对复杂,与我们常见的java不同,如果一个数组为空,其通常有如下表现,借助如下表现可进行空判断 JObject.FromObject(exsitContainers)(“containers”) = [] JObject.FromObject(exsitContainers)(“containers”).Count = 0 JObject.FromObject(exsitContainers)(“containers”).toString = “” 6.发送快捷键有时我们在处理业务的过程中不可避免的需要用到快捷键功能,向浏览器发送快捷键可以借助控件Send Hotkey完成.这其中需要指定我们发送的快捷键是什么,这也是复杂的地方. 例如我们需要发送ctrl+w则快捷键字符应为”[d(ctrl)]w[u(ctrl)]”其中d代表持续按下,u代表松开 7.正则表达式利用正则表达式进行条件判断,如在判断验证码是否合规上可以用到 New System.Text.RegularExpressions.Regex(“^[0-9a-zA-Z]{4}$”).IsMatch(captcha) 8.关于UiElement对象UiElement对象是Uipath中自定义的一种用于代表页面元素的对象数据类型,它将存放某指定元素的完整信息并可以基于该对象对页面元素进行完整的操作.但是其也有一些特殊的特性需要注意,具体如下: UiElement对象就如同Sting\\Object对象等可以在不同RPA间作为参数传递 UiElement对象只在本页面有效,页面刷新后即使元素相同也无法选择对应元素.例如在A页面下获取了某元素对象,由于业务因素必须刷新页面,在刷新页面后即使我们知道是相同的页面相同的元素,也不可以使用刷新前获取的UiElement对象进行操作,此时该对象已经失效. 如果UiElement对象有失效的风险,我们可以借助UiElement中的selector属性获取selector字符串,将字符串进行传递,此时将不受页面刷新影响 9.依赖包引用 UiPath v19.10 Uipath.Excel.Activities v2.7.2 Uipath.Mail.Activities v1.7.2 Uipath.System.Activities v19.10.1 Uipath.UIAutomation.Activities v19.11.0 Uipath.Web.Activities v1.4.4 10.特殊元素获取 chrome浏览器alert弹出框内容获取 123&lt;html app='chrome.exe' title='::: Sinokor New e-Service :::' /&gt;&lt;ctrl role='dialog' /&gt;&lt;ctrl name='*' role='text' /&gt; 其它问题解答 浏览器分辨率问题导致的点击功能无法正确点击 具体问题:如果浏览器窗口太小,且被处理网站没有做页面自适应,那么将会有很大几率出现横向+纵向滚动条,这种情况下将会造成我们需要点击的按钮被遮盖,从而无法正常点击触发 解决方式:首先是尽可能保证浏览器不处于缩放状态,其次可以借助set focus控件使RPA在点击前聚焦一下,这样页面将自动聚焦到被遮盖的区域 Uipath日志本地路径:例如C:\\Users\\EDZ\\AppData\\Local\\UiPath\\Logs 通配符常用在过滤器或选择器中,例如,其中的*则代表通配符 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/4/8/common/"},{"title":"UiPath-Apps简介","text":"Robot可实现自动化业务处理但是如果想要实现更复杂而且更长的流程实现自动化，这些流程需要人类员工处理异常情况并进行验证，这时就需要Uipath Apps进行处理。Uipath Apps使机器人和人类员工能够轻松地无缝协作，在适当的时间将人类员工带入循环协作机制，当机器人需要人类员工帮助处理异常、升级、验证和批准时，它会自动创建一个任务并将其委派给合适的人，人类员工在处理任务的同时机器人可同时进行其它的工作。 UiPath Apps内置强大的访问管理和任务分配权限控制，因此，您可以自己选择一个任务也可以将其委派给团队其它人员。 Apps通知功能Apps的消息通知功能是一个新功能它是基于Orchestrator的Webhooks来实现的，能够实时监控Robot运行。（Webhooks用于Robot的执行事件、消息等的订阅功能，第三方应用或UiPath Apps可以实现订阅） 监控内容 Job（定时任务）失败消息 Schedule（计划任务）失败消息 Queue Item Transaction（队列对象的事务）失败消息 Queue Item Transaction（队列对象的事务）异常终止消息 Task创建 Task完成 Task分配变更 运行逻辑 1、Orchestrator产生通知信息，webhooks将被触发 2、云推送消息服务（Cloud Push Notification Server）将会收到webhooks推送的Post请求事件（相同事件类型下若具备多个通知消息将会归纳为同一组进行发送） 3、利用Firebase云消息通讯服务将归类好的消息发送至安卓移动端应用，利用Apple推送服务将归类好的消息发送至IOS移动端应用 4、移动应用端的操作记录以及消息接受记录将体现在Orchestrator中 标星流程（Favorite Processes）为了更快发现和运行流程我们可以在Apps中对流程标记星星icon。所有的标星标记信息均存储在移动端本地，如果重装应用将失去此类信息。 Apps可以提供如下功能操作： 标记流程 将标记流程移除星标 重排序标星流程 运行标星流程 标星Jobs（Favorite Jobs）为了更快发现和运行job我们可以在Apps中对流程标记星星icon。所有的标星标记信息均存储在移动端本地，如果重装应用将失去此类信息。 Apps可以提供如下功能操作： 标记job 编辑job 移除标记 重排序标记job 运行标记job 参考链接 [1].https://www.bilibili.com/video/av88197715 [2].https://docs.uipath.com/orchestrator/docs/about-push-notifications var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/2/13/UiPathApps/"},{"title":"Orchestrator简介","text":"简介Orchestrator首先是一个web应用程序，它的作用是以面板方式集中管理机器人集群。能够对机器人的创建、监控、部署、运行等全流程管控，并且能够同任何第三方应用程序做集成。 项目架构 单个Orchestrator支持1000无人值守机器人或者10000有人值守机器人的监管，并且Orchestrator支持多节点部署，相同集群下可共同使用相关ES或SQL数据库。 表现层：web应用、Orchestrator Data Rest API、提示API 服务层：REST API 实现 持久层：SQL server、Elasticsearch 功能简介适配用例Orchestrator能够管理的用例类型如下： 无人值守机器人-不限线程数量不需真实用户环境可在虚拟环境运行 有人值守机器人-单线程且需真实用户环境 studio/studioX-拥有有人值守机器人功能并可链接Orchestrator以实现部署功能 非产品-既在测试环境下的RPA也可以与Orchestrator链接以实现部署和测试 主要功能 指配（provisioning）：创建和维护机器人与web之间的连接 部署（deployment）：能够将不同版本的Robot发布包交付指定机器人来执行 配置（configuration）：维护和传递Robot环境和流程配置 队列（queues）：确保分布式自动化机器人负载均衡 监控（monitoring）：对机器人运行期间的数据和行为进行监控 日志（logging）：能够将日志数据存储至SQL数据库或ES库 互联互通（Inter-connectivity）:能够同第三方应用实现互联互通 操作界面 1、仪表盘Dashboard 2、用户菜单UserMenu：包括我的资料、系统设置、声明、webhooks（为第三方应用提供robot执行事件的监听接口）、Credential（证书管理）、审计追踪（不同用户的操作行为记录） 3、系统提示Alerts：重要历史事件的提示 4、系统帮助Help 5、Folder（文件夹）选择：Folder用于容纳Robots、监视器、环境、流程、jobs、tasks、queues、assets、Triggers等，可针对不同用户和角色进行分配可操作权限，这里提供选择功能。 6、机器人Robot：全局和folder范围内的机器人列表 7、Jobs调度任务：机器人所对应的可执行流程processes 8、队列Queues：总览队列和事务状态，队列是一种容器用于无限制容纳对象，队列对象可以存储多种数据类型，例如发票信息和用户信息。这些信息需要被process消费，既队列对象的消费会产生process 9、logs：平台监控日志信息 10、processes：Folder视图内Robot所对应的不同版本package信息 11、触发器（Triggers）：针对job执行的时间或事件触发器 12、队列和事务：队列信息以及队列所对应的事务信息 13、资产Assets：资产用于存储和分享变量以及证书，这些数据可以应用在不同的自动化项目中。 14、任务（Tasks）：为长链路流程人工制定干预作业任务task 15、Folder（文件夹）：Folder用于容纳Robots、监视器、环境、流程、jobs、tasks、queues、assets、Triggers等，可针对不同用户和角色进行分配可操作权限。 16、用户和角色user and roles：用于维护平台内的用户和角色 17、机器人和环境：机器人以及环境列表 18、机器Machines：容纳Robot的服务器列表 19、包/包库：包的上传、发布、部署和分组组织，可分享和重用 20、任务类型 Task Catalogs：可定义不同任务类型在创建任务时供选择 21、语言切换Language Selector:支持包括中英文在内的12种语言 关于安装想要使用Orchestrator必须购买，社区版只提供studio编辑工具。安装类型如下： 在windows服务器独立安装-包含service、client、SQL、ES等 通过Azure服务器安装脚本安装 通过UiPath平台安装 参考链接 [1].https://docs.uipath.com/orchestrator/v2020.4/docs var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/2/12/orchestrator/"},{"title":"UiPath-RPA-文件下载","text":"简介UiPath编写的RPA本身是支持文件下载的,不仅仅支持文件下载,其对windows计算机内的文件\\文件夹等具备完备的查找\\创建\\删除等功能.下面将针对文件下载做简略介绍并奉上可移植组件供下载: 功能组件 如上图所示下载需要依赖HttpClient控件,具体步骤如下: 拖拽控件进入目标区域 填写EndPoint内容即文件下载的URL 指定ResourcePath即文件存放的本地路径 注意:文件下载并非简单的下载即可,如果想要做好还要考虑文件夹是否存在?历史文件是否存在?是否需要删除历史文件?等问题,这里已经封装成可移植组件供各位使用.点击这里(也可在git仓库file文件夹内获取https://github.com/monkeyGeek369/icarus_monkeyGeek_source) var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/5/rpadownload/"},{"title":"Uipath简介","text":"简介简单来讲UiPath是提供”机器处理自动化”即RPA全链路服务的技术提供商与服务提供商,借助UiPath的studio可快速编写RPA机器人程序,借助Orchestrator可便捷管理RPA集群.UiPath在企业自动化业务场景中提供了强有力的支撑. 基本概念 提供服务 拓展 参考资料: [1]https://www.uipath.com.cn/ var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/15/uipathIntroduction/"},{"title":"chrome提速方案","text":"前言借助chrome浏览器执行的RPA程序在执行效率上会受到各种因素的影响，网络问题、服务器问题、浏览器问题，其中本文专门针对chrome浏览器的提速做简历介绍。 常规操作 更新chrome至最新 关闭多余标签 关闭多余扩展程序 关闭不需要的任务 无图模式针对某些特定性的网站，例如加载大量图片、登录无验证码的网站可以开启无图模式，提高加载速度。具体设置路径如下： 设置&gt;&gt;隐私设置和安全性&gt;&gt;网站设置&gt;&gt;图片 开启GPU加速利用GPU硬件对网页加载提速 浏览器输入chrome://flags并搜索#enable-gpu-rasterization选中开启 开启QUIC协议这是 Google 研发的另一项数据传输加速黑科技，2012 年 Google 便研发了 QUIC (快速 UDP Internet 连接) 协议并在公司内部用于减少连接延迟和网络拥塞。虽然目前在 Chrome 中还是实验性功能，但已经在 2015 年 6 月作为标准被提交给了 IETF，相信很快便会得到普及。要启用 QUIC 协议支持，只需将「实验性 QUIC 协议」改为已启用即可。 浏览器输入chrome://flags并搜索#enable-quic选中开启 开启Stale-While-Revalidate缓存关于Stale-While-Revalidate的相关只是可以参考[2]，总的来说利用Stale-While-Revalidate配置可以使浏览器更加智能更加合理的去选择在网站加载时读取缓存数据还是获取最新数据。其通常与max-age匹配使用。 stale-while-revalidate 指令应当与 max-age 配合使用，超过 max-age 指定的时间的响应就是陈旧的响应。与之相对的，没有超过时间的就是新鲜的 (fresh) 响应。如果一个缓存的响应没有超过 max-age 指定的时间（仍是新鲜的），按照上面讲的缓存机制，此时请求这个资源，浏览器会直接返回缓存的结果。如果缓存的结果已经陈旧了呢？按照前面讲的缓存机制，浏览器应该去请求新的响应了，但是如果存在 stale-while-revalidate 指令就不一样了，浏览器会检查这个陈旧的响应是否超过了 stale-while-revalidate 规定的时间窗口。如果没有超过，那么浏览器仍然会直接返回缓存的结果，同时在后台请求新的结果用来更新缓存。 浏览器输入chrome://flags并搜索#enable-stale-while-revalidate选中开启 提速插件FasterChrome下载及介绍可参考[3] 参考资料： [1]https://www.sysgeek.cn/speed-up-chrome-8-flags/ [2]https://juejin.im/post/6844904136920547341 [3]https://hao.su/3081/ var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/8/7/chromeSpeed/"},{"title":"交互式RPA实现方案","text":"简介RPA的执行除了无人值守的方式外在某些长链式的业务场景下还需要人员的介入，例如业务人员确认后方可进行后续操作。介于此，交互式RPA便应运而生，本文仅探讨交互式RPA的实现思路以及一些可行方案的简介，详细的落地方案不在本文讨论范围。 交互流程 正常流程：触发-校验-适配-执行-提交-反馈 交互流程一：触发-校验-适配-确认-执行-提交-反馈 交互流程二：触发-校验-适配-执行-确认-提交-反馈 交互流程三：触发-校验-适配-执行-确认-执行-确认-提交-反馈 交互式RPA本质上是实现人机交互，通过人的介入来更好的完成长链式任务。 人员介入后可进行外部业务逻辑处理，例如数据填写、数据确认、流程回退等等，业务人员的外部操作所产生的数据可以返回并转化为RPA的执行参数。涉及到数据相关的人机交互相当复杂，这里仅仅讨论简单的“确认”逻辑，不涉及数据交互。 针对RPA执行过程的确认可以通过表格/截图/视频的方式进行，或者借助短信、微信、钉钉、app等平台进行确认，确认的过程仅仅是动作的反馈不涉及业务数据交互。 脑洞大开思路一：前段式确认采用交互流程一的方式，在执行RPA前将提交数据进行校验和适配并以数据表格方式展示和确认优点：效率高，节省服务器资源，RPA成功执行只需执行一遍缺点：确认的成功率存在风险，可视化不友好，改造成本中等 思路二：一遍式确认-服务器单用户采用交互流程二的方式，RPA仅被触发一遍，当执行到提交节点前时正在执行的RPA程序将暂时停止并等待人员确认，此时服务器仅支持单用户账户同时操作。 优点：执行一遍节省时间 缺点：服务器资源占用、RPA需要断点改造 思路三：一遍式确认-服务器多用户采用交互流程二的方式，RPA仅被触发一遍，当执行到提交节点前时正在执行的RPA程序将暂时停止并等待人员确认，此时服务器可支持多用户账户同时操作。 优点：执行一遍节省时间，多用户提高服务器利用率 缺点：RPA需要断点改造，需要服务器配置 思路四：一遍式确认-浏览器多开隔离采用交互流程二的方式，RPA仅被触发一遍，当执行到提交节点前时正在执行的RPA程序将暂时停止并等待人员确认，此时浏览器可支持多开并相互不影响。 优点：执行一遍节省时间，多开浏览器提高服务器利用率 缺点：RPA需要断点改造，浏览器多开和隔离技术难度大 思路五：两遍式确认-利用真实提交采用交互流程二的方式，RPA执行两遍，第一遍执行到提交功能前结束，此时RPA资源释放、服务器资源释放并将执行视频反馈至操作人员，操作人员确认无误后将触发第二遍RPA程序，此时重新组织数据并提交。 优点：改造成本低，可靠性高，提交数据中途可变 缺点：流程耗时长，RPA无需改造，配套系统需要改造 思路六：两遍式确认-适配数据预留采用交互流程二的方式，RPA执行两遍，第一遍执行到提交功能前结束，此时RPA资源释放、服务器资源释放并将执行视频反馈至操作人员，操作人员确认无误后将触发第二遍RPA程序，此时获取历史数据并重新提交，直接跳过数据的适配和校验。 优点：改造成本中等，可靠性高，耗时中等 缺点：系统改造成本中上 思路七：长链任务编排采用交互流程三的方式，针对长链业务、多人员交互业务、个性化执行调度需求等可以采用长链任务编排的方案。该方案下将对长链任务为N段，每一段可单独成为独立业务执行调度，N段任务可进行自由编排。 特点： 灵活编排：可以针对不同分公司甚至不同业务人员进行个性化编排 权限控制：每一段RPA任务可自由组合编排 数据校验：每一段的数据入口和出口均可校验 数据控制：人机交互产生的数据可反馈至RPA端成为参数继续执行 消息通知：更加个性化的消息通知，钉钉、微信、短信、平台、邮件 业务确认：跟家多样化且灵活的确认方式，钉钉、平台 日志回滚：单节点出错可回滚至上一节点，根据日志可以自由还原操作流程 受限于服务器资源，其实现也必将考虑执行一遍和执行多遍等方式，具体如下： 一遍式单用户—不可取/资源占用严重一遍式多用户—可取多遍式单用户—可取/资源占用可接受多遍式多用户—可取/资源占用少 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/11/6/interactive_rpa/"},{"title":"非人民币玩家的升级之路","text":"难忘童年 本博主是92年生人，有人说我年轻，有人说我老，我自己认为在年龄上我是个老头子了但是在心智上依然年轻（=幼稚）。我的老家在江苏-徐州-沛县，没错就是刘邦的故乡（这个能吹一辈子）然而没什么用，家乡依然是如此的不富裕。我这么说我的家乡并不是不爱他，而是更爱他的体现，我希望我的家乡更好，事实上现在也确实更好了，江苏政策的扶持、产业的升级等一系列的变化，原先只靠种地谋生的父母及乡亲们现在没有几个种地的了，村里的大部分土地都被包出去建太阳能电站。 总的来说我的童年很快乐，我依然记得在2000年之前作为小孩子的我当时的主要娱乐方式不外乎去河里洗澡、去田地里烤红薯、烤玉米，去别人果园里“借”苹果，除此之外也古惑仔过，打过架、拜过把子（现在依然每年回家聚聚）、逃过课、喝过酒、去过网吧、玩过传奇、没谈过恋爱（失败），当时的生活很简单但是很快乐……但是好景不长，终于我到了八岁可以上小学的时候了，你没有听错我们那里上小学是有年龄限制的，必须要年满八岁，这个也没办法，村里就一所小学，人又多，只能这样。在上小学之前也不能荒废啊，跟着村里的半吊子武师学过武，五步拳、长拳还有各种练体技巧，比如把腿伸直让下巴放到脚尖，各种花样的翻跟头，还有练过刀法，哈哈。想想也真是好玩，小孩子的生活就是简单和快乐。 文章写起来就收不住，看到这里的看官先感谢你们听我啰嗦，这篇文章我也不遵循什么写作方法了，高中学到的什么抑扬结合、点面结合、动静结合、叙议结合、情景交融、首尾呼应先给我放一边，这篇文章就是聊天，是我同各位看客的简单沟通。 游戏人生 说起我与互联网的关系，真正说起来要从初中开始说起，从小学的快意人生步入快节奏的初中生活我是真的不适应。大家应该都清楚，小孩子是有叛逆期的，大多数孩子的叛逆期是在初中，我的也不例外，现在依然记得我的叛逆期是在初二。为什么说是叛逆期？因为在这个时期我明显的感觉到自己的躁动和不安，这种躁动是没有原因的，反正就是呆不住、不想学习，就只想出去玩。也就是从这个时候我迷恋上了玩网络游戏，从开始的抢滩登陆、cf1.5到后面的梦幻传奇、热血江湖、魔域、天龙八部…不过真的是难忘和好玩。 玩玩游戏，小男孩皮一下很正常，但是这并不是让我独立开出一个章节去介绍的原因，真正的原因是在这个过程中发生的一件可以说改变我命运的事。 由于过度的玩游戏，慢慢的我开始沉迷在里面，不想学习就想玩游戏，当时还有自己的一套歪理。“人生在世是为了什么？难道就是上学吗？不就是快快乐乐的生活吗？玩游戏能让我开心，能让我满足这就足够了，我为什么还要拼了命的学习？”，你们没有听错，这套理论已经上升到人生的高度了，现在想想也是可笑。人生在世身不由己，我们并非仅仅为自己活，还要为家庭为父母而活。我没有这么的豁达和洒脱，逃脱不了世俗的禁锢，就让我沉沦吧。 还好我的母亲及时把我带回了正途，当时有错学的想法后就在家里闹，不去上学，我妈也很强势，说什么也要让我去上。后来我问我妈当时为什么这么坚持，我妈说自己这一辈吃了没有文化的苦不能再让下一代也像自己一样一辈子只能种地。在这里我要再次感谢我的母亲，没有你的坚持就没有我现在开阔的眼界和见识。 浑浑噩噩 不知道大家有没有发现，男孩子相对女孩子要晚熟很多，就算是现在我自认在心智上依然幼稚（不代表思想），我的高中生涯更是在不成熟中浑浑噩噩度过。怎么来介绍我的高中生活呢？我高中花费了3+1年时间，有一年在复读，前三年确实是浑浑噩噩，因为那个时候我不清楚自己的目标是什么、不知道学习的意义是什么、不明白这么努力的学习能够给我带来什么、更不能理解如果不上好学的后果会是什么……当看到班级成绩好的同学在刻苦学习时我没有任何触动，终于在第一次高考成绩公布后我傻眼了，虽然之前一直没想过学习的结果会是什么，但是得到270分的高考成绩依然让我无法接受，看到别的同学进入本科学校自己更是羡慕。 这里简单介绍下，非江苏考生看到270的分数可能会觉的怎么这么低，其实这个分数在当时我们县城排名第二的高中内部算是中等成绩，因为江苏高考在未改革之前高考成绩的计算是只有语数外的，其它的如生物、物理、地理、化学这些科目只算ABC等级不进入分数计算。其实我的物理和生物当时是很好的，随便学学当时排进班级前十是没有问题的，因为喜欢。我也很无奈为什么江苏要这样算分，这样算下来语数外总分也就480，我又不喜欢不擅长语数外，结果也是可想而知的。 在第一年高考后的那一年暑假，我思考了很多关于未来应该何取何从，结果是下定决心去复读。当时我的想法是一定要再给自己一次机会，不留遗憾，并且自己要好好努力。接下来我就不详细叙述了，直接说结果，第二年高考我还是进步很大的比去年的分数足足高出1分，达到了历史纪录的271，直逼总分。其实再次失利也是预料之中，因为复读这一年的我依然是没有改掉之前的颓废之气，而且自己比较懒，惰性大……虽然我高考再次失利但是我不后悔，因为这一年是我思想开始成熟的元年，我不再是那个没有目标、理想、斗志的学生，我开始意识到学习的重要性，开始意识到努力的重要性，这也为后来步入大学生活的一系列表现埋下了伏笔。 斗志昂扬 经历了浑浑噩噩的高中生活，那种没有目标、没有激情、平庸至极的生活我真的是过够了，正巧经历了高考复读一年在心智上更加的成熟，所以在步入大学生活之初我就告诉自己要告别过去，重新开始。我当时的想法也很简单，先从告别平庸开始，先从突破自己开始。班级竞选班长、加入校学生会、成为学院辅导员助理、成为毕业协会成员、积极入党成为积极分子、成为党员…… 我当时信奉的奋斗哲理是有努力就有收获，当时的自己也是年少轻狂，认为只要自己想要得到的无论是什么都可以通过自己的努力得到（后面意识到也并不是全部）。结果也确实没有辜负我，从班长到辅导员助理、院学生会自律会副主席、国家助学金、国家奖学金、江苏省优秀学生干部、第八届中国花卉博览会优秀志愿者、中共党员……写这些东西不是说我有多优秀，其实现在看来我自认为还是很一般乃至是失败的，主要是想表达一个思想：青春不惜，奋斗不止！努力不一定有汇报，但是不努力一定没有汇报，我们要勇于出击，把握机遇。现在回想起常信奋斗时光依然激情澎湃，感谢学校的栽培、学校老师的教导。 逐渐成熟 不瞒各位，我的第一学历是专科，就读于常州信息职业技术学院，是一所专科院校，虽然是专科院校但是学校在师职质量、教育质量、学生服务质量、教学品质、学校环境、软硬件环境上在江苏省绝对是排的上名次的，而且最令我难忘和感激的是学校的每一位老师都很认真负责，他们真的是为学生着想，感谢我的母校。 在常信就读软件技术专业后由于学习成绩还可以（学院第一、二名，哈哈，我也很意外，当时也没想这么多）在毕业后就被学校推荐进入本科阶段学习，当时推荐供我选择的本科院校比较出名的有苏州科技、徐州矿业大学、南京晓庄学院，由于种种原因我选择了进入南京晓庄学院软件工程专业继续学习。这段本科学习经历怎么来评价呢？中规中矩吧！由于已经经历了一次毕业，经历了一次实习（2015年7月常信毕业，我于2015年3月到2015年9月在上海某小型互联网企业实习）所以自己想的更多的还是步入社会之后应该怎么办？我有自己的目标，自己的计划。即使在本科学习阶段我依然在为之后步入社会做准备，在学校期间我没有再像之前一样参加各种学生会团体，只是竞选了班级班长，然后长期从事软件项目兼职工作（服务于实习期的那一家上海小型互联网公司），当时的想法很简单就是磨练技术并且能够养活自己减轻家庭负担。 在南京晓庄学院最大的收获是认识了一群志同道合、有目标、肯努力、有想法的优秀年轻人，其中包括我一生中不可多得的几个挚友。在这里为专转本、专升本等一些起点低的学生说两句，其实学校、学历并不能代表一个人的全部，每一个群体都有良莠不齐的个体，只要一个人肯努力肯奋斗，知道自己想要什么并为之奋斗，那么这种同志就是优秀的，至少是不负吾生且值得尊重的。 步入社会 从南京晓庄学院毕业的时间是2017年7月份，现在回想起来真的跟昨天发生一样，时间过的真快！我真正的离校时间其实是2016年的11月份，离开学校后我依然继续就职于兼职的上海某互联网公司，从基础的软件开发工程师慢慢做到了项目经理，考取了PMP证书、软件设计师（中级）证书……其实我是一个不安分的人，喜欢折腾，但是在骨子里也是比较懒的人，这是我的缺点之一，可能是家族遗传吧，哈哈。 在上海的这家小公司工作了接近四年时间里我慢慢的迷失了自己，以前在学校期间的那种斗志慢慢没有了，自己的锐气也慢慢的被繁琐且重复的工作磨平了棱角。这不是我想要的生活，我发现自己慢慢的没有了成长的机会，没有了进步的空间，自己所做的工作太过于熟悉且没有挑战性，自己的生活也慢慢变的无趣。当时我就问自己这就是你自己想要的生活吗？你自己真正想要的是什么？是啊，我自己想要的是什么？于是我开始反思并制定了一系列的长期、中期、近期目标，首先要做的就是跳槽，进入理想的工作环境，做自己喜欢的工作，而不是为了生活打工。 未来畅想 未来不是一成不变的，恰恰相反未来是不断变化的，可能我们现在想好的未来场景、未来目标，在进行到某一个阶段后都会有所改变。但是无论如何变化，站在我的角度对未来的看法是“前途无限，拥有无限可能”，随着我国的复兴（我相信也一定能够复兴）各行各业都将会繁荣发展，今后的互联网将融入社会各种传统行业，真正实现李克强总理提出的互联网+，作为互联网人我愿为此尽自己的一点薄力。 扯的有点远，回归正题，我认为对我们这些不是富二代、没有背景的普通人来说经营好自己的生活就是最好的，其实未来也是生活的一部分，未来太远，现在的脚踏实地才是现实。“过去的我们无法改变、未来的我们触摸不到，只有现在才是我们能够把握的，因为做好了现在，未来才会被影响才会更好！”这是我常信奋斗生涯中总结出的人生哲理之一。没错，工作只是生活的一部分，做自己喜欢的事情才最幸福，把握现在，抓住机遇，认真对待每一天，即使将来没能达成多大的成就我们也可以对自己及自己的孩子说“不负吾生”！大家一起加油！ var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/11/introduction/"},{"title":"Activiti数据库表结构说明","text":"数据库表名说明Activiti工作流总共包含23张数据表，所有的表名默认以“ACT_”开头.并且表名的第二部分用两个字母表明表的用例，而这个用例也基本上跟Service API匹配 ACT_GE_* : “GE”代表“General”（通用），用在各种情况下； ACT_HI_* : “HI”代表“History”（历史），这些表中保存的都是历史数据，比如执行过的流程实例、变量、任务，等等。Activit默认提供了4种历史级别： none: 不保存任何历史记录，可以提高系统性能； activity：保存所有的流程实例、任务、活动信息； audit：也是Activiti的默认级别，保存所有的流程实例、任务、活动、表单属性； full：最完整的历史记录，除了包含audit级别的信息之外还能保存详细，例如：流程变量。对于几种级别根据对功能的要求选择，如果需要日后跟踪详细可以开启full。 ACT_ID_* : “ID”代表“Identity”（身份），这些表中保存的都是身份信息，如用户和组以及两者之间的关系。如果Activiti被集成在某一系统当中的话，这些表可以不用，可以直接使用现有系统中的用户或组信息； ACT_RE_* : “RE”代表“Repository”（仓库），这些表中保存一些‘静态’信息，如流程定义和流程资源（如图片、规则等）； ACT_RU_* : “RU”代表“Runtime”（运行时），这些表中保存一些流程实例、用户任务、变量等的运行时数据。Activiti只保存流程实例在执行过程中的运行时数据，并且当流程结束后会立即移除这些数据，这是为了保证运行时表尽量的小并运行的足够快； 数据库表结构 表分类 表名 说明 一般数据 ACT_GE_BYTEARRAY 通用的流程定义和流程资源 一般数据 ACT_GE_PROPERTY 系统相关属性 流程历史记录 ACT_HI_ACTINST 历史的流程实例（只记录UserTask类型） 流程历史记录 ACT_HI_ATTACHMENT 历史的流程附件 流程历史记录 ACT_HI_COMMENT 历史的说明性信息 流程历史记录 ACT_HI_DETAIL 历史的流程运行中的细节信息 流程历史记录 ACT_HI_IDENTITYLINK 历史的流程运行过程中用户关系 流程历史记录 ACT_HI_PROCINST 历史的流程实例（包括正运行的） 流程历史记录 ACT_HI_TASKINST 历史的任务实例（包括正运行的） 流程历史记录 ACT_HI_VARINST 历史的流程运行中的变量信息（包括正运行的） 用户表 ACT_ID_GROUP 用来存储用户组信息 用户表 ACT_ID_INFO 用户扩展信息表。目前该表未用到。 用户表 ACT_ID_MEMBERSHIP 用来保存用户的分组信息 用户表 ACT_ID_USER 身份信息-用户信息 流程定义表 ACT_RE_DEPLOYMENT 用来存储部署时需要持久化保存下来的信息 流程定义表 ACT_RE_MODEL 创建流程的设计模型时，保存在该数据表中。 流程定义表 ACT_RE_PROCDEF 流程解析表，解析成功了，在该表保存一条记录。业务流程定义数据表 运行实例表 ACT_RU_EVENT_SUBSCR 运行时事件 运行实例表 ACT_RU_EXECUTION 运行时流程执行实例（记录当前节点信息） 运行实例表 ACT_RU_IDENTITYLINK 主要存储当前节点参与者的信息,任务参与者数据表。 运行实例表 ACT_RU_JOB 运行时定时任务数据表 运行实例表 ACT_RU_TASK （执行中实时任务）代办任务查询表 运行实例表 ACT_RU_VARIABLE 运行时变量表 主要表简要说明ACT_GE_BYTEARRAY通用的流程定义和流程资源，用来保存部署文件的大文本数据。 保存流程定义图片和xml、Serializable(序列化)的变量,即保存所有二进制数据，特别注意类路径部署时候，不要把svn等隐藏文件或者其他与流程无关的文件也一起部署到该表中，会造成一些错误（可能导致流程定义无法删除）。 ACT_GE_PROPERTY系统相关属性，属性数据表。存储这个流程引擎级别的数据。 ACT_HI_ACTINST历史活动信息。这里记录流程流转过的所有节点，与HI_TASKINST不同的是，taskinst只记录usertask内容。 ACT_HI_DETAIL历史详情表：流程中产生的变量详细，包括控制流程流转的变量，业务表单中填写的流程需要用到的变量等。 备注：VAR_TYPE_类型说明: jpa-entity、boolean、bytes、serializable(可序列化)、自定义type(根据你自身配置)、 CustomVariableType、date、double、integer、long、null、short、string ACT_HI_IDENTITYLINK历程流程人员表，任务参与者数据表。主要存储历史节点参与者的信息。 ACT_RE_PROCDEF流程解析表，解析成功了，在该表保存一条记录。业务流程定义数据表 注：此表和ACT_RE_DEPLOYMENT是多对一的关系，即，一个部署的bar包里可能包含多个流程定义文件，每个流程定义文件都会有一条记录在ACT_RE_PROCDEF表内，每个流程定义的数据，都会对于ACT_GE_BYTEARRAY表内的一个资源文件和PNG图片文件。和ACT_GE_BYTEARRAY的关联是通过程序用ACT_GE_BYTEARRAY.NAME与ACT_RE_PROCDEF.NAME_完成的，在数据库表结构中没有体现。 Activiti中主要对象的关系本节主要介绍在工作流中出现的几个对象及其之间的关系，以及在Activiti中各个对象是如何关联的。 我们模拟一个请假的流程进行分析介绍，该流程主要包含以下几个步骤： 员工申请请假 部门领导审批 人事审批 员工销假 ProcessInstance对象员工开始申请请假流程，通过runtimeService.startProcessInstance()方法启动，引擎会创建一个流程实例（ProcessInstance）。 简单来说流程实例就是根据一次（一条）业务数据用流程驱动的入口，两者之间是一对一的关系。流程引擎会创建一条数据到ACT_RU_EXECUTION表，同时也会根据history的级别决定是否查询相同的历史数据到ACT_HI_PROCINST表。 启动完流程之后业务和流程已经建立了关联关系，第一步结束。 启动流程和业务关联区别： 对于自定义表单来说启动的时候会传入businessKey作为业务和流程的关联属性 对于动态表单来说不需要使用businessKey关联，因为所有的数据都保存在引擎的表中 对于外部表单来说businessKey是可选的，但是一般不会为空，和自定义表单类似 Execution对象对于初学者来说，最难理解的地方就是ProcessInstance与Execution之间的关系，要分两种情况说明。Execution的含义就是一个流程实例（ProcessInstance）具体要执行的过程对象。 不过在说明之前先声明两者的对象映射关系： ProcessInstance（1）→ Execution(N)，（其中N&gt;=1）。 1) 值相等的情况： 除了在流程中启动的子流程之外，流程启动之后在表ACT_RU_EXECUTION中的字段ID_和PROC_INST_ID_字段值是相同的。 2) 值不相等的情况： 不相等的情况目前只会出现在子流程中（包含：嵌套、引入），例如一个购物流程中除了下单、出库节点之外可能还有一个付款子流程，在实际企业应用中付款流程通常是作为公用的，所以使用子流程作为主流程（购物流程）的一部分。 Task对象前面说了ProcessInstance和业务是一对一关联的，和业务数据最亲密；而Task则和用户最亲密的（UserTask），用户每天的待办事项就是一个个的Task对象。 Task是在流程定义中看到的最大单位，每当一个Task完成的时候引擎会把当前的任务移动到历史中，然后插入下一个任务插入到表ACT_RU_TASK中。结合请假流程来说就是让用户点击“完成”按钮提交当前任务是的动作，引擎自动根据任务的顺序流或者排他分支判断走向。 HistoryActivity（历史活动）Activity包含了流程中所有的活动数据，例如开始事件（图5表中的第1条数据）、各种分支（排他分支、并行分支等，图5表中的第2条数据）、以及刚刚提到的Task执行记录 有些人认为Activity和Task是多对一关系，其实不是，从上图中可以看出来根本没有Task相关的字段。 结合请假流程来说，如Task中提到的当完成流程的时候所有下一步要执行的任务（包括各种分支）都会创建一个Activity记录到数据库中。例如领导审核节点点击“同意”按钮就会流转到人事审批节点，如果“驳回”那就流转到调整请假内容节点，每一次操作的Task背后实际记录更详细的活动（Activity）。 参考资料: [1]https://blog.csdn.net/hj7jay/article/details/51302829 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/22/activititable/"},{"title":"IDEA集成activiti作图工具","text":"IDEA中安装activiti工具 打开IDEA中File列表下的Settings 输入actiBPM，然后点击下面的Search…搜索 点击Install 下载 下载结束后应用保存，然后重启IDEA 创建流程文件 右键new，点击BpmnFeil,然后取个名 会出现界面 鼠标左键拖拽StartEvent到界面上，同样再弄几个其他图标 鼠标放到图标中心会变成黑白扇形，拖拽连线到另一个图标进行画图 右键进行改名，把后缀改为.xml结尾 出现这个界面点击箭头指的图标 选择刚开始创建的文件夹 出现带后缀为.png的就对了 参考资料： [1]https://blog.csdn.net/qq_41728540/article/details/79506463 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/30/activitidea/"},{"title":"IDEA集成activiti的常见问题","text":"BPMN设计图中的乱码问题 需要在这两个文件下的后面都加上-Dfile.encoding=UTF-8 然后重启IDEA，把原来的PNG图片删掉，再生成一次就不会出现乱码了 设置自定义参数的节点必须进行参数传递 如上流程图，在“请假天数判断”设置了days参数用于路径选择，那么在该节点的上一节点完成时必须设定days参数并传递，否则在流转到“请假天数判断”时会报错，缺少days var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/30/activitierror/"},{"title":"activiti与Springboot集成配置","text":"第一步：添加项目依赖 12345&lt;dependency&gt;&lt;groupId&gt;org.activiti&lt;/groupId&gt;&lt;artifactId&gt;activiti-spring-boot-starter-basic&lt;/artifactId&gt;&lt;version&gt;6.0.0&lt;/version&gt;&lt;/dependency&gt; 第二步：配置activiti配置文件（springboot的配置文件）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.jntech.config;import com.jntech.common.utils.CustomLog;import org.activiti.engine.delegate.event.ActivitiEventListener;import org.activiti.spring.SpringProcessEngineConfiguration;import org.activiti.spring.boot.AbstractProcessEngineAutoConfiguration;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.Resource;import org.springframework.core.io.support.ResourcePatternResolver;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.util.CollectionUtils;import javax.sql.DataSource;import java.io.IOException;import java.util.*;@Configuration//@MapperScan(basePackages = &quot;com.jntech.dao.mysql&quot;, sqlSessionTemplateRef = &quot;mysqlSqlSessionTemplate&quot;)//@PropertySource(&quot;classpath:application.properties&quot;)public class DataSourceActivitiConfig extends AbstractProcessEngineAutoConfiguration {@Autowiredprivate ResourcePatternResolver resourceLoader;@Bean(name = &quot;activitiDataSource&quot;)@ConfigurationProperties(prefix = &quot;spring.datasource.local&quot;)//@Primarypublic DataSource testDataSource() {return DataSourceBuilder.create().build();}@Bean(name = &quot;activitiSqlSessionFactory&quot;)// @Primarypublic SpringProcessEngineConfiguration springProcessEngineConfiguration(@Qualifier(&quot;activitiDataSource&quot;) DataSource dataSource,@Qualifier(&quot;activitiTransactionManager&quot;) PlatformTransactionManager transactionManager) throws IOException {SpringProcessEngineConfiguration configuration = new SpringProcessEngineConfiguration();configuration.setDataSource(dataSource);//配置数据源configuration.setTransactionManager(transactionManager);//配置transactionconfiguration.setDatabaseSchemaUpdate(&quot;true&quot;);//每次项目启动是否更新数据库表(第一次运行项目需要设为true，activiti将在数据库建表)configuration.setAsyncExecutorActivate(true);//是否激活异步执行器configuration.setHistory(&quot;audit&quot;);//流程历史记录登录configuration.setCreateDiagramOnDeploy(true);//部署流程定义时是否生成图片（新流程部署时或数据库初始化时）configuration.setActivityFontName(&quot;\\\\u5b8b\\\\u4f53&quot;);//字体 下面内容为转成unicode的'宋体'configuration.setLabelFontName(&quot;\\\\u5b8b\\\\u4f53&quot;);//字体 下面内容为转成unicode的'宋体'//设置指定的流程图文件资源List&lt;Resource&gt; procDefResources = discoverProcessDefinitionResources(&quot;classpath*:/processes/&quot;, Arrays.asList(&quot;**.bpmn20.xml&quot;, &quot;**.bpmn&quot;),true);configuration.setDeploymentResources(procDefResources.toArray(new Resource[procDefResources.size()]));//设置流程监听器Map&lt;String, List&lt;ActivitiEventListener&gt;&gt; typedListeners = new HashMap&lt;&gt;();/*typedListeners.put(&quot;ENTITY_CREATED&quot;, Collections.singletonList(entityCreatedListener));typedListeners.put(&quot;TASK_CREATED&quot;, Collections.singletonList(taskCreatedListener));typedListeners.put(&quot;TASK_COMPLETED&quot;, Collections.singletonList(taskCompletedListener));*/configuration.setTypedEventListeners(typedListeners);return configuration;}@Bean(name = &quot;activitiTransactionManager&quot;)//@Primarypublic DataSourceTransactionManager testTransactionManager(@Qualifier(&quot;activitiDataSource&quot;) DataSource dataSource) {return new DataSourceTransactionManager(dataSource);}/*** 获取指定的流程图文件资源* @param prefix 路径前缀* @param suffixes 文件后缀* @param checkPDs 如果checkProcessDefinitions为true，则发布新版流程定义，后续可能根据流程定义文件MD5等判断是否真正变化而进行发布* @return* @throws IOException*/private List&lt;Resource&gt; discoverProcessDefinitionResources(String prefix, List&lt;String&gt; suffixes, boolean checkPDs) throws IOException {if (checkPDs) {List&lt;Resource&gt; result = new ArrayList();for (String suffix : suffixes) {String path = prefix + suffix;Resource[] resources = resourceLoader.getResources(path);if (resources != null &amp;&amp; resources.length &gt; 0) {CollectionUtils.mergeArrayIntoCollection(resources, result);}}if (result.isEmpty()) {CustomLog.getInstance().createLogger(&quot;No process definitions were found for autodeployment&quot;);}return result;}return new ArrayList&lt;&gt;();}} databaseSchemaUpdate配置项可以设置流程引擎启动和关闭时数据库执行的策略。 databaseSchemaUpdate有以下四个值： false：false为默认值，设置为该值后，Activiti在启动时，会对比数据库表中保存的版本，如果没有表或者版本不匹配时，将在启动时抛出异常。 true：设置为该值后，Activiti会对数据库中所有的表进行更新，如果表不存在，则Activiti会自动创建。 create-drop：Activiti启动时，会执行数据库表的创建操作，在Activiti关闭时，执行数据库表的删除操作。 drop-create：Activiti启动时，执行数据库表的删除操作在Activiti关闭时，会执行数据库表的创建操作。 Activiti提供了history-level属性对其进行配置。history-level属性有点像log4j的日志输出级别，该属性有以下四个值： none：不保存任何的历史数据，因此，在流程执行过程中，这是最高效的。 activity：级别高于none，保存流程实例与流程行为，其他数据不保存。 audit：除activity级别会保存的数据外，还会保存全部的流程任务及其属性。audit为history的默认值。 full：保存历史数据的最高级别，除了会保存audit级别的数据外，还会保存其他全部流程相关的细节数据，包括一些流程参数等。 第三步 多数据源下配置activiti数据源（非多数据源请跳过）只需要借助springboot在配置activiti配置文件的时候制定数据源即可，详情可见“第二步” 第四步 将流程文件放入项目指定路径内例如放入resources-&gt;processes-&gt;xxxx.xml 第五步 调用activiti提供的基础工具类实现流程操作activiti仅仅提供了基础的针对流程对象的操作，我们可以利用基础功能进行封装，将流程创建，流程终止等功能完整自行封装，以提供对外能力。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/30/activitispring/"},{"title":"activiti事件监听","text":"工作流程事件监听可用于任务提醒、超时提醒等的模块的设计。以下是相关事件的介绍 事件监听类型 ENGINE_CREATED 监听器监听的流程引擎已经创建完毕，并准备好接受API调用。 ENGINE_CLOSED 监听器监听的流程引擎已经关闭，不再接受API调用。 ENTITY_CREATED 创建了一个新实体。实体包含在事件中。 ENTITY_INITIALIZED 创建了一个新实体，初始化也完成了。如果这个实体的创建会包含子实体的创建，这个事件会在子实体都创建/初始化完成后被触发，这是与ENTITY_CREATED的区别。 ENTITY_UPDATED 更新了已存在的实体。实体包含在事件中。 ENTITY_DELETED 删除了已存在的实体。实体包含在事件中。 ENTITY_SUSPENDED 暂停了已存在的实体。实体包含在事件中。会被ProcessDefinitions, ProcessInstances 和 Tasks抛出。 ENTITY_ACTIVATED 激活了已存在的实体，实体包含在事件中。会被ProcessDefinitions, ProcessInstances 和 Tasks抛出。 JOB_EXECUTION_SUCCESS 作业执行成功。job包含在事件中。 JOB_EXECUTION_FAILURE 作业执行失败。作业和异常信息包含在事件中。 JOB_RETRIES_DECREMENTED 因为作业执行失败，导致重试次数减少。作业包含在事件中。 TIMER_FIRED 触发了定时器。job包含在事件中。 JOB_CANCELED 取消了一个作业。事件包含取消的作业。作业可以通过API调用取消， 任务完成后对应的边界定时器也会取消，在新流程定义发布时也会取消。 ACTIVITY_STARTED 一个节点开始执行 ACTIVITY_COMPLETED 一个节点成功结束 ACTIVITY_SIGNALED 一个节点收到了一个信号 ACTIVITY_MESSAGE_RECEIVED 一个节点收到了一个消息。在节点收到消息之前触发。收到后，会触发ACTIVITY_SIGNAL或ACTIVITY_STARTED，这会根据节点的类型（边界事件，事件子流程开始事件） ACTIVITY_ERROR_RECEIVED 一个节点收到了一个错误事件。在节点实际处理错误之前触发。 事件的activityId对应着处理错误的节点。 这个事件后续会是ACTIVITY_SIGNALLED或ACTIVITY_COMPLETE， 如果错误发送成功的话。 UNCAUGHT_BPMN_ERROR 抛出了未捕获的BPMN错误。流程没有提供针对这个错误的处理器。 事件的activityId为空。 ACTIVITY_COMPENSATE 一个节点将要被补偿。事件包含了将要执行补偿的节点id。 VARIABLE_CREATED 创建了一个变量。事件包含变量名，变量值和对应的分支或任务（如果存在）。 VARIABLE_UPDATED 更新了一个变量。事件包含变量名，变量值和对应的分支或任务（如果存在）。 VARIABLE_DELETED 删除了一个变量。事件包含变量名，变量值和对应的分支或任务（如果存在）。 TASK_ASSIGNED 任务被分配给了一个人员。事件包含任务。 TASK_CREATED 创建了新任务。它位于ENTITY_CREATE事件之后。当任务是由流程创建时， 这个事件会在TaskListener执行之前被执行。 TASK_COMPLETED 任务被完成了。它会在ENTITY_DELETE事件之前触发。当任务是流程一部分时，事件会在流程继续运行之前， 后续事件将是ACTIVITY_COMPLETE，对应着完成任务的节点。 TASK_TIMEOUT 任务已超时，在TIMER_FIRED事件之后，会触发用户任务的超时事件， 当这个任务分配了一个定时器的时候。 PROCESS_COMPLETED 流程已结束。在最后一个节点的ACTIVITY_COMPLETED事件之后触发。 当流程到达的状态，没有任何后续连线时， 流程就会结束。 MEMBERSHIP_CREATED 用户被添加到一个组里。事件包含了用户和组的id。 MEMBERSHIP_DELETED 用户被从一个组中删除。事件包含了用户和组的id。 MEMBERSHIPS_DELETED 所有成员被从一个组中删除。在成员删除之前触发这个事件，所以他们都是可以访问的。 因为性能方面的考虑，不会为每个成员触发单独的MEMBERSHIP_DELETED事件。 示例创建监听器 12345678910111213141516171819202122232425262728293031package com.jntech.config;import org.activiti.engine.delegate.event.ActivitiEntityEvent;import org.activiti.engine.delegate.event.ActivitiEvent;import org.activiti.engine.delegate.event.ActivitiEventListener;import org.activiti.engine.impl.persistence.entity.TaskEntity;import org.springframework.stereotype.Component;/*** packageName：com.jntech.config* class：EntityCreatedListener* describe：activiti流程对象创建监听器（每一个流程节点创建时均会出发及一个流程初始化是如果其有六个流程节点则会触发六次）* author：mahao* time：19:31-2018/12/16* modify by:请输入修改人* modify time：请输入修改时间* version：V1.0*/@Componentpublic class EntityCreatedListener implements ActivitiEventListener {public void onEvent(ActivitiEvent event){Object entity = ((ActivitiEntityEvent)event).getEntity();if(entity instanceof TaskEntity){TaskEntity taskEntity = (TaskEntity)entity;//自身业务代码}}public boolean isFailOnException(){return true;}} 监听器注册（修改springboot中的activiti配置文件） 1234567891011121314151617181920212223242526@Autowiredprivate EntityCreatedListener entityCreatedListener;@Bean(name = &quot;activitiSqlSessionFactory&quot;)// @Primarypublic SpringProcessEngineConfiguration springProcessEngineConfiguration(@Qualifier(&quot;activitiDataSource&quot;) DataSource dataSource,@Qualifier(&quot;activitiTransactionManager&quot;) PlatformTransactionManager transactionManager) throws IOException {SpringProcessEngineConfiguration configuration = new SpringProcessEngineConfiguration();configuration.setDataSource(dataSource);//配置数据源configuration.setTransactionManager(transactionManager);//配置transactionconfiguration.setDatabaseSchemaUpdate(&quot;true&quot;);//每次项目启动是否更新数据库表(第一次运行项目需要设为true，activiti将在数据库建表)configuration.setAsyncExecutorActivate(true);//是否激活异步执行器configuration.setHistory(&quot;audit&quot;);//流程历史记录登录configuration.setCreateDiagramOnDeploy(true);//部署流程定义时是否生成图片（新流程部署时或数据库初始化时）configuration.setActivityFontName(&quot;\\\\u5b8b\\\\u4f53&quot;);//字体 下面内容为转成unicode的'宋体'configuration.setLabelFontName(&quot;\\\\u5b8b\\\\u4f53&quot;);//字体 下面内容为转成unicode的'宋体'//设置指定的流程图文件资源List&lt;Resource&gt; procDefResources = discoverProcessDefinitionResources(&quot;classpath*:/processes/&quot;, Arrays.asList(&quot;**.bpmn20.xml&quot;, &quot;**.bpmn&quot;),true);configuration.setDeploymentResources(procDefResources.toArray(new Resource[procDefResources.size()]));//设置流程监听器Map&lt;String, List&lt;ActivitiEventListener&gt;&gt; typedListeners = new HashMap&lt;&gt;();typedListeners.put(&quot;ENTITY_CREATED&quot;, Collections.singletonList(entityCreatedListener));/*typedListeners.put(&quot;TASK_CREATED&quot;, Collections.singletonList(taskCreatedListener));typedListeners.put(&quot;TASK_COMPLETED&quot;, Collections.singletonList(taskCompletedListener));*/configuration.setTypedEventListeners(typedListeners);return configuration;} 其它监听器 123456789101112// 关于监听器的注册看上面配置类中typedListeners部分已有@Componentpublic class TaskCompletedListener implements ActivitiEventListener {public void onEvent(ActivitiEvent event){TaskEntity taskEntity = (TaskEntity)((ActivitiEntityEvent)event).getEntity();taskEntity.setVariable(&quot;fromTaskIdVarKey&quot;, taskEntity.getId());}public boolean isFailOnException(){return true;}} 12345678910111213141516@Componentpublic class TaskCreatedListener implements ActivitiEventListener {public void onEvent(ActivitiEvent event){TaskEntity taskEntity = (TaskEntity)((ActivitiEntityEvent)event).getEntity();String fromTaskId = (String)taskEntity.getVariable(WfVarKeyConstants.fromTaskId);if(StringUtils.isEmpty(fromTaskId)) return;xxxTaskInfo info = new xxxTaskInfo();info.setId(taskEntity.getId());info.setFromId(fromTaskId);//此处进行任务关系持久化，自行实现xxxTaskInfoRepository.save(info);}public boolean isFailOnException(){return true;}} 参考资料： [1]https://blog.csdn.net/zhangdaiscott/article/details/80944389 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/30/activitilisten/"},{"title":"activiti实现流程回退","text":"activiti流程回退功能在原始api中并没有提供，需要我们自行实现，现有如下几种思路 提供思路 复制流程 关闭当前流程并获取当前流程已执行节点信息（截止到当前节点的上一节点），创建新流程并将获取的已执行节点信息赋值系统控制走流程 修改数据库 获取上一节点任务信息，修改当前节点信息为上一节点任务信息，需要修改数据库表，如下： ACT_RU_TASK 正在运行的任务节点表 ACT_RU_EXECUTION 运行时流程执行实例表 ACT_HI_TASKINST 历史任务节点表(包括正在运行的) ACT_RU_IDENTITYLINK 任务与人员关联表 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/30/activitiback/"},{"title":"activiti案例运行及资源包简介","text":"本文将针对activiti官网提供的资源包以及案例程序做详细介绍，以方便初入人员快速了解activiti 官网下载activiti资源包https://www.activiti.org 资源包解压后得到如下图结构： tomcat运行activiti-app.waractiviti-app.war是activiti提供的供本地流程图制作、流程测试的工具软件 activiti使用 流程的运行依赖于流程图以及人员、角色组，因此我们首先需要新建用户用于执行流程，以简易的请假流程来作为示范。 进入idenity management 选择用户选项卡进行用户新建 进入APP创建流程process 将流程节点与用户进行绑定 进入APP并创建APP 指定APP所包含的流程 发布APP 员工账户登录发起流程 管理人员登录系统审批流程 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/30/activitisource/"},{"title":"activiti简介","text":"七大接口 RepositoryService：提供一系列管理流程部署和流程定义的API。 RuntimeService：在流程运行时对流程实例进行管理与控制。 TaskService：对流程任务进行管理，例如任务提醒、任务完成和创建任务等。 IdentityService：提供对流程角色数据进行管理的API，这些角色数据包括用户组、用户及它们之间的关系。 ManagementService：提供对流程引擎进行管理和维护的服务。 HistoryService：对流程的历史数据进行操作，包括查询、删除这些历史数据。 FormService：表单服务。 结构关系 数据库表结构 1、act_ge_ 通用数据表，ge是general的缩写 2、act_hi_ 历史数据表，hi是history的缩写，对应HistoryService接口 3、act_id_ 身份数据表，id是identity的缩写，对应IdentityService接口 4、act_re_ 流程存储表，re是repository的缩写，对应RepositoryService接口，存储流程部署和流程定义等静态数据 5、act_ru_ 运行时数据表，ru是runtime的缩写，对应RuntimeService接口和TaskService接口，存储流程实例和用户任务等动态数据 流程处理 说明：关于人员指派我们再做流程图时可以指定具体某节点对应的用户或用户组，这种情况下无需指派人员操作，流程自动识别。若流程图中未指定人员，我们可以通过代码的方式手动指定人员id 流程发布更新问题场景如下：流程图制作完毕并交付项目使用，在使用一段时间后发现流程需要调整，需要将最新流程文件xml进行替换 原理：xml流程文件即为流程图的规则，在执行流程的过程中activiti流程引擎回去解析，如果流程执行到某节点，那么该节点的xml对应信息将会被解析存储进数据库成为可持久化数据。 流程结构不变，需要针对参数等微调：直接将xml流程文件进行替换即可 流程结构变化：如果该流程某业务已经执行了一部分则不建议直接替换需要等流程走通后替换。 影响: 如果流程没被使用则随时可以替换，无影响 如果流程正在被使用，那么已经执行的流程节点已经被持久化至数据库，即使替换流程图也无法更改，未执行节点将按照新版流程图进行 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/22/activitiIntroduction/"},{"title":"hexo主题icarus添加评论插件gitalk","text":"一、gitalk简介我们在利用github搭建个人博客的时候通常需要添加评论功能，以方便博主同其他志同道合的朋友进行交流。github本身是提供第三方api接入服务的，一些第三方服务提供方可以利用github提供的接口针对具体某github账户下的仓库进行操作，比如我们想要实现通过第三方服务针对自身账户下的某仓库进行远程添加issue问题功能等。 正巧，github内总是有项目能够满足我们的需求。gitalk正是针对github评论功能而开发的第三方服务项目，除此之外还有gitment等，但是gitment很久没有维护了，本片文章针对gitalk进行详细应用介绍。 二、需求场景介绍gitalk如何自定义配置到自己的博客？具体的操作大家可以访问gitalk的原网址教程，介绍的很详细，使用也相对简单。不过要说声抱歉的是，由于本人使用的hexo模板是icarus，而这个模板其实已经帮助使用者将各种评论插件集成，例如gitalk，gitment，isso，disqus等，使用者只需要在主题的配置文件_config.yml中配置好相应的参数即可。 三、具体步骤3.1、创建github授权应用登录github后（首先需要有github账户），一次点击settings/Developer settings/OAuth Apps，选择New OAuth App，将会看到如下界面： application name:自行取名，建议英文 Homepage URL:自己博客的地址即可，如https://monkeyGeek369.github.io description:输入描述 callback URL:服务授权回调地址，也填写博客地址即可，如https://monkeyGeek369.github.io 创建成功后将看到如下界面： 其中Client ID和Client Secret将是我们后面用到的。 3.2、在主题中配置id和密钥进入主题文件夹，打开_config.yml，进行如下设置： 12345678comment: # Name of the comment plugin type: gitalk owner: monkeyGeek369 # github用户名 repo: monkeyGeek369.github.io # github仓库名称，即博客仓库名称 client_id: # (required) OAuth application client id client_secret: # (required) OAuth application client secret admin: monkeyGeek369 # 指定本仓库的管理方账户名称，即拥有权限去调用授权接口的github账户 3.3、博客仓库issue功能开启点击博客仓库—点击settings，进行如下勾选设置 3.4、添加第一条评论进入博客文章页面，添加第一条博客即可 四、问题解决4.1、初始化问题 我们在成功配置好评论插件后或许会出现以上问题，这种问题在gitalk中有详细介绍，大家也可以去gitalk查看详细解决方案。这种问题通常是由于博主未给文章评论初始化，博主只需要登陆github账户即可。 4.2、面对issues时选择登录github账户后出现404错误这个问题是因为github的issue问题label不能超过50个字符，label通常由gitalk自动取自当前博文页面的URL的pathname，所以必须确保我们的pathname足够短。需要准寻如下规则; 需要在hexo的_config.yml中设置永久链接规则，如permalink: :year/:id/ # 网站的永久链接格式 文章的永久链接尽量不要使用:title，如果非要使用那么尽可能使用英文，因为中文解析出来字符会非常多 关于这个问题可以去看本站点内的“五、关于写作的那些事” 关于这个问题还有其它解决方案，例如在gitalk配置文件内将lable的获取规则进行修改，进行md5加密等。详情可以看问题连接 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/icarus/"},{"title":"一、hexo基础环境准备","text":"简介 根据hexo官网简介hexo是一个快速、简介且高效的博客框架。hexo使用markdown解析文章，可以在几秒内利用靓丽主题生成静态网页。本系列教程是以官网简介为基础再加上实际操作经验总结所写，看到这里证明大家希望搭建自己的技术了乐园，那么请细心往下看，避免后期踩坑。 nodeJS安装 nodeja是一款优秀的js服务器软件，安装教程也是十分简单，只需下载下来双击打开，一直点击下一步傻瓜安装即可。下载网址 https://nodejs.org/en/，当安装成功后可输入cmd进入命令控制器输入node -v 如果出现版本号则证明安装成功。 git安装 关于git的系列教程小伙伴可以去看我写的git相关博文，在这里简而言之，git的安装类似于nodejs，均是傻瓜安装模式，安装成功后鼠标右键若出现git bash here即证明安装成功，点击此即可进入git命令控制器 hexo安装 在确保nodejs与git安装成功后即可进行hexo的安装，hexo的安装需要我们指定安装地址，例如我们想要安装到D盘的myblog文件夹，那么首先需要手动创建该文件夹，创建成功后进入该文件夹并鼠标右击git bash here在此文件夹打开git命令控制器，输入如下命令即可实现hexo安装。 npm install -g hexo-cli 注意：本教程基于windows系统，mac或linux等系统的环境安装请参考官网 https://hexo.io/zh-cn/docs/ var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/environment/"},{"title":"七、hexo中md文档插入图片问题","text":"插入图片的途径 我们知道md文档仅仅是作为文字信息的载体，如果需要插入类似图片这种附件对象则需要通过其他手段，方法如下： 1、将图片放入外部服务器，md文档中引用图片链接即可 2、将图片放在博客静态站点内，md文档使用相对路径引用即可 总之，图片的引用一定是引用连接的形式 如何实现高效插入图片（以相对路径的方式） 1、手动在source文件夹内创建如image名称的文件夹 2、将需要引用的图片放入该文件夹 3、使用md编辑器Typora打开需要编辑的文章md文件，选择插入图片并选择image中的图片即可 注意：（假设source子目录存在image文件夹，用于存放图片） 1、使用html标签插入图片路径问题 使用html标签插入图片需满足如下条件： hexo中的_config.yml配置永久链接，如permalink: :year/:i_month/:i_day/:enname/ # 网站的永久链接格式 由永久链接对应的public生成路径为“年/月/日/文章英文名称” md文件中插入图片，设置路径如下 1&lt;img style=&quot;height:auto; width:auto;flot:left;&quot; src=&quot;../../../../image/monkey64.png&quot; /&gt; 注意有四个跳出，因为source中的image文件夹在执行hexo g后将在public一级子目录下生成对应的image文件夹 2、使用md直接插入图片路径问题 与html插入图片不同，如果直接通过md插入图片，在设置相对路径时只需要根据source文件夹下的md文件与image文件夹相对路径设置即可。 例如 1thumbnail: ../../image/mdmenuset.png 如果在内容区插入图片依然要依据永久链接相对路径如 1![](../../../../image/githubblogtheme.png) var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/mdimage/"},{"title":"三、hexo基础命令","text":"命令 类型 作用 hexo init [folder] init 初始化hexo，如果未指定文件夹则在当前目录生成 hexo new [layout] new 新建文章，可以选择layout布局类型和title文章名称 hexo g generate 将source文章文件夹内的文章生成html静态站点文件至public文件夹 hexo publish [layout] publish 发布草稿文件，草稿文件为source文件夹内的draft文件夹文件，后面新建文章时会介绍 hexo s server 启动public文件夹内生成的动态站点文件，默认发布端口为4000，可通过http://localhost:4000进行访问。可使用--port重设端口，--static只使用静态文件，--log启动日志记录。使用时如 hexo s –port 4001 修改端口为40001 hexo d deploy 部署public文件夹内生成的静态站点文件，部署指的是将其部署至git等远程仓库，需要在hexo的_config.yml文件夹内配置远程仓库连接。详情可查看“二、hexo结构简介”中的部署配置 hexo render [file2] … render 渲染文件，实际没用过，效果未知 hexo migrate migrate 从其他博客系统迁移内容，目前还未用过 hexo clean clean 清空public文件夹生成的静态站点文件和db.json缓存文件 hexo list list 列出网站资料 hexo version version 显示hexo版本 hexo –safe option 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 hexo –debug option 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 hexo –silent option 隐藏终端信息。 hexo –config custom.yml option 自定义配置文件的路径，执行后将不再使用 _config.yml。 hexo –draft option 显示 source/_drafts 文件夹中的草稿文章。 hexo –cwd /path/to/cwd option 自定义当前工作目录（Current working directory）的路径。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/basecom/"},{"title":"九、github自建博客实现域名绑定与解析","text":"用户域名绑定 总所周知我们通过github来实现自建博客利用的其实是github提供的githubpage服务，github page本身是支持自定义域名绑定的，如果我们觉的使用“你的用户名.github.io”来访问博客站点比较费力可以绑定自己购买到的域名。 如何购买域名？ 购买域名非常简单，渠道也非常多，例如可以去万网、阿里云、腾讯云、华为域名等等地方去购买一个域名，这里就不详细介绍了。 如何获取博客站点的真实ip地址？ 这里先说一下如何获取博客站点的真实ip地址，因为我们在购买域名后需要做域名解析，说白了就是告诉DNS服务器，我们的这个域名应该指向哪里，可以指向某ip地址也可以指向其它域名。 windows机器在屏幕左下角搜索框输入cmd，进入命令控制工具， 1输入“ping www.你的用户名.github.io” 或者 1输入“ping 你的用户名.github.io” 都会看到对应的ip地址，比较神奇的是这两种方式竟然得到不一样的地址，这个本人也是不清楚，不知道github内部的处理和部署逻辑是什么，不过都一样使用。 如何解析域名？ 在我们得到博客站点的ip后就可以去告诉DNS如何进行指向了，由于本人是在阿里云购买的域名，所以这里以阿里云域名解析为例，我详细这种都大同小异，其它厂商提供的设置方式也是相同。 如上图所示就做好了域名解析，现在做下简单介绍： @表示可以直接通过如monkeygeek.cn来访问绑定的ip 解析路线如果没有特殊要求选择“默认”即可，其实区别不大 如何将域名绑定至github page？ 进入博文仓库—settings 拉到页面底部的位置进行github page设置 绑定成功验证 浏览器输入你的域名访问即可，需要注意的是域名解析在配饰好之后有一段时间的等待期，大概十分钟，所以请耐心等待。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/11/githubdomain/"},{"title":"二、hexo结构简介","text":"hexo结构 当hexo安装成功后其结构如下图： 结构简介 **node_modules:**nodejs根据hexo的依赖组件而下载的各种工具包 **public:**我们写作的md文档文件均存放子啊source，public是根据source文件夹内的md文档生成的对应静态html等静态网站数据 **scaffolds:**模板文件夹，我们在写各种md文档时可以根据模板文档来生成对应的md文档，默认有post（文档）、page（自定义页面）、draft（草稿）三种模板 **source:**存放有md文档，其实我们的创作成果体现，后面文章将详细介绍 **themes:**主题文件夹，用于存放我们clone的各种主题。hexo在安装时将自动下载“landscape”主题 package.json：hexo的应用程序信息，包含版本信息、依赖插件信息等 package-lock.json：hexo详细的依赖工具包信息 _config.yml:**其为hexo的配置文件，下面将详细介绍。** 提前注意：配置文件中参数的设置必须要加入空格，例如title: monkeyGeek # 网站标题 ：之后加入空格，#之后加入空格等 hexo样例_config.yml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: monkeyGeek # 网站标题subtitle: monkeyGeek # 网站副标题description: java,软件,IT,学习,分享,成长,activit,AI,android,协议,线程与进程,系统装机,算法,数据库,软件基础,权限,其它,跨域,康波定律,开发标准,集合框架,分布式与架构,springcloud,svn,UML,安全,annotation,scikit-Lean,spring,springboot,RabbitMQ,python,PD,OSGI,numpy,nosql,nginx,mybatis,maven,linux,js,idea,hexo,github,git,feign,eureka,ELK,chrome,BIM,apollo # 网站描述，主要用于SEO搜索，关键词罗列方便搜索keywords: java,软件,IT,学习,分享,成长,activit,AI,android,协议,线程与进程,系统装机,算法,数据库,软件基础,权限,其它,跨域,康波定律,开发标准,集合框架,分布式与架构,springcloud,svn,UML,安全,annotation,scikit-Lean,spring,springboot,RabbitMQ,python,PD,OSGI,numpy,nosql,nginx,mybatis,maven,linux,js,idea,hexo,github,git,feign,eureka,ELK,chrome,BIM,apollo# 网站关键词，以半角逗号分隔多个关键词author: monkeyGeek # 作者名称language: zh-CN # 网站使用的语言timezone: # 网站时区，录入可设置America/New_York, Japan, 和 UTC等# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://monkeygeek369.github.io # 网站urlroot: / # 网站根目录permalink: :year/:i_month/:i_day/:enname/ # 网站的永久链接格式permalink_defaults: # 网站永久链接格式的默认值# Directorysource_dir: source # 指定资源文件夹public_dir: public # 指定公共文件夹，即生成的静态站点文件tag_dir: tags # 指定标签文件夹archive_dir: archives # 指定归档文件夹category_dir: categories # 指定分类文件夹code_dir: downloads/code # 指定include code文件夹i18n_dir: :lang # 国际化文件夹skip_render: # 跳过指定文件的渲染，可使用glob表达式来匹配路径# Writingnew_post_name: :category/:title.md # 新建md文档时生成的文件路径和文件名称指定default_layout: post # 新建文档的默认布局方式titlecase: false # 是否把标题转换为title caseexternal_link: true # 是否在新标签页中打开链接filename_case: 0 # 把文件名称转换为1大写或2小写，默认为0render_drafts: false #是否显示草稿post_asset_folder: false #是否启动asset文件夹relative_link: false # 是否把链接改为与根目录的相对地址future: true # 是否显示问来的文章highlight: # 代码块设置 enable: true # 是否启用代码高亮 line_number: true # 是否启用行号 auto_detect: false # 是否启用代码自动检测 tab_replace: # 未知，没使用过 # 主页设置# path: 博文网站index启动页面的位置路径，默认为空# per_page: 每页显示的文章量 (0 = 关闭分页功能)# order_by: 排序规则 (默认以文章创建日期倒叙排序)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorized # 默认分类category_map: # 分类别名tag_map: # 标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD # 日期格式time_format: HH:mm:ss # 时间格式# Pagination# per_page: 每页显示的文章量 (0 = 关闭分页功能)# pagination_dir: 分页目录per_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: 需要指定theme文件夹下的主题theme: icarus_monkeyGeek# 部署配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # 指定仓库类型 repo: https://github.com/monkeyGeek369/monkeyGeek369.github.io.git # 指定仓库连接 branch: master # 指定分支 message: #消息配置 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/structure/"},{"title":"五、关于写作的那些事","text":"布局的概念 Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts 注意： 可以设置md文章中的layout为false，这样该文章将不被处理 通过使用不同布局，md文章文档将生成至对应文件夹 模板的概念 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1$ hexo new photo &quot;My Gallery&quot; 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章 草稿的概念 使用draft布局新建的文章即为草稿，可以通过public命令将草稿移动到source/_post文件夹内。草稿默认不会显示在页面，但是可以在执行时加上 –draft参数或者在配置文件中把render_drafts设置为true。 文件名称 文件名可以在配置文件中去设置，可使用参数如下： 变量 描述 :title 标题（小写，空格将会被替换为短杠） :year 建立的年份，比如， 2015 :month 建立的月份（有前导零），比如， 04 :i_month 建立的月份（无前导零），比如， 4 :day 建立的日期（有前导零），比如， 07 :i_day 建立的日期（无前导零），比如， 7 例如：在配置文件中可以设置文章的永久链接格式permalink: :year/:month/:day/:title/ # 网站的永久链接格式 例如：在配置文件中可以设置文字默认名称的格式new_post_name: :category/:title.md # 新建md文档时生成的文件路径和文件名称指定 至于永久链接和new_post_name的具体用法请继续往下看。 创建文章 通常我们创建文章是需要指定布局和模板的 例如：hexo new post “hello word” #使用post布局，并使用post模板创建md文档，文档将被保存至source/post文件夹 例如：hexo new myScaffold “hello word“ #使用myScaffold目标创建md文档，那么此时文档的默认布局为_config.yml配置文件设置的布局，默认为post 创建分页 从”二、hexo结构简介“我们知道，hexo中的source文件夹存放我们编辑的原始md文章文档，那么由于布局的使用我们的md文档只能存在于_post或者_drafts或者直接source内。前两者通过post、draft布局即可实现，而如果要创建分页必须使用page布局。 我们需要明白一点，什么是分页？根据我的理解，分页是网站页面的概念，分页内可包含md文档，其范围大于md文档。例如我们通过命令hexo new page “spring”，那么将会在source创建一个spring的文件夹（如果不存在）并包含一个index.md文档，如下图： 那么创建成功的分页可以当作菜单使用，因为其本质是hexo生成的对应html连接 例如，我们可以在我们所使用的模板配置文件内设置菜单（我使用的是icarus_monkeyGeek模板，存放在themes\\icarus_monkeyGeek目录，可以进入目录找到配置文件_config.yml） 当博客发布成功后点击页面中的”关于我“就会跳转到我们生成的about/index.md,当然此时hexo已经将md转为html，应该是about/index.html 值得注意的是如果我们手动在我们的分页文件夹内创建md文档，如下图： 1、即使在新创建的md文档内设置了categories和tags，那么hexo依然无法识别，即只能识别到index.md 2、手动创建的分页内部md文档，如上图的aboutTest.md是可以通过如http://localhost:4000/about/aboutTest.html来进行访问的 永久链接的多种用法 什么是永久链接？ 永久链接既是我们在public文件夹内生成的html页面所对应的固定路径，简单来说就是我们博文固定的访问路径。 例如hexo将会自动根据永久链接路径来生成对应路径的html页面 永久链接可以有哪些途径设置？ 通过_config.yml配置设置 通过每篇文章的Front-matter来指定 永久链接的设置参数？ 变量 描述 :year 文章的发表年份（4 位数） :month 文章的发表月份（2 位数） :i_month 文章的发表月份（去掉开头的零） :day 文章的发表日期 (2 位数) :i_day 文章的发表日期（去掉开头的零） :title 文件名称 :post_title 文章标题 :id 文章 ID :category 分类。如果文章没有分类，则是 default_category 配置信息。 您可在 permalink_defaults 参数下调整永久链接中各变量的默认值： 12permalink_defaults:lang: en 当您建立新文章时，文章会被储存到： 12$ hexo new &quot;Hello World&quot; --lang tw# =&gt; source/_posts/tw/Hello-World.md 而网址会是： http://localhost:4000/tw/hello-world/ 利用永久路径建立文章唯一短路径 需求场景，比如我们需要针对文章添加评论功能，例如使用gitalk插件，那么由于github要求我们的当前文字path路径不能超过50字符，如果我们的永久路径太长，例如被设置为“:year/:month/:day/:category/:title.md”并且我们的title还是一大串的中文，那么在生成永久链接时必然很长，所以评论功能注定失败，此时我们需要设定唯一短路径。 如：”:year/:id”这样既能确保唯一性也可以生成短路径，满足github评论功能 new_post_name的多种用法 1、首先我们需要清楚，new_post_name是用来设置新建文章存放在_post文件夹下的文件路径 例如：在_config.yml设置new_post_name: :category/:title.md 我的目的很简单就是让自己创建的md文字可以根据文章的分类不同存放在_post内的不同文件夹内，这样方便我后期根据分类快速查找文章，可以方便进行迁移。 执行命令：hexo new post ”springDetil“ –category spring 结果：在_post文件夹下创建spring分类文件夹并包含名称为springDetil.md的文章 2、其次我们要明确new_post_name不同于永久链接，前者是设置md文档的存放路径，后者是者设置md文档所对应的html文件在public内的路径 我们可以这样理解，md文章的存放路径与html静态站点路径是两回事，两者路径可以完全不同，我们可以通过永久链接来实现自定义分类访问（模仿菜单）。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/editdetail/"},{"title":"八、hexo写作常用技巧","text":"1、文章折叠问题 在待编辑的文章md中加入 1&lt;!-- more --&gt; 这个标记是hexo自带并可识别的，该标记之后的内容将被折叠，如果该标记之前无文字内容，则标记无效 2、md支持html标签以及内嵌css样式，因此我们可以自由发挥，如下是“版权声明”的内嵌html案例 1234567891011121314&lt;div style=&quot;height:260px; background-color:rgb(238,240,244); padding:10px;border-radius:10px;&quot;&gt; &lt;p style=&quot;color:#f36c21;font:bold 16px/20px 'kaiTi';&quot;&gt; 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! &lt;/p&gt; &lt;p&gt; &lt;span style=&quot;font:bold 16px/20px 'kaiTi';&quot;&gt;本文出自：&lt;/span&gt;&lt;a href=&quot;https://monkeyGeek369.github.io&quot;&gt;monkeyGeek&lt;/a&gt; &lt;/p&gt; &lt;p&gt; &lt;span style=&quot;font:bold 16px/20px 'kaiTi';&quot;&gt;座右铭：&lt;/span&gt;&lt;span&gt;生于忧患，死于安乐&lt;/span&gt; &lt;/p&gt; &lt;p&gt; &lt;span style=&quot;font:16px/20px 'kaiTi';&quot;&gt;欢迎志同道合的朋友一起交流、探讨！&lt;/span&gt; &lt;/p&gt; &lt;img style=&quot;height:auto; width:auto;flot:left;&quot; src=&quot;../../../../image/monkey64.png&quot; /&gt;&lt;span style=&quot;font:16px/20px 'kaiTi';flot:left;&quot;&gt; monkeyGeek&lt;/span&gt; 3、利用categories文章分类来实现自定义菜单 以创建”经验分享”菜单分类为例进行讲解: 首先新建文章，如命令hexo new post “mymd” 打开文章，添加categories分类为“share” 执行生成html命令，hexo g 这样就会在public文件夹内生成categories/share文件夹 在主题的menu添加自定义主题如“经验分享: categories/share” 访问页面点击“经验分享”即可查看指定目录下的所有文章 4、md文档头部参数设置范例 123456789101112131415title: #主题名称category: hexo #new_post_name中指定的自定义参数date: 2019-08-10 16:15:14updated: 2019-08-10 16:15:14enname: hexoskillcategories: #分类名称，可多个 - hexotags: #标签名称，可多个 - hexokeywords: #关键字，可多个 - hexo - icarus - gitalkpermalink: #永久链接，可为空thumbnail: #缩略图路径，可为空，可以是相对路径 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/hexoskill/"},{"title":"六、通过hexo实现将博客系统部署至github","text":"github环境准备 github中有个叫github page 的服务，这项服务支持html等静态站点的访问解析，可以通过访问与github用户名相同的仓库名来实现访问站点，这也是通过github实现自建博客的依据。那么我们的首要条件是建立一个仓库名称为自己github账户名称的仓库，然后通过“你的用户名.github.io”来访问你的博文站点。 那么问题来了，如何创建仓库？如何实现本地同github的安全通信？这部分内容在文章“本地版本库创建并提交GitHub”已经介绍，这里不再重复叙述。在这里假设我们已经成功建立仓库，名称为：monkeyGeek369（一定要是你自己github的账户名称） 本地git环境准备 简单来说git的环境准备就是将git安装到本地，一直下一步即可，如果对git生疏可以查看本博客站点git相关文章。 hexo环境配置 详情可以查看“一、hexo基础环境准备” 下载主题与配置 hexo官方提供多种主题下载，官方主提地址 https://hexo.io/themes/，在挑选到自己喜欢的主题后进行如下操作： 1、主题克隆：通过 “git clone 主题地址”命令将主题克隆至hexo安装目录下的“theme”文件夹内 2、主题绑定：通过修改hexo的_config.yml文件绑定主题（_config.yml配置文件的详细介绍可参考“二、hexo结构简介”） 文章编辑 文章编辑就是利用hexo提供的各种命令以及主题配置等实现对文章的编辑操作，详情可参考“三、hexo基础命令” 例如： 通过命令hexo new post “文件名” 来创建文档 通过命令hexo new page “分页名称”来创建分页 通过命令hexo g 来将source种的文档生成html静态站点到public文件夹 通过命令hexo s 来将public种的静态站点发布，默认端口4000 通过命令hexo clean来讲public清空、db缓存清空等 md编辑器可以选择使用Typora，相对简介好用 站点生成 source文件夹：我们创建的无论是文档还是分页全部存放在source文件夹以.md结尾的文档，这也是生成html静态站点的基础素材。 public文件夹：通过执行hexo g命令实现将source中的md文档生成符合指定模板的html静态站点，静态站点存放在public文件夹下。 通过命令hexo s 来将public种的静态站点发布，默认端口4000 站点发布 若站点本地发布成功则可以将public中的静态站点文件提交到github中我们创建的仓库。实现提交github需如下几步： 1、hexo配置github地址等信息（在hexo的_config.yml文件内） 1234567# 部署配置## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # 指定仓库类型 repo: https://github.com/monkeyGeek369/monkeyGeek369.github.io.git # 指定仓库连接 branch: master # 指定分支 message: #消息配置 2、确保本地与github仓库的通信成功，这部分内容在文章“本地版本库创建并提交GitHub”已经介绍 3、安装部署插件，执行命令 npm install --save hexo-deployer-git 4、通过hexo deploy实现部署 结果验证 通过“你的用户名.github.io”来访问你的博文站点 域名绑定 关于自身域名如何绑定至github可以参考我第九篇文章，有专门介绍。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/githubblog/"},{"title":"四、Front-matter概念理解","text":"基础概念 Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说： 1234---title: Hello Worlddate: 2013/7/13 20:46:25--- 详细参数 参数 描述 默认值 layout 布局，可指定文章布局 title 标题，可指定文章标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页，即新建立的分页无法识别）tags: - PS3 - Games categories 分类（不适用于分页，即新建立的分页无法识别）categories: - Diary permalink 覆盖文章网址 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） 自定义参数 Front-matter除了以上官方参数之外我们还可以添加自定义参数，例如 123456789title: 软件研发（开发）流程与规范enname: softDevelopcategory: share #source路径自定义参数date: 2019-08-06 23:37:39updated: 2019-08-06 23:37:39categories: experienceShare #分类名称，影响永久路径生成tags: experienceShare #标签名称，影响永久路径生成keywords: 软件研发（开发）流程与规范thumbnail: ../../image/研发流程与规范.png #缩略图 其中的enname为标题的英文名称，这样我们可以在永久链接中使用，以确保我们生成的html静态站点连接为村英文且保持尽可能的端。 permalink: :year/:i_month/:i_day/:enname/ # 网站的永久链接格式 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/frontmatter/"},{"title":"git多用户配置","text":"一 前言众所周知,我们通过本机git来访问服务器git通常使用rsa凭证的方式来确保安全性,下面通过三个场景来具体分析git账户的含义: 场景一:只存在一个git账户,一个rsa密钥 例如公司内部存在gitlab服务器,那么通过本地生成rsa公钥与私钥,分别将公钥配置到服务器,私钥配置到本机git,那么可以正常通过rsa访问. 场景二:存在多个git账户,一个rsa密钥 例如本机只生成一对rsa密钥分别为id_rsa\\id_rsa.pub,然而我们需要操作公司内部gitlab与自身的github,其实通过一对rsa就可以实现,将生成的公钥分别配置到gitlab与github,私钥配置到本机git,那么可以同时操作两者. 场景三:存在多个git账户,多个rsa密钥 例如我们既有公司内部的gitlab也有自身的githubA账户\\githubB账户,那么通过一对rsa无法实现控制(github有验证,相同公钥不可重复使用在不同github账户),必须进行多用户配置. 二 密钥的基本概念如何生成密钥以及如何使用密钥在文章中已经详细介绍,rsa密钥的作用是使git服务器与client之间建立安全通信通道并完成身份认证. 生成密钥时我们可以输入密码,但无需填写账户名\\邮箱等特定信息,即密钥与账户无关仅做身份认证. 三 账户的基本概念通过密钥我们可以实现本机同服务器间的身份认证,但这还远远不够,想要完整的操作git服务器必须具备如下条件: 以如下环境为例:(查看某项目git配置) 12345678910111213141516#输出项目本地配置信息$ git config --local -lcore.repositoryformatversion=0core.filemode=falsecore.bare=falsecore.logallrefupdates=truecore.symlinks=falsecore.ignorecase=trueuser.name=111111user.email=111111@qq.comremote.origin.url=https://github.com/yqnshare/yqnshare.github.io.gitremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*branch.master.remote=https://github.com/yqnshare/yqnshare.github.io.gitbranch.master.merge=refs/heads/master 必须具备条件解读:(在密钥已经配置要的前提下) 条件 说明 远程主机remote.origin 本地仓库必须要指定远程主机信息,通过clone命令即已经具备,无需再设置,当然也可也通过git remote 命令重新设置(如$ git remote set-url origin https://github.com/yqnshare/yqnshare.github.io.git) 本地分支branch.master 创建本地分支并提交至远程主机,详情可看git用法之常用命令 用户名user.name 可以通过git config –system/global/local来分别设定,优先级为local&gt;global&gt;system,用户名仅仅是作为标记,无任何验证作用.详情可看git用法之常用命令 用户邮箱user.email 可以通过git config –system/global/local来分别设定,优先级为local&gt;global&gt;system,用户邮箱仅仅是作为标记,无任何验证作用.详情可看git用法之常用命令 账户名 账户名必须填写,对应的是远程主机的账户名,如github账户名 密钥密码 如果使用rsa且设置了密码那么必须要输入 四 配置步骤4.1针对不同环境生成不同rsa密钥 密钥的生成看第二部分”密钥的基本概念” 4.2配置config文件 以window系统为例,需要在.ssh中创建config文件并进行配置,内容如下: 123456789101112131415#公司的git地址Host yqngitlab User mahao Hostname git.iyunquna.com IdentityFile ~/.ssh/id_rsaHost yqnsharehost User yqnshare Hostname github.com IdentityFile ~/.ssh/yqnshare_rsaHost monkeygeekhost User monkeygeek369 Hostname github.com IdentityFile ~/.ssh/myblog_rsa Host:可以自定义,实际上是远程地址的别名,如通过 ssh -T git@yqnsharehost 等效于 ssh -T git@github.com User:实际上是远程服务器的账户名称,例如自己的github账户名称等,例如可以这样使用git remote set-url origin https://yqnshare@yqnsharehost/yqnshare/test.git IdentityFile:指的是rsa对应的路径 配置好后可通过ssh -T命令测试各个配置是否能够联通,如: ssh -T git@@yqnsharehost 4.3配置账户信息 具体可看第三部分”账户的基本概念”,其中需要特别注意的是”用户名”和”密钥密码”,一般git会将我们第一次输入的账户名和密码进行缓存,当然我们也可以移除缓存或添加缓存,具体操作如下: 12345678910#缓存项目本地的rsa对应的凭据信息#1.缓存的账户密码以明文形式存放在.ssh根目录.git-credentials文件内#2.同服务器账户只能被缓存一次，如account1和account2同为github账户，即github.com的服务器地址只能被缓存一条数据#3.若account2被缓存那么在account1使用push等命令时会提示“使用account2账户登录无权限”git config --local credential.helper store#清除系统\\全局\\项目本地的rsa对应的凭据信息git config --system --unset credential.helpergit config --global --unset credential.helpergit config --local --unset credential.helper 这里或许大家会有一个疑问,比如我在config配置了多种rsa那么到具体的项目中我们也没有去设置匹配关系,git是如何找到对应的config配置呢? 正如我前文说的,rsa密钥配置仅仅作为身份认证没有其它作用,而账户信息则负责整个本地项目与远程仓库的对应关系,两者不存在直接匹配关系,当我们本地项目需要pull或push等操作远程仓库时,git会根据项目中对应好的关系(如url地址,账户名等)自动取config中匹配,我们只需输入对应的”账户名”和”rsa密钥密码”即可访问. var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/10/31/multuser/"},{"title":"一、git基础教程","text":"简介Git是分布式版本控制器，由中央服务器、客户机组成。客户机从中央服务器获取代码后除了代码文件外还有一个与服务器相同的完整的版本库，客户机在断网的情况下依然可以与本地版本库进行代码提交、更新、差异化比较等操作，等有网络了再将本地版本库与服务器同步。中央服务器起到代码备份与版本控制作用，即使挂掉也可以由客户机来恢复，因为客户机的版本库一直是最新的。 GIT与SVN不同的是“记录快照”，GIT不关心具体代码的差异只关心文件和项目整体性的变化，每次变动都会进行备份快照，所以GIT更像是一个特殊的文件系统。 SVN是集成式版本控制器，中央服务器负责版本控制，客户机对获取的代码进行的任何操作都需要同步到中央服务器。每次更新与提交代码进行“差异化比较”，将服务器代码进行更新，并将此次操作记录在.SVN文件中。 组成结构 git与其它版本控制软件最大的区别是其并非存储差异而是存储完整快照，并且git的每一个命令都会在git仓库有记录留存，数据丢失的情况非常少。git版本控制主要由三功能区组成： 工作区：可以理解为我们正在编辑的文件，文件有改动后工作区与缓存区出现不一致，git status将显示modify状态，需要执行commit命令 缓存区：这个一个抽象的概念，主要作用是为了解决仓库与工作区的不统一问题，祈祷协调作用，通过git add命令可以将新文件放入缓存区（实际上此时仓库也有记录） git仓库：仓库分为本地仓库和远程仓库，远程仓库存在主分支、子分支，本地仓库同样存在主分支和子分支，子分支可以由其它分支产生，各主子分支之间各自迭代互不影响。（分支存在更新传递，如C分支来自B分支，B分支来自A分支，那么C分支的提交会更新至B分支，B分支需要在提交至A分支。） 经典交互过程 master：从服务器clone后默认会生成一个名为master的主库，其它各分支可以来自master库 HEAD：可以理解为分支的快照，快照指向哪里（通常指向commit）那么git将认为已经提交的状态为指向内容，通过git rest命令可以实现git的移动 Index空间：可以理解为缓存区，实际上Index空间是新的commit的一个快照 commit：指的是每一次的提交，实际上就是Index缓存空间的一次记录 git搭建流程 建立git服务器：可以通过第三方软件自己搭建，如Gitlab，也可以直接利用github提供服务 服务器配置：根据git服务器软件的不同有差异，通常是配置用户、权限、库等信息 客户端安装：根据本教程安装客户端即可 客户端ssh配置：为了安全通常借助ssh进行客户端与服务端的加密通信，详情可看“Git SSH KEY生成与配置” 客户端与服务器端实现通信 辅助软件安装（基本上不用，可以不用安装） 安装tortoiseGit的GUI安装 GUI的语言包 Git的全局账户配置首先我们需要明白的是本地仓库与远程仓库的通信需要建立在两方面设置的基础上，第一，首先需要设置github或其他git仓库的账户名设置，即user.name和user.email，第二，需要创建rsa的公钥和私钥并将私钥添加到本地git将公钥加入github等远程仓库。第二点本文将不详细介绍，详情请看文章“Git SSH Key生成与配置”，通常我们会通过全局命令设置全局的账户名信息，具体如下： 12$ git config --global user.name &quot;xxx&quot; 例如应该填写如github用户名，如我的用户名是monkeyGeek$ git config --global user.email &quot;aaa.bbb@xxx.com&quot; 例如应该填写的是github内设置并验证成功的email 需要注意的是当我们设定好全局的用户名和邮箱后那么整个本地git仓库的所有账户名都用被设置的全局名称，如果存在本地多个仓库来自多个远程git仓库，由于每个git仓库的账户名和email很大程度上是不同的，因此可以用如下命令，单独针对某本地仓库设置账户名和邮箱。 重新设置 1git remote set-url origin git+ssh://git@github.com/monkeyGeek369/icarus_monkeyGeek.git 新添加 1git remote add origin git@github.com:nickchou/gocode.git 其它命令 12git remote -v 查看git remote rm origin 移除 注意：添加的github账户需要使用git方式不要使用https方式，git方式更加方面不用每次执行命令都要输入密码 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/gitbase/"},{"title":"三、git用法之常用命令","text":"1、git clone –将远程项目下载到本地进入目标文件夹，右击选择git bash here，执行如下命令 1git clone git@git.soydai.cn:liuxuewen/static-file-3.0.git 或者 1git clone http://git.soydai.cn/liuxuewen/static-file-3.0.git 区别： 第1种使用ssh协议下载，第二种使用http协议，而Git支持多种协议包括 ssh、http、https； 通过http、https协议下载时，需要输入 Username、Password 登录成功才会下载到本地； 通过ssh支持的原生git协议速度最快。 2、git add –将文件添加至缓存区进入目标文件夹，右击选择git bash here，执行如下命令 1git add . 添加所有未版本控制文件对象 1git add www/js/a.js 添加具体未版本控制对象 3、git remote –远程主机设置123456789101112131415161718#列出现存远程主机git remote#列出远程主机详情及地址git remote -v#设置远程主机自定义名称及地址git remote add yourName url 如 git remote add monkeygeek git@github.com:monkeygeek/Test.git#删除指定名称的远程主机信息git remote remove yourName #重命名远程主机git remote rename 原名字 新名字#展示远程主机详细信息git remote show 主机名 为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。 4、设置别名可以针对git默认命令进行别名设置，效果同使用元命令相同，例如： 1$ git config --global alias.ph push 5、git commit –将缓存区文件提交至库由工作区提交至缓存区 1git commit -m '修改xxxbug' ------描述并提交到本地当前分支 6、git pull –取回远程分支的更新并于本地分支合并1git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; //相当于git fetch + git merge，拉取远程分支并merge。 1git pull --rebase : 相当于git fetch + git rebase，拉取远程分支并进行rebase操作。 1git pull 直接拉取默认 1git pull origin xxx 直接拉取xxx分支代码到本地 7、git push –将本地分支的更新推送到远程分支1git push origin 本地分支 : 远程分支 //将本地缓存推送到远程分支 8、git merge 和 git rebase 的区别1git merge 被合并分支名称 (例如项目A合并项目B,则在项目A中执行git merge B) 举个例子： A和B两个人进行合作开发，同时在develop分支上开启各自的功能分支featureA和featureB进行开发，A在10：00提交了A1，12:00提交了A2，16:00提交了A3，并且合并到develop分支，此时develop分支状态为： 1Head -&gt; A1 -&gt; A2 -&gt; A3 而B则分别在9：00提交了B1，在11：00提交了B2，在17：00提交了B3，此时对于B来说，合并到develop分支有两种方式，使用rebase和merge。 1234// 根据提交的先后顺序进行排序merge ： Head -&gt; B1 -&gt; A1 -&gt; B2 -&gt; A2 -&gt; A3 -&gt; B3// 根据提交的先后进行排序rebase： Head -&gt; A1 -&gt; A2 -&gt; A3 -&gt; B1 -&gt; B2 -&gt; B3 9、git branch –本地分支管理列出本地已经存在的分支，并且在当前分支的前面加“*”号标记。 12345678git branch :列出本地分支git branch -r : 列出远程分支git branch -a: 列出本地分支和远程分支git branch &lt;name&gt;: 创建一个新的本地分支git branch -m oldbranch newbranch： 重命名分支git branch -d branchname： 删除本地分支git push origin --delete branchname：删除远程分支git push origin yourBranch 提交本地分支到远程 10、git remote –远程分支管理列出已经存在的远程分支 1git remote -v: 列出详细信息，在每一个名字后面列出其远程url 将远程仓库连接地址添加至本地某仓库，使之成为本地仓库的远程地址 1git remote add &lt;name&gt; &lt;url&gt;：在url创建名字为name的仓库，name为远程仓库的名字。 11、git checkout –迁出分支、切换分支、迁出单个文件123git checkout -b 本地分支名 origin/远程分支名 //拉取远程分支并创建和切换到本地分支git checkout 本地分支名 //切换本地分支git checkout --patch 目标分支名 文件路径 //合并两个分支中单个的文件 12、git stash 和 git pop在执行pull操作时会遇到提示即将覆盖文件，这个时候可以使用stash进行备份，之后再进行获取保存内容，git将自动进行合并 1234git stash：是备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。git stash pop：从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。git stash list：显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。git stash clear：清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了。 13、tag –为分支添加标记123456789101112131415// 列出本地tag$ git tag// 添加tag$ git tag -a v0.1.2 -m “0.1.2版本”// 切换到tag的位置$ git checkout -b [branch] [tagname]// 删除tag$ git tag -d [tagname]// 推tag$ git push origin –tags$ git push origin [tagname] 14、git config查看/修改用户名和地址本地git的用户名和邮箱是作为身份标识，仅仅是标识。 12git config user.namegit config user.email 15、git fetch –取回远程分支但不与本地分支合并12git fetch //在服务端创建分支后本地通过git branch -a拉去远程分支发现没有最新创建的这时需要刷新本地分支git fetch origin 远程分支名 : 本地分支名 //拉取远程分支到本地分支 16、git status –查看本地文件修改状态查看需要提交的文件 17、git reset –用户版本库回退（改变HEAD指向） git –hard：将缓存区、工作区强制与分支仓库保持一直，换句话说，工作区、缓存区内容会被重置有丢失风险，这也是git稍有的危险命令。如git reset –hard HEAD^ 回退到上一次commit，当然也可以指定commit版本 git –soft：保留工作区并把重置带来的差异放进暂存区，此命令将造成工作区与分支存在差异，使工作区文件为修改状态。缓存区与分支保持一直。 git –mixed：将分支内容、缓存区内容、工作区内容共同融合保存到工作区，并清空缓存区，此时缓存区与工作区存在不一致。 18、git config –git配置相关123456789101112131415161718192021222324252627#分别查看系统\\全局\\本地配置,优先级为local&gt;global&gt;systemgit config --system -lgit config --global -lgit config --local -l#设置全局用户名\\用户邮箱git config --global user.name &quot;yourName&quot;git config --global user.email &quot;yourEmail&quot;#设置项目本地用户名\\用户邮箱git config --local user.name &quot;yourName&quot;git config --local user.email &quot;yourEmail&quot;#缓存项目本地的rsa对应的凭据信息#1.缓存的账户密码以明文形式存放在.ssh根目录.git-credentials文件内#2.同服务器账户只能被缓存一次，如account1和account2同为github账户，即github.com的服务器地址只能被缓存一条数据#3.若account2被缓存那么在account1使用push等命令时会提示“使用account2账户登录无权限”git config --local credential.helper store#清除系统\\全局\\项目本地的rsa对应的凭据信息git config --system --unset credential.helpergit config --global --unset credential.helpergit config --local --unset credential.helper#清除全局用户名\\用户邮箱信息git config --global --unset user.namegit config --global --unset user.email 19、ssh -T –验证git是否联通12#基本格式为 ssh -T 远程服务类型@远程地址(当然也可以是自定义地址Host)ssh -T git@github.com 1234567891011#步骤一:在.ssh文件夹内的config配置文件来配置自定义rsa,如下Host yqnshare User yqnshareTest Hostname github.com IdentityFile ~/.ssh/yqnshare_rsa#通过自定义Host名称来代替远程地址进行访问$ ssh -T git@yqnshareEnter passphrase for key '/c/Users/EDZ/.ssh/yqnshare_rsa':Hi yqnshare! You've successfully authenticated, but GitHub does not provide shell access. 用于本地测试是否能够联通远程服务器,出现以下内容则表示联通: 1Hi ***! You've successfully authenticated, but GitHub does not provide shell access. 20、ssh-add –私钥添加至本地1234567891011#将不同的私钥添加到本机git环境ssh-add ~/.ssh/id_rsa_github // 将 GitHub 私钥添加到本地ssh-add ~/.ssh/id_rsa_gitlab // 将 GitLab 私钥添加到本地#列出本机git环境已添加私钥情况ssh-add -l#如果执行添加私钥命令出现如下提示,则需要执行eval `ssh-agent`命令Could not open a connection to your authentication agenteval `ssh-agent` var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/gitcommand/"},{"title":"二、Git SSH Key 生成与配置","text":"Git 是分布式的代码管理工具，远程的代码管理基于SSH的，因此必须由用户本地生成ssh的私钥和公钥来建立客户端与服务器的安全连接，配置SSH的步骤如下： 全局账户配置全局账户配置的详细教程说明已经在“一、git基础教程”中讲解，各位看官可取查看。 生成SSH密钥1、说明本地git同github或者gitlab等git仓库进行通信通常需借助rsa密钥进行身份确认，即需要我们在创建好公钥和私钥后将私钥进行本地注册，公钥放入远程git仓库注册。 2、查看本地ssh在windows系统中rsa密钥的默认存放路径是在当前登录账户的用户-&gt;.ssh文件夹内。右键选择git bash here，执行如下命令： 12$ cd ~/.ssh$ ls 3、执行生成命令右键选择git bash here，执行如下命令： 1ssh-keygen -t rsa -C &quot;你的邮箱地址&quot; #自动在.ssh生成名称为id_rsa的密钥文件 在输入此命令后会提示是否设置密码，可以自行选择是否设置密码。 设置密码后在每次进行git push等命令时会进行密码输入 1ssh-keygen -t rsa -C &quot;你的邮箱地址&quot; -f &quot;yourFileName_rsa&quot; 通过该命令可生成指定名称的rsa密钥文件至.ssh文件夹内 4、加入ssh代理右键选择git bash here，执行如下命令： 1ssh-add ~/.ssh/rsa密钥文件名 注意：直接ssh-add命令可能报错“ Could not open a connection to your authentication agent”这是因为ssh agent配置有问题，需要先执行ssh-agent bash命令。 1ssh-add id_rsa 5、公钥使用需要添加到git上的是id_rsa.pub，此时客户端即可clone，pull，push代码了。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/gitsshkey/"},{"title":"四、本地版本库创建并提交GitHub","text":"前言github与git在这里就不去介绍，这些基础知识可以查看其它知识文档。我们通常本地使用git进行版本控制，进行与github、gitlab等git仓库的交互，例如克隆、拉去、提交、推送等，这些基本的git操作通常是建立在git远程仓库存在的情况下，那么如果并非系统管理员或有机会触及此类业务的人员，自己将很难接触仓库的创建与上传。本篇文章将专注介绍如何本地创建git仓库并提交至github等git仓库。大体上划分下来主要由三部分组成：在github新建仓库、在本地创建仓库、建立加密认证链接并提交 具体步骤1、在github创建仓库 登陆github 进入仓库 选择新建 设置与提交–设置仓库名称、描述、公开/私有、是否自动生成README文件 github建议每一个仓库都要具备一个叫做README.md的文件，用于对当前仓库的介绍描述。 2、在本地创建仓库当我们创建好本地仓库后github将自动跳转到仓库代码管理页面，该页面将提示三种代码传递方式，如下： 第一种是通过本地仓库上传的方式，第二种是从已存在的git仓库克隆的方式，第三种是通过其它版本控制仓库导入。 第一种和第二种方式有些类似，下面将介绍第一种方式： 本地确保已经安装git版本控制工具 本地进入你要创建版本库文件夹，右键选择 git bash here，进入git命令控制界面（该文件夹名称将成为你本地仓库的名称） 执行 git init 命令（该文件夹名称将成为你本地仓库的名称） git add . （将所有文件添加进仓库，当然也可也指定单独文件） git commit -m “本次提交的注释” （执行提交命令，将工作区内容提交至本地仓库缓存区） git remote add origin https://你的地址 （在完成3、建立加密认证链接并提交，后执行，否则认证链接不成功） git push -u origin master (将仓库提交并作为master主库) 3、建立加密认证链接并提交详情请看“Git SSH Key 生成与配置”，该文章将详细介绍如何生成rsa公钥与私钥，以及如何配置和链接。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/10/commitgithub/"},{"title":"rabbitMQ常见问题","text":"RabbitMQ是什么？RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。 RabbitMQ特点?可靠性: RabbitMQ使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。 灵活的路由 : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。 扩展性: 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。 高可用性 : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。 多种协议: RabbitMQ除了原生支持AMQP协议，还支持STOMP， MQTT等多种消息 中间件协议。 多语言客户端 :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。 管理界面 : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。 令插件机制 : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。 AMQP是什么?RabbitMQ就是 AMQP 协议的 Erlang 的实现(当然 RabbitMQ 还支持 STOMP2、 MQTT3 等协议 ) RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。 AMQP协议3层？Module Layer:主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。 Session Layer:主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。 TransportLayer:主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。 AMQP模型的几大组件？ 交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。 绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。 队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。 说说生产者Producer和消费者Consumer?生产者 消息生产者，就是投递消息的一方。 消息一般包含两个部分：消息体（payload)和标签(Label)。 消费者 消费消息，也就是接收消息的一方。 消费者连接到RabbitMQ服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。 为什么需要消息队列？用来实现：异步处理、服务解耦、流量控制（削峰）。 说说Broker服务节点、Queue队列、Exchange交换器？ Broker可以看做RabbitMQ的服务节点。一般情况下一个Broker可以看做一个RabbitMQ服务器。 Queue:RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。 Exchange:生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。 消息队列有什么优缺点优点： 解耦、异步、削峰 缺点： 系统可用性降低（会存在mq崩溃带来的风险） 系统复杂度提高 消息传递的顺序性需要额外解决 一致性问题需要额外解决（即一项业务涉及多个服务消费不同的mq，其中一个出现问题就会产生一致性问题） 如何保证消息的可靠性？生产者到RabbitMQ：事务机制和Confirm机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。 RabbitMQ自身：持久化、集群、普通模式、镜像模式。 RabbitMQ到消费者：basicAck机制、死信队列、消息补偿机制。 什么是RoutingKey路由键？生产者将消息发送给交换器的时候，会指定一个RoutingKey,用来指定这个消息的路由规则，这个RoutingKey需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效。 RoutingKey为一个 点号'.': 分隔的字符串。比如:java.xiaoka.show Binding绑定？通过绑定将交换器和队列关联起来，一般会指定一个BindingKey,这样RabbitMq就知道如何正确路由消息到队列了。 交换器4种类型？主要有以下4种。 fanout:（广播模式）把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。 direct:把消息路由到和RoutingKey完全匹配的队列中。 topic:*匹配一个单词，#匹配多个或者0个 headers：不依赖路由键匹配而是根据发送消息内容中的headers属性进行匹配，性能差，基本不用。 生产者消息发送过程？1.Producer先连接到Broker,建立连接Connection,开启一个信道(Channel)。 2.Producer声明一个交换器并设置好相关属性。 3.Producer声明一个队列并设置好相关属性。 4.Producer通过路由键将交换器和队列绑定起来。 5.Producer发送消息到Broker,其中包含路由键、交换器等信息。 6.相应的交换器根据接收到的路由键查找匹配的队列。 7.如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。 8.关闭信道。 9.管理连接。 消费者接收消息过程？1.Producer先连接到Broker,建立连接Connection,开启一个信道(Channel)。 2.向Broker请求消费响应的队列中消息，可能会设置响应的回调函数。 3.等待Broker回应并投递相应队列中的消息，接收消息。 4.消费者确认收到的消息,ack。 5.RabbitMq从队列中删除已经确定的消息。 6.关闭信道。 7.关闭连接。 交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？ mandatory ：true 返回消息给生产者。 mandatory: false 直接丢弃。 死信队列DLX，全称为 Dead-Letter-Exchange，死信交换器。 当消息在一个队列中变成死信 (dead message) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。 导致死信的几种原因 消息被拒（Basic.Reject /Basic.Nack) 且 requeue = false。 消息TTL过期。 队列满了，无法再添加。 延迟队列当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。rabbitmq中并没有延迟队列但是可以借助死心队列来实现功能。 优先级队列？ 优先级高的队列会先被消费。 可以通过x-max-priority参数来实现。 当消费速度大于生产速度且Broker没有堆积的情况下，优先级显得没有意义。 事务机制RabbitMQ 客户端中与事务机制相关的方法有三个: channel.txSelect 用于将当前的信道设置成事务模式。 channel.txCommit 用于提交事务 。 channel.txRollback 用于事务回滚,如果在事务提交执行之前由于 RabbitMQ 异常崩溃或者其他原因抛出异常,通过txRollback来回滚。 发送确认机制生产者把信道设置为confirm确认模式,设置后，所有在该信道发布的消息都会被指定一个唯一的ID，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（Basic.Ack)给生产者（包含消息的唯一ID)，这样生产者就知道消息到达对应的目的地了。 消费者获取消息的方式 推 拉 消费者拒绝消息 channel .basicNack(deliveryTag,false,true) 不确认deliveryTag对应的消息。第二个参数是否应用于多消息，第三个参数是否requeue。可以nack该消费者先前接收未ack的所有消息。nack后的消息也会被自己消费到。 channel .basicReject(deliveryTag,true) 拒绝deliveryTag对应的消息，第二个参数是否requeue，true则重新入队列 channel. basicRecover(true) 是否恢复消息到队列.true重新入队并尽可能分给其他消费者，false重新入队并自己消费 消息传输保证层级At most once:最多一次。消息可能会丢失，但不会重复传输。 At least once：最少一次。消息绝不会丢失，但可能会重复传输。 Exactly once: 恰好一次，每条消息肯定仅传输一次。 Virtual Host每一个RabbitMQ服务器都能创建虚拟的消息服务器，也叫虚拟主机(virtual host)，简称vhost。 默认为“/”。 集群中的节点类型内存节点：ram,将变更写入内存。 磁盘节点：disc,磁盘写入操作。 RabbitMQ要求最少有一个磁盘节点。 队列结构通常由以下两部分组成 rabbit_amqqueue_process:负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息、处理消息的确认(包括生产端的 confirm 和消费端的 ack) 等。 backing_queue:是消息存储的具体形式和引擎，并向 rabbit amqqueue process提供相关的接口以供调用。 RabbitMQ中消息可能有的几种状态alpha: 消息内容(包括消息体、属性和 headers) 和消息索引都存储在内存中 。 beta: 消息内容保存在磁盘中，消息索引保存在内存中。 gamma: 消息内容保存在磁盘中，消息索引在磁盘和内存中都有 。 delta: 消息内容和索引都在磁盘中 。 生产者如何将消息可靠投递到MQ1.Client发送消息给MQ 2.MQ将消息持久化后，发送Ack消息给Client，此处有可能因为网络问题导致Ack消息无法发送到Client，那么Client在等待超时后，会重传消息； 3.Client收到Ack消息后，认为消息已经投递成功。 MQ如何将消息可靠投递到消费者1.MQ将消息push给Client（或Client来pull消息） 2.Client得到消息并做完业务逻辑 3.Client发送Ack消息给MQ，通知MQ删除该消息，此处有可能因为网络问题导致Ack失败，那么Client会重复消息，这里就引出消费幂等的问题； 4.MQ将已消费的消息删除 保证RabbitMQ消息队列的高可用RabbitMQ 有三种模式：单机模式，普通集群模式，镜像集群模式。 单机模式：就是demo级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式 普通集群模式：意思就是在多台机器上启动多个RabbitMQ实例，每个机器启动一个。 镜像集群模式：这种模式，才是所谓的RabbitMQ的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据(元数据指RabbitMQ的配置数据)还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/10/20/rabbitmq-qa/"},{"title":"rabbitmq中SimpleMessageListenerContainer与DirectMessageListenerContainer","text":"SimpleMessageListenerContainer与DirectMessageListenerContainer详细介绍 SimpleMessageListenerContainer 消费者消费消息-单线程 通常一个应用创建一个connection连接（通过TCP实现）当然可以创建多个 一个connection可被多个channel复用 一个channel是单线程的 channel单线程串行消费消息 消费者消费消息-多线程 通常一个应用创建一个connection连接（通过TCP实现）当然可以创建多个 分布式服务创建各自对应的connection 一个connection可被多个channel复用 设置参数concurrency来控制线程数，相当于为每一个消费者创建了多个channel 消费者对应的多个channel可以被不同的微服务共享，例如针对消费者consumer-a的Channel-a/Channel-b可以被微服务Application-b/Application-b1公用，只是线程不同 channel单线程串行消费消息 基本参数 1234567891011121314151617181920212223242526public class SimpleMessageListenerContainer extends AbstractMessageListenerContainer { private static final long DEFAULT_START_CONSUMER_MIN_INTERVAL = 10000L; private static final long DEFAULT_STOP_CONSUMER_MIN_INTERVAL = 60000L; private static final long DEFAULT_CONSUMER_START_TIMEOUT = 60000L; private static final int DEFAULT_CONSECUTIVE_ACTIVE_TRIGGER = 10; private static final int DEFAULT_CONSECUTIVE_IDLE_TRIGGER = 10; public static final long DEFAULT_RECEIVE_TIMEOUT = 1000L; private final AtomicLong lastNoMessageAlert = new AtomicLong(); private final AtomicReference&lt;Thread&gt; containerStoppingForAbort = new AtomicReference(); private final BlockingQueue&lt;ListenerContainerConsumerFailedEvent&gt; abortEvents = new LinkedBlockingQueue(); private volatile long startConsumerMinInterval = 10000L; private volatile long stopConsumerMinInterval = 60000L; private volatile int consecutiveActiveTrigger = 10; private volatile int consecutiveIdleTrigger = 10; private volatile int txSize = 1; private volatile int concurrentConsumers = 1; private volatile Integer maxConcurrentConsumers; private volatile long lastConsumerStarted; private volatile long lastConsumerStopped; private long receiveTimeout = 1000L; private Set&lt;BlockingQueueConsumer&gt; consumers; private final ActiveObjectCounter&lt;BlockingQueueConsumer&gt; cancellationLock = new ActiveObjectCounter(); private Integer declarationRetries; private Long retryDeclarationInterval; private TransactionTemplate transactionTemplate; private long consumerStartTimeout = 60000L; concurrentConsumers：设置当前消费者数量，默认一个，初始化时自动设置 maxConcurrentConsumers：设置最大消费者数量，根据消息数量动态浮动 consumers：消费者集合，每一个consumer对应一个channel对应一个线程 Consumers初始化 1234567891011121314151617protected int initializeConsumers() { int count = 0; synchronized(this.consumersMonitor) { if (this.consumers == null) { this.cancellationLock.reset(); this.consumers = new HashSet(this.concurrentConsumers); for(int i = 0; i &lt; this.concurrentConsumers; ++i) { BlockingQueueConsumer consumer = this.createBlockingQueueConsumer(); this.consumers.add(consumer); ++count; } } return count; } } 根据设定的concurrentConsumers来初始化数量 BlockingQueueConsumer基本参数 12345678910111213141516171819202122232425262728293031323334private static Log logger = LogFactory.getLog(BlockingQueueConsumer.class);private final BlockingQueue&lt;Delivery&gt; queue;private volatile ShutdownSignalException shutdown;private final String[] queues;private final int prefetchCount;private final boolean transactional;private Channel channel;private RabbitResourceHolder resourceHolder;private BlockingQueueConsumer.InternalConsumer consumer;private final AtomicBoolean cancelled;private final AcknowledgeMode acknowledgeMode;private final ConnectionFactory connectionFactory;private final MessagePropertiesConverter messagePropertiesConverter;private final ActiveObjectCounter&lt;BlockingQueueConsumer&gt; activeObjectCounter;private final Map&lt;String, Object&gt; consumerArgs;private final boolean noLocal;private final boolean exclusive;private final Set&lt;Long&gt; deliveryTags;private final boolean defaultRequeueRejected;private final Map&lt;String, String&gt; consumerTags;private final Set&lt;String&gt; missingQueues;private long retryDeclarationInterval;private long failedDeclarationRetryInterval;private int declarationRetries;private long lastRetryDeclaration;private ConsumerTagStrategy tagStrategy;private BackOffExecution backOffExecution;private long shutdownTimeout;private boolean locallyTransacted;private ApplicationEventPublisher applicationEventPublisher;private volatile long abortStarted;private volatile boolean normalCancel;volatile Thread thread;volatile boolean declaring; 一个消费者可以监听多个队列 prefetchCount：用于控制每次从队列抓取消息的数量 Channel：对应的channel信息 thread：消费者对应的线程对象 线程处理核心代码 12345678910111213141516171819202122232425262728293031323334353637public void start() throws AmqpException {...... try { if (!this.cancelled()) { String[] var2 = this.queues; int var3 = var2.length; for(int var4 = 0; var4 &lt; var3; ++var4) { String queueName = var2[var4]; if (!this.missingQueues.contains(queueName)) { //从队列中消费消息 this.consumeFromQueue(queueName); } } } } catch (IOException var9) { throw RabbitExceptionTranslator.convertRabbitAccessException(var9); }......} private void consumeFromQueue(String queue) throws IOException { String consumerTag = this.channel.basicConsume(queue, this.acknowledgeMode.isAutoAck(), this.tagStrategy != null ? this.tagStrategy.createConsumerTag(queue) : &quot;&quot;, this.noLocal, this.exclusive, this.consumerArgs, new BlockingQueueConsumer.ConsumerDecorator(queue, this.consumer, this.applicationEventPublisher)); if (consumerTag != null) { this.consumerTags.put(consumerTag, queue); if (logger.isDebugEnabled()) { logger.debug(&quot;Started on queue '&quot; + queue + &quot;' with tag &quot; + consumerTag + &quot;: &quot; + this); } } else { logger.error(&quot;Null consumer tag received for queue &quot; + queue); } } } 消息消费的底层逻辑 123456789101112131415161718192021222324252627public String basicConsume(String queue, final boolean autoAck, String consumerTag, boolean noLocal, boolean exclusive, Map&lt;String, Object&gt; arguments, final Consumer callback) throws IOException { Method m = (new com.rabbitmq.client.AMQP.Basic.Consume.Builder()).queue(queue).consumerTag(consumerTag).noLocal(noLocal).noAck(autoAck).exclusive(exclusive).arguments(arguments).build(); BlockingRpcContinuation&lt;String&gt; k = new BlockingRpcContinuation&lt;String&gt;(m) { public String transformReply(AMQCommand replyCommand) { String actualConsumerTag = ((ConsumeOk)replyCommand.getMethod()).getConsumerTag(); ChannelN.this._consumers.put(actualConsumerTag, callback); ChannelN.this.metricsCollector.basicConsume(ChannelN.this, actualConsumerTag, autoAck); ChannelN.this.dispatcher.handleConsumeOk(callback, actualConsumerTag); return actualConsumerTag; } }; this.rpc(m, k); try { if (this._rpcTimeout == 0) { return (String)k.getReply(); } else { try { return (String)k.getReply(this._rpcTimeout); } catch (TimeoutException var11) { throw this.wrapTimeoutException(m, var11); } } } catch (ShutdownSignalException var12) { throw wrap(var12); }} 利用rpc进行消息消费的远程通信 底层利用反射机制生产消费者类和处理方法 总结： SimpleMessageListenerContainer是最简单的消息监听容器，使用简单，适合并发要求不高的场景 单线程串行执行，如果消费者处理时间过长，很有可能造成消息积压 如果代码中发生重复ack，channel将会被关闭并报异常，通道关闭后造成消息积压 由于没有使用线程池，多线程切换会影响效率 1java.lang.IllegalStateException: Channel closed; cannot ack/nack^@#\\tat org.springframework.amqp.rabbit.connection.CachingConnectionFactory$CachedChannelInvocationHandler.invoke(CachingConnectionFactory.java:982)^@#\\tat com.sun.proxy.$Proxy248.basicAck(Unknown Source)^@#\\tat com.yqn.pac.zuul.dispatch.mq.TaskResultConsumerTest.dispatch(TaskResultConsumerTest.java:27)^@#\\tat sun.reflect.GeneratedMethodAccessor130.invoke(Unknown Source)^@#\\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)^@#\\tat java.lang.reflect.Method.invoke(Method.java:498)^@#\\tat org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:181)^@#\\tat org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:114)^@#\\tat org.springframework.amqp.rabbit.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:51)^@#\\tat org.springframework.amqp.rabbit.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:182)^@#\\tat org.springframework.amqp.rabbit.listener.adapter.MessagingMessageListenerAdapter.onMessage(MessagingMessageListenerAdapter.java:120)^@#\\tat org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:1414)^@#\\tat org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.actualInvokeListener(AbstractMessageListenerContainer.java:1337)^@#\\tat org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:1324)^@#\\tat org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.executeListener(AbstractMessageListenerContainer.java:1303)^@#\\tat org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.doReceiveAndExecute(SimpleMessageListenerContainer.java:817)^@#\\tat org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.receiveAndExecute(SimpleMessageListenerContainer.java:801)^@#\\tat org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.access$700(SimpleMessageListenerContainer.java:77)^@#\\tat org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:1042)^@#\\tat java.lang.Thread.run(Thread.java:748)^@# DirectMessageListenerContainer 共用线程池 被@RabbitListener标记的消费者方法对应独立的RabbitListenerContainer 应用配置一个RabbitListenerContainerFactory且所有的queue使用相同消费者方法（@RabbitListener标记）时，每一个queue使用相同的线程池 消费者queue依然可以利用consumersPerQueue参数指定消费者并发数量，即多个channel channel对应的线程交由线程池管理 独立线程池 被@RabbitListener标记的消费者方法对应独立的RabbitListenerContainer 应用配置多个RabbitListenerContainerFactory，每个消费者指定不同的监听容器工厂可以实现独立线程池使用 应用配置一个RabbitListenerContainerFactory，每个队列拥有不同的消费者方法可以实现独立线程池使用 基本参数 12345678910111213141516171819private static final int DEFAULT_MONITOR_INTERVAL = 10000;private static final int DEFAULT_ACK_TIMEOUT = 20000;protected final List&lt;DirectMessageListenerContainer.SimpleConsumer&gt; consumers = new LinkedList();private final List&lt;DirectMessageListenerContainer.SimpleConsumer&gt; consumersToRestart = new LinkedList();private final MultiValueMap&lt;String, DirectMessageListenerContainer.SimpleConsumer&gt; consumersByQueue = new LinkedMultiValueMap();private final ActiveObjectCounter&lt;DirectMessageListenerContainer.SimpleConsumer&gt; cancellationLock = new ActiveObjectCounter();private TaskScheduler taskScheduler;private boolean taskSchedulerSet;private long monitorInterval = 10000L;private int messagesPerAck;private long ackTimeout = 20000L;private volatile boolean started;private volatile boolean aborted;private volatile boolean hasStopped;private volatile CountDownLatch startedLatch = new CountDownLatch(1);private volatile int consumersPerQueue = 1;private volatile ScheduledFuture&lt;?&gt; consumerMonitorTask;private volatile long lastAlertAt;private volatile long lastRestartAttempt; consumers：容器内的消费者集合，每一个消费者对象都有对应的channel、queue consumersByQueue：以队列名称为key的消费者map，一个queue可能对应多个消费者 taskScheduler：线程池ThreadPoolTaskScheduler，支持容器内所有消费者 consumersPerQueue：每一个队列设定的消费者数量，即channel数量 monitorInterval：尝试重启消费者的时间间隔 线程池初始化 12345678910111213141516171819 public void setTaskScheduler(TaskScheduler taskScheduler) { this.taskScheduler = taskScheduler; this.taskSchedulerSet = true; }protected void doInitialize() throws Exception { if (this.taskScheduler == null) { ThreadPoolTaskScheduler threadPoolTaskScheduler = new ThreadPoolTaskScheduler(); threadPoolTaskScheduler.setThreadNamePrefix(this.getBeanName() + &quot;-consumerMonitor-&quot;); threadPoolTaskScheduler.afterPropertiesSet(); this.taskScheduler = threadPoolTaskScheduler; } if (this.messagesPerAck &gt; 0) { Assert.state(!this.isChannelTransacted(), &quot;'messagesPerAck' is not allowed with transactions&quot;); }} 可以自由设定TaskScheduler,如果不设定则默认使用ThreadPoolTaskScheduler 线程池使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173protected void actualStart() throws Exception { this.aborted = false; this.hasStopped = false; if (this.getPrefetchCount() &lt; this.messagesPerAck) { this.setPrefetchCount(this.messagesPerAck); } super.doStart(); String[] queueNames = this.getQueueNames(); this.checkMissingQueues(queueNames); if (this.getTaskExecutor() == null) { this.afterPropertiesSet(); } long idleEventInterval = this.getIdleEventInterval(); if (this.taskScheduler == null) { this.afterPropertiesSet(); } if (idleEventInterval &gt; 0L &amp;&amp; this.monitorInterval &gt; idleEventInterval) { this.monitorInterval = idleEventInterval / 2L; } if (this.getFailedDeclarationRetryInterval() &lt; this.monitorInterval) { this.monitorInterval = this.getFailedDeclarationRetryInterval(); } this.lastRestartAttempt = System.currentTimeMillis(); this.consumerMonitorTask = this.taskScheduler.scheduleAtFixedRate(() -&gt; { long now = System.currentTimeMillis(); if (idleEventInterval &gt; 0L &amp;&amp; now - this.getLastReceive() &gt; idleEventInterval &amp;&amp; now - this.lastAlertAt &gt; idleEventInterval) { this.publishIdleContainerEvent(now - this.getLastReceive()); this.lastAlertAt = now; } List consumersToCancel; synchronized(this.consumersMonitor) { consumersToCancel = (List)this.consumers.stream().filter((c) -&gt; { boolean open = c.getChannel().isOpen(); if (open &amp;&amp; this.messagesPerAck &gt; 1) { try { c.ackIfNecessary(now); } catch (IOException var6) { this.logger.error(&quot;Exception while sending delayed ack&quot;, var6); } } return !open; }).collect(Collectors.toList()); } consumersToCancel.forEach((c) -&gt; { try { RabbitUtils.closeMessageConsumer(c.getChannel(), Collections.singletonList(c.getConsumerTag()), this.isChannelTransacted()); } catch (Exception var3) { if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Error closing consumer &quot; + c, var3); } } this.logger.error(&quot;Consumer canceled - channel closed &quot; + c); c.cancelConsumer(&quot;Consumer &quot; + c + &quot; channel closed&quot;); }); if (this.lastRestartAttempt + this.getFailedDeclarationRetryInterval() &lt; now) { synchronized(this.consumersMonitor) { List&lt;DirectMessageListenerContainer.SimpleConsumer&gt; restartableConsumers = new ArrayList(this.consumersToRestart); this.consumersToRestart.clear(); if (this.started) { if (restartableConsumers.size() &gt; 0) { this.doRedeclareElementsIfNecessary(); } Iterator var8 = restartableConsumers.iterator(); while(var8.hasNext()) { DirectMessageListenerContainer.SimpleConsumer consumer = (DirectMessageListenerContainer.SimpleConsumer)var8.next(); if (this.logger.isDebugEnabled() &amp;&amp; restartableConsumers.size() &gt; 0) { this.logger.debug(&quot;Attempting to restart consumer &quot; + consumer); } try { this.doConsumeFromQueue(consumer.getQueue()); } catch (AmqpIOException | AmqpConnectException var13) { this.logger.error(&quot;Cannot connect to server&quot;, var13); if (var13.getCause() instanceof AmqpApplicationContextClosedException) { this.logger.error(&quot;Application context is closed, terminating&quot;); this.taskScheduler.schedule(this::stop, new Date()); } break; } } this.lastRestartAttempt = now; } } } this.processMonitorTask(); }, this.monitorInterval); if (queueNames.length &gt; 0) { this.doRedeclareElementsIfNecessary(); //根据queue名称来执行线程池线程 this.getTaskExecutor().execute(() -&gt; { synchronized(this.consumersMonitor) { if (this.hasStopped) { if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Consumer start aborted - container stopping&quot;); } } else { BackOffExecution backOffExecution = this.getRecoveryBackOff().start(); while(true) { label54: while(true) { if (this.started || !this.isRunning()) { return; } this.cancellationLock.reset(); try { String[] var4 = queueNames; int var12 = queueNames.length; int var6 = 0; while(true) { if (var6 &gt;= var12) { break label54; } String queue = var4[var6]; //消费者消费消息的核心方法 this.consumeFromQueue(queue); ++var6; } } catch (AmqpIOException | AmqpConnectException var10) { long nextBackOff = backOffExecution.nextBackOff(); if (nextBackOff &lt; 0L || var10.getCause() instanceof AmqpApplicationContextClosedException) { this.aborted = true; this.shutdown(); this.logger.error(&quot;Failed to start container - fatal error or backOffs exhausted&quot;, var10); this.taskScheduler.schedule(this::stop, new Date()); return; } this.logger.error(&quot;Error creating consumer; retrying in &quot; + nextBackOff, var10); this.doShutdown(); try { Thread.sleep(nextBackOff); } catch (InterruptedException var9) { Thread.currentThread().interrupt(); } } } this.started = true; this.startedLatch.countDown(); } } } }); } else { this.started = true; this.startedLatch.countDown(); } if (this.logger.isInfoEnabled()) { this.logger.info(&quot;Container initialized for queues: &quot; + Arrays.asList(queueNames)); }} 消费者并发 123456789101112private void consumeFromQueue(String queue) { //根据queue名称来获取所有的消费者 List&lt;DirectMessageListenerContainer.SimpleConsumer&gt; list = (List)this.consumersByQueue.get(queue); if (CollectionUtils.isEmpty(list)) { //根据consumersPerQueue参数来控制每一个queue的数量 for(int i = 0; i &lt; this.consumersPerQueue; ++i) { this.doConsumeFromQueue(queue); } }} 消费者消费 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private void doConsumeFromQueue(String queue) { if (!this.isActive()) { if (this.logger.isDebugEnabled()) { this.logger.debug(&quot;Consume from queue &quot; + queue + &quot; ignore, container stopping&quot;); } } else { String routingLookupKey = this.getRoutingLookupKey(); if (routingLookupKey != null) { SimpleResourceHolder.bind(this.getRoutingConnectionFactory(), routingLookupKey); } Connection connection = null; try { connection = this.getConnectionFactory().createConnection(); } catch (Exception var14) { this.addConsumerToRestart(new DirectMessageListenerContainer.SimpleConsumer((Connection)null, (Channel)null, queue)); throw var14 instanceof AmqpConnectException ? (AmqpConnectException)var14 : new AmqpConnectException(var14); } finally { if (routingLookupKey != null) { SimpleResourceHolder.unbind(this.getRoutingConnectionFactory()); } } Channel channel = null; DirectMessageListenerContainer.SimpleConsumer consumer = null; try { channel = connection.createChannel(this.isChannelTransacted()); channel.basicQos(this.getPrefetchCount()); consumer = new DirectMessageListenerContainer.SimpleConsumer(connection, channel, queue); channel.queueDeclarePassive(queue); //消费者消费消息的核心代码，借助channel来获取消息并利用反射来实例化消费者对象 consumer.consumerTag = channel.basicConsume(queue, this.getAcknowledgeMode().isAutoAck(), this.getConsumerTagStrategy() != null ? this.getConsumerTagStrategy().createConsumerTag(queue) : &quot;&quot;, this.isNoLocal(), this.isExclusive(), this.getConsumerArguments(), consumer); } catch (AmqpApplicationContextClosedException var16) { throw new AmqpConnectException(var16); } catch (AmqpConnectException | IOException var17) { RabbitUtils.closeChannel(channel); RabbitUtils.closeConnection(connection); if (var17.getCause() instanceof ShutdownSignalException &amp;&amp; var17.getCause().getMessage().contains(&quot;in exclusive use&quot;)) { this.getExclusiveConsumerExceptionLogger().log(this.logger, &quot;Exclusive consumer failure&quot;, var17.getCause()); this.publishConsumerFailedEvent(&quot;Consumer raised exception, attempting restart&quot;, false, var17); } else if (var17.getCause() instanceof ShutdownSignalException &amp;&amp; RabbitUtils.isPassiveDeclarationChannelClose((ShutdownSignalException)var17.getCause())) { this.logger.error(&quot;Queue not present, scheduling consumer &quot; + consumer + &quot; for restart&quot;, var17); } else if (this.logger.isWarnEnabled()) { this.logger.warn(&quot;basicConsume failed, scheduling consumer &quot; + consumer + &quot; for restart&quot;, var17); } if (consumer == null) { this.addConsumerToRestart(new DirectMessageListenerContainer.SimpleConsumer((Connection)null, (Channel)null, queue)); } else { this.addConsumerToRestart(consumer); consumer = null; } } synchronized(this.consumersMonitor) { if (consumer != null) { this.cancellationLock.add(consumer); this.consumers.add(consumer); this.consumersByQueue.add(queue, consumer); if (this.logger.isInfoEnabled()) { this.logger.info(consumer + &quot; started&quot;); } if (this.getApplicationEventPublisher() != null) { this.getApplicationEventPublisher().publishEvent(new AsyncConsumerStartedEvent(this, consumer)); } } } }} 总结 DirectMessageListenerContainer利用线程池来管理channel线程，但每一个线程的底层消息消费逻辑与SimpleMessageListenerContainer相同，都是借助channel利用反射实现消费者实例化。 SimpleMessageListenerContainer提供了以下特性，但DirectMessageListenerContainer不提供: txSize—使用SimpleMessageListenerContainer，您可以将其设置为控制事务中传递的消息数量和/或减少ack的数量，但这可能会导致失败后重复传递的数量增加。(与txSize和SimpleMessageListenerContainer一样，DirectMessageListenerContainer也有mesagesPerAck，可以用来减少ack，但不能用于事务—每个消息都在单独的事务中交付和打包)。 maxconcurrentconsumer和consumer伸缩间隔/触发器—DirectMessageListenerContainer中没有自动伸缩;但是，它允许您以编程方式更改consumersPerQueue属性，并相应地调整使用者。 然而，与SimpleMessageListenerContainer相比，DirectMessageListenerContainer有以下优点: 在运行时添加和删除队列更有效;使用SimpleMessageListenerContainer，整个使用者线程重新启动(所有使用者取消并重新创建);对于DirectMessageListenerContainer，不受影响的使用者不会被取消。 避免了RabbitMQ客户机线程和使用者线程之间的上下文切换。 线程是跨使用者共享的，而不是为SimpleMessageListenerContainer中的每个使用者都有一个专用线程。但是，请参阅“线程和异步使用者”一节中有关连接工厂配置的重要说明。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/8/4/rab-sim-dir/"},{"title":"rabbitmq中connection与channel","text":"本文重点讲解RabbitMQ中Connection与Channel的作用及相互关系并顺带理清channel与线程的配置方案。 生产者生产流程 建立链接（Connection） 在链接（Connection）上开启一个信道（Channel） 声明一个交换机（Exchange） 声明一个队列（Queue） 使用路由键（RoutingKey）将队列（Queue）和交换机（Exchange）绑定起来 根据路由键（RoutingKey）发送消息到交换机（Exchange） [MQ]根据交换机（Exchange）和路由键（RoutingKey），将消息或存放到队列（Queue），或丢弃，或回给生产者 关闭信道（Channel） 关闭链接（Connection） 消费者消费流程 建立链接（Connection） 在链接（Connection）上开启一个信道（Channel） 请求消费指定队列（Queue）的消息，并设置回调函数（onMessage） [MQ]将消息推送给消费者 消费者发送消息确定（Ack[acknowledge]） [MQ]删除被确认的消息 关闭信道（Channel） 关闭链接（Connection） Connection与Channel的关系以SimpleMessageListenerContainer为例来看下生产与消费关系，如下图： 生产者发送消息 通常一个应用创建一个connection连接（通过TCP实现）当然可以创建多个 一个connection可被多个channel复用 一个channel是单线程的 channel单线程串行发送消息 消费者消费消息-单线程 通常一个应用创建一个connection连接（通过TCP实现）当然可以创建多个 一个connection可被多个channel复用 一个channel是单线程的 channel单线程串行消费消息 消费者消费消息-多线程 通常一个应用创建一个connection连接（通过TCP实现）当然可以创建多个 分布式服务创建各自对应的connection 一个connection可被多个channel复用 设置参数concurrency来控制线程数，相当于为每一个消费者创建了多个channel 消费者对应的多个channel可以被不同的微服务共享，例如针对消费者consumer-a的Channel-a/Channel-b可以被微服务Application-b/Application-b1公用，只是线程不同 channel单线程串行消费消息 SimpleMessageListenerContainer并发的实现并非依赖线程池而是通过对消费者创建多个channel来实现多线程，每个channel依然是单线程串行执行的。 非阻塞I/O多路复用connection是建立在TCP之上的虚拟连接，多个channel共用同一个connection，这样做的好处是减少了频繁的channel开启或关闭造成的TCP资源浪费。多个channel复用同一个connection。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/8/3/co_ch/"},{"title":"rabbitmq消息积压解决思路","text":"问题场景借助mq实现解耦、削峰、异步场景时由于多种内外部因素很有可能遇到消息积压的情况，即短时间内大量消息无法被立即消费，造成消息阻塞。可以参考“rabbitmq中connection与channel”了解两者关系。 产生原因 生产者生产速度大于消费者消费速度 消费者部分/全部异常无法消费消息 生产者-消费者设计原因导致积压 消费者异常 未ACK消息：由于消费者代码问题导致未能成功ACK，建议ACK操作不与业务代码关联，单独做ack 重复ACK同一个消息：queue中的每一个消息都有一个唯一tag且自增，如果重复消费相同tag会报io异常并引起channel关闭，虽然channel后续会重启但是有可能造成消息重复消费或者丢失问题。 消费者模型设计详情可以参考“rabbitmq中SimpleMessageListenerContainer与DirectMessageListenerContainer” 简而言之消费者是需要配置监听容器的用于消息监听与消费 SimpleMessageListenerContainer适用于小业务量简单业务场景，一个消费者可以配置一个/多个channel，一个channel对应一个线程，channel可以被相同queue的不同消费者复用，但需要rabbitmq客户端线程与消费者线程之前切换比较耗费资源。 SimpleMessageListenerContainer的升级玩法是消费者中单独使用业务线程池，将不同的queue消息交由不同的业务线程池处理，channel线程仅仅做ack操作。这样做的优点是现有功能维护升级简便同时兼顾线程调度优势，缺点是同样无法避免channel线程间切换的问题。 DirectMessageListenerContainer相对来说适用于大数据量业务场景，一个消费者可以配置一个/多个channel，一个channel调用一个线程池线程，线程池可以被相同消费者的不同queue通用（主要看如何配置），当然如果每一个queue对应独立的消费者那么线程池是独立的。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/8/3/mq-backlog/"},{"title":"死信队列和延迟队列","text":"死信队列&amp;死信交换器 DLX 全称（Dead-Letter-Exchange）,称之为死信交换器，当消息变成一个死信之后，如果这个消息所在的队列存在x-dead-letter-exchange参数，那么它会被发送到x-dead-letter-exchange对应值的交换器上，这个交换器就称之为死信交换器，与这个死信交换器绑定的队列就是死信队列。 死信消息 消息被拒绝（Basic.Reject或Basic.Nack）并且设置 requeue 参数的值为 false 消息过期 队列达到最大的长度 过期消息 12345在 rabbitmq 中存在2种方可设置消息的过期时间，第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间，第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。如果同时使用这2种方法，那么以过期时间小的那个数值为准。当消息达到过期时间还没有被消费，那么那个消息就成为了一个 死信 消息。队列设置：在队列申明的时候使用 x-message-ttl 参数，单位为 毫秒单个消息设置：是设置消息属性的 expiration 参数的值，单位为 毫秒 延时队列 在rabbitmq中不存在延时队列，但是我们可以通过设置消息的过期时间和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/10/26/rabbitmq-dxl/"},{"title":"php环境准备","text":"前言php语言大家比较耳熟能详,作为强大的服务器端脚本语言,其在许多领域得到应用同时也得到了像facebook等大公司的信赖,本文不对其发展史做详细介绍,主要就php的环境准备做详细描述. 想要运行php项目必须具备基本的三要素: 第一是完成php运行环境的安装与配置 第二是安装服务器容器如iis\\apache等 第三是必须安装实下流行的浏览器进行浏览 php环境配置首先需要去官网下载适合的版本下载地址 1234512/6/2018 8:43 PM 24425705 php-7.0.33-nts-Win32-VC14-x64.zip 12/6/2018 8:43 PM 22346551 php-7.0.33-nts-Win32-VC14-x86.zip 12/6/2018 9:14 PM 26103356 php-7.0.33-src.zip 12/6/2018 8:43 PM 24539294 php-7.0.33-Win32-VC14-x64.zip 12/6/2018 8:43 PM 22419115 php-7.0.33-Win32-VC14-x86.zip 例如7.0.33版本提供五种下载,其中nts表示非线程安全,vc14表示php依赖于vc++14,下载包中已经具备,具体配置如下: 解压压缩包至指定目录,如D:\\installSoft\\php-7.0.33-Win32-VC14-x64 在PHP根目录中有php.ini-production和php.ini-development这两个配置文件（使用哪个取决于你自己，PHP官方建议将前者用于生产环境，后者多用于开发环境），这里我选择使用php.ini-development，现在将php.ini-development复制一份备份，然后将php.ini-development改为php.ini即可。 将php安装目录添加至pash环境变量D:\\installSoft\\php-7.0.33-Win32-VC14-x64 cmd输入php -v 测试是否安装成功,如果显示出版本好则成功 在php.ini中搜索extension_dir = &quot;ext&quot;，删除前面的;，并将exc修改为你的PHP根目录下的php/ext目录，我这里修改为：extension_dir = &quot;D:/installSoft/php-7.0.33-Win32-VC14-x64/ext&quot;(注意是/而不是\\) PHP开启Mysql扩展安装PHP之后必定会用到数据库，现在在 php.ini 中搜索：;extension=mysqli 和 ;extension=pdo_mysql，（建议两者都开启）；删除前面的;即可。 apache容器配置 官网下载apach容器,详情可参考[1] 解压到指定目录(不要有中文)如D:\\installSoft\\httpd-2.4.41-o111c-x64-vc15-r2\\Apache24 进入D:\\installSoft\\httpd-2.4.41-o111c-x64-vc15-r2\\Apache24\\conf\\httpd.conf文件修改Define SRVROOT为真实apache目录,修改默认端口号80为88(如果有需要) 12345Define SRVROOT &quot;D:/installSoft/httpd-2.4.41-o111c-x64-vc15-r2/Apache24&quot;Listen 80ServerName localhost:80 将apache加入pash环境变量D:\\installSoft\\httpd-2.4.41-o111c-x64-vc15-r2\\Apache24\\bin 以管理员方式打开cmd,并进入apache目录的bin目录,并执行命令httpd -k install,如下 启动apache需打开cmd执行命令httpd -k start,浏览器输入localhost:88,若正常出现apache主页则表示成功 apache常用命令如httpd -k restart/httpd -k stop 若需要将apache与php关联需要进行额外配置,如下:打开 Apache 的配置文件httpd.conf，在LoadModule行后添加以下代码 针对php版本 1234567LoadModule php7_module &quot;D:/installSoft/php-7.0.33-Win32-VC14-x64/php7apache2_4.dll&quot;&lt;IfModule php7_module&gt; AddHandler application/x-httpd-php .php AddType application/x-httpd-php .php .html PHPIniDir &quot;D:/installSoft/php-7.0.33-Win32-VC14-x64&quot;&lt;/IfModule&gt; 针对php5版本 1234567LoadModule php5_module C:/PHP/php5apache2_4.dll&lt;IfModule php5_module&gt; DirectoryIndex index.html index.php AddHandler application/x-httpd-php .php PHPIniDir &quot;C:/PHP&quot;&lt;/IfModule&gt; 保存文件后重启apache即可 httpd -k restart 运行测试测试 启动apache 在apache根目录D:\\installSoft\\httpd-2.4.41-o111c-x64-vc15-r2\\Apache24\\htdocs创建phptest.php文件 在文件编写简单php交本语句如 123&lt;?phpphpinfo();?&gt; 浏览器输入http://localhost:88/phptest.php 参考资料: [1]https://www.cnblogs.com/lovetree/p/6385957.html [2]https://www.cnblogs.com/nwgdk/p/8654182.html var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/12/24/phpenv/"},{"title":"redis基础","text":"本文是对redis的简单介绍，底层逻辑和深层设计思想不在本文，目的是让读者能够对redis又一个基本且全方位的认识。 redis基础为什么说redis能够快速执行i. 绝大部分请求是纯粹的内存操作（非常快速） ii. 采用单线程,避免了不必要的上下文切换和竞争条件 iii. 非阻塞IO - IO多路复用 Redis中的五种数据结构 string (字符串) redis是使用C语言开发，但C中并没有字符串类型，只能使用指针或符数组的形式表示一个字符串，所以redis设计了一种简单动态字符串(SDS[Simple Dynamic String])作为底实现： 定义SDS对象，此对象中包含三个属性： len buf中已经占有的长度(表示此字符串的实际长度)所以取字符串的长度的时间复杂度为O(1) free buf中未使用的缓冲区长度 buf[] 实际保存字符串数据的地方 空间分配原则：当len小于IMB（1024*1024）时增加字符串分配空间大小为原来的2倍，当len大于等于1M时每次分配 额外多分配1M的空间。 由此可以得出以下特性： 二进制安全的 高效的计算字符串长度(时间复杂度为O(1)) 高效的追加字符串操作 list (列表) 在3.2版本之前，列表是使用ziplist和linkedlist实现的。 列表对象使用ziplist编码有如下条件： 列表对象保存的所有字符串元素的长度都小于64字节 列表对象保存的元素数量小于512个 当有任一条件 不满足时将会进行一次转码，使用linkedlist。 而在3.2版本之后，重新引入了一个quicklist的数据结构，列表的底层都是由quicklist实现的，它结合了ziplist和linkedlist的优点。按照原文的解释这种数据结构是【A doubly linked list of ziplists】意思就是一个由ziplist组成的双向链表 ziplist的结构 由表头和N个entry节点和压缩列表尾部标识符zlend组成的一个连续的内存块。 主要用于存储整数和比较短的字符串 插入/删除元素时需要对内存进行调整，还要进行部分数据的移动操作 更新效率低下 linkedlist的结构 双向链表，插入和删除效率很高，查询的效率却是O(n)[n为元素的个数]。 quicklist结构 它整体宏观上就是一个链表结构，只不过每个节点都是以压缩列表ziplist的结构保存着数据，而每个ziplist又可以包含多个entry。也可以说一个quicklist节点保存的是一片数据，而不是一个数据。 set (集合) 通过散列表（hashtable）来保证自已存储的每个字符串都是各不相同的值(这些散列表只有键，但没有与键相关联的值)集合是无序的 intset用于存储整数的有序集合，里面存放同一类型的整数。共有三种整数：int16_t、int32_t、int64_t。查找的时间复杂度为O(logN)，但是插入的时候，有可能会涉及到升级（比如：原来是int16_t的集合，当插入int32_t的整数的时候就会为每个元素升级为int32_t）这时候会对内存重新分配，所以此时的时间复杂度就是O(N)级别的了。注意：intset只支持升级不支持降级操作。 hash (哈希) hash底层的数据结构实现有两种： ziplist实现 当存储的数据超过配置的阀值时就是转用hashtable的结构。这种转换比较消耗性能，所以应该尽量避免这种转换操作。同时满足以下两个条件时才会使用这种结构：当键的个数小于hash-max-ziplist-entries（默认512）当所有值都小于hash-max-ziplist-value（默认64） hashtable实现 这种结构的时间复杂度为O(1)，但是会消耗比较多的内存空间。 zset (有序集合) 有序集合和散列一样，都用于存储键值对 有序集合的键被称为成员（member),每个成员都是各不相同的 有序集合的值则被称为分值（score），分值必须为浮点数 有序集合是redis里面唯一一个既可以根据成员访问元素(这一点和散列一样),又可以根据分值以及分值的排列顺序访问元素的结构 它的存储方式也有两种： ziplist结构与上面的hash中的ziplist类似，member和score顺序存放并按score的顺序排列 skiplist与dict的结合，skiplist用来保障有序性和访问查找性能，dict就用来存储元素信息，并且dict的访问时间复杂度为O(1) Redis的持久化 RDB持久化 RDB持久化即通过创建快照（压缩的二进制文件）的方式进行持久化，保存某个时间点的全量数据。RDB持久化是Redis默认的持久化方式。RDB持久化的触发包括手动触发与自动触发两种方式。 AOF持久化 AOF（Append-Only-File）持久化即记录所有变更数据库状态的指令，以append的形式追加保存到AOF文件中。在服务器下次启动时，就可以通过载入和执行AOF文件中保存的命令，来还原服务器关闭前的数据库状态。 RDB、AOF混合持久化 Redis从4.0版开始支持RDB与AOF的混合持久化方案。 首先由RDB定期完成内存快照的备份，然后再由AOF完成两次RDB之间的数据备份，由这两部分共同构成持久化文件。 该方案的优点是充分利用了RDB加载快、备份文件小及AOF尽可能不丢数据的特性。 缺点是兼容性差，一旦开启了混合持久化，在4.0之前的版本都不识别该持久化文件，同时由于前部分是RDB格式，阅读性较低。 Redis 持久化方案的建议 如果Redis只是用来做缓存服务器，比如数据库查询数据后缓存，那可以不用考虑持久化，因为缓存服务失效还能再从数据库获取恢复。 如果你要想提供很高的数据保障性，那么建议你同时使用两种持久化方式。如果你可以接受灾难带来的几分钟的数据丢失，那么可以仅使用RDB。 通常的设计思路是利用主从复制机制来弥补持久化时性能上的影响。即Master上RDB、AOF都不做，保证Master的读写性能，而Slave上则同时开启RDB和AOF（或4.0以上版本的混合持久化方式）来进行持久化，保证数据的安全性。 Redis 持久化方案的优缺点 RDB持久化 优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。 缺点：做不到实时持久化，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。 AOF持久化 与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。 缓存穿透、缓存击穿、缓存雪崩解决方案 缓存穿透 指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。 解决方案： i. 查询返回的数据为空，仍把这个空结果进行缓存，但过期时间会比较短 ii. 布隆过滤器：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对 DB 的查询。 缓存击穿 对于设置了过期时间的 key，缓存在某个时间点过期的时候，恰好这时间点对这个 Key 有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。 解决方案： i. 使用互斥锁：当缓存失效时，不立即去 load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db 的操作并回设缓存，否则重试 get 缓存的方法。 ii 永远不过期：物理不过期，但逻辑过期（后台异步线程去刷新）。 缓存雪崩 设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB， DB 瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多 key，击穿是某一个key 缓存。 解决方案： 将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 Redis 的集群模式 主从复制 当从数据库启动时，会向主数据库发送sync命令，主数据库接收到sync后开始在后台保存快照rdb，在保存快照期间收到的命令缓存起来，当快照完成时，主数据库会将快照和缓存的命令一块发送给从数据库。 复制初始化结束。 之后，主每收到1个命令就同步发送给从。 当出现断开重连后，2.8之后的版本会将断线期间的命令传给从数据库。 哨兵模式 哨兵的作用： 1、监控redis主、从数据库是否正常运行 2、主出现故障自动将从数据库转换为主数据库。 哨兵的核心知识 1、哨兵至少需要 3 个实例，来保证自己的健壮性。 2、哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。 3、对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。 4、配置哨兵监控一个系统时，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库。 Redis分布式锁先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，这个锁就永远得不到释放了，使用set指令把setnx和expire合成一条指令来用 一些问题 **内存淘汰机制**（当内存不足以容纳新写入数据时） noeviction: 新写入操作直接报错 allkeys-lru：移除最近最少使用的 key allkeys-random：随机移除某个 key volatile-lru：在设置了过期时间的键空间中，移除最近最少使用的 key volatile-random：在设置了过期时间的键空间中，随机移除某个 key volatile-ttl：在设置了过期时间的键空间中，有更早过期时间的 key 优先移除 Redis 和 Mysql 的数据不一致怎么办 对于热点数据我们通常会放入redis中来增加读取效率，但是需要保证从数据库到redis的数据最终一致性。为了保证一致性我们需要考虑两个问题： redis数据是采用更新操作还是删除操作更好？ 操作数据库与操作缓存的顺序应该是怎么样的？ 直接说结论： redis删除操作更加友好。更新缓存的消耗更大（更新操作交给缓存执行）且更容易造成数据不一致（涉及到复杂业务计算时可能会反复更新缓存）。 无论谁前谁后在多线程环境下都有可能在两者间隙中发生意外从而引起数据不一致。虽然间隙无法避免但先操作数据库再操作缓存会更好控制一些。 延时双删 第一步：先删除缓存（为了清除老数据） 第二步：再写入数据库 第三步：休眠xxx毫秒（根据具体的业务时间来定）（避免立即删除缓存导致的其他同步线程将脏数据刷入） 第四步：再次删除缓存（为了清除其他线程增加的脏数据） 123456public void use(String key, Object data){ redis.delKey(key); db.updateData(data); Thread.sleep(800); redis.delKey(key);} 异步更新缓存+重试策略 基于mysql binlog进行数据库更新分析 异步分析binlog来更新缓存 更新缓存失败借助mq实现重试来达到最终一致性 Redis常见性能问题和解决方案 i. Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件；(Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作;AOF文件过大会影响Master重启的恢复速度) ii. 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次 iii. 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内 iv. 尽量避免在压力很大的主库上增加从库 v. 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…；这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。 mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据 1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru 2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？ 使用keys指令可以扫出指定模式的key列表 对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。 项目中有没有用Redis事务 采用的是Redis Cluster集群架构，不同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效的。其次，Redis事务不支持回滚操作，所以基本不用！ 参考资料 [1]https://blog.csdn.net/qq1515312832/article/details/113880849 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/10/11/redis-base/"},{"title":"软件研发（开发）流程与规范","text":"一、研发过程中遇到的问题？ 研发的过程既是创造的过程，既然是过程那么必然涉及时间的消耗、精力的消耗、待处理目标、处理结果等要素，面对这样复杂的事务如果我们没有一套适合自己的研发流程与规范，那么或多或少必将面对如下问题： 1、研发耗时长 2、研发过程反复 3、研发过程不可控 4、实际成功与预期目标存在巨大差异 5、易产生不可预知的bug 6、影响研发人员心情乃至拖延整体团队进度 …… 二、如何建立良好的研发流程与规范？ 流程与规范不是枷锁，而是提升工作效率的催化剂，适合自己的才是最好的。 良好的研发流程与规范应该具备如下要素： 充分的沟通 全面的思考 对目标结果的清晰预期 对过程的强力把控 具备约束力 符合自己的做事风格 结合自身实际情况现将本人总结的研发流程与规范进行分享，如下图： 三、案例分享 —需求分析 1、非延期–今天代办：到期日期&lt;=当前日期，且非延期任务（不显示无到期日期的任务） 2、非延期–最近七天代办：到期日期&lt;=当前日期+6天，且非延期任务（不显示无到期日期的任务） 3、非延期–所有代办：包括无到期日期，且非延期任务 4、延期处理—原条件不变，即延期任务 5、排序记录：前端通过浏览器storage实现持久化存储 6、列表数量查询接口更新 —涉及到的原始接口 40002/taskCentre/task/query/list 列表查询接口 40002/taskCentre/task/countTodoTaskAndDelayTask 列表数量查询接口 30032/api/GeneralSetting/GetGeneralContentBykey 任务分类获取接口 —优化建议 问题：测试时发现在我的代办任务种点击不同的任务分页都会调用一遍列表、数量、分类三种接口，其中数量、分类着两种接口数据是固定的无需每次切换分页都要调用。 建议：第一次点击我的代办任务时调用三种接口，后期即使切换分页也只需调用list接口和list数量接口即可。 —注意 1、需要将历史facade版本合并到master，并从master拉取最新代码到0814 2、非延期任务状态后端枚举是否需要设定对应的基础信息–不需要（任务延期状态也没有配置） 3、如果当前用户拥有管理视角且具备企业数据权限，则将查询系统内所有任务。如果只拥有管理视角，则查询自身以及下属任务。 —facade-api com.yqn.order.facade.vo.request.taskcenter.TaskQueryVO L116 com.yqn.order.facade.vo.response.taskcenter.TaskCountVO —facade-service com.yqn.order.facade.manager.TaskManager L471 com.yqn.order.facade.service.TaskQueryFacadeServiceImpl L276 —task-api –需要将api发布到maven com.yqn.task.enums.TaskNotDelayStatus 新建 com.yqn.task.dto.task.TaskQueryDTO L193 com.yqn.task.dto.search.TaskSearchReqDTO L226 —task-service com.yqn.task.transfer.TaskSearchTransfer L155 com.yqn.task.manager.search.TaskSearchManager L166,L186,L426 com.yqn.task.util.DateUtil L133 —测试接口参数案例 1、列表查询接口 xUserId：0 —必填 { delayHandleStatus: 1, notDelayHandleStatus：0, isManager: false, —必填 page: 1, —必填 size: 20, —必填 sort: [] } 2、列表数量查询接口（理论上其参数是要同列表查询接口保持一致） —测试用例 https://docs.qq.com/sheet/DWlFXdm53TXBnaVRP?opendocxfrom=admin&amp;preview_token=&amp;t=1565004059930&amp;coord=K46C0Z0&amp;tab=BB08J2 四、编程规范 将编程规范放在最后去讲，这并不代表编码规范不重要，编码规范因编程语言、所在团队、个人习惯而异，简单来说需符合一下标准： 1、遵循项目架构—不同任务功能集成至相应项目 2、符合调用层级关系 3、注意功能的拆分与封装 4、接口、类、方法注释明确—方便自己合其他人阅读 5、函数内清晰的处理逻辑与注释 6、在满足以上五条的基础上实现性能提升 …… var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/8/6/softDevelop/"},{"title":"BASE理论","text":"在讲述BASE理论之前我们首先要了解CAP理论,详情可参考CAP理论.Base理论是对CAP理论的进一步优化以满足大型分布式场景,更具有应用价值. CAP权衡通过CAP理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？ 对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。 对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA。还有一种是保证CP，舍弃A。例如网络故障事只读不写。 孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。 BASE理论eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。 BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。 **基本可用:**基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用. **软状态:**软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。简单来说就是状态可以在一段时间内不同步. **最终一致性:**系统中的所有数据副本经过一定时间后，最终能够达到一致的状态，不需要实时保证系统数据的强一致性。最终一致性是弱一致性的一种特殊情况。 BASE理论是C\\A之间的权衡,BASE理论面向的是大型高可用可扩展的分布式系统，通过牺牲强一致性来获得可用性。ACID是传统数据库常用的概念设计，追求强一致性模型。简单来说就是在一定的时间窗口内， 最终数据达成一致即可。 最终一致性的分类因果一致性（Causal consistency）因果一致性指的是：如果节点A在更新完某个数据后通知了节点B，那么节点B之后对该数据的访问和修改都是基于A更新后的值。于此同时，和节点A无因果关系的节点C的数据访问则没有这样的限制。 读己之所写（Read your writes）读己之所写指的是：节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。 会话一致性（Session consistency）会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。 单调读一致性（Monotonic read consistency）单调读一致性指的是：如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。 单调写一致性（Monotonic write consistency）单调写一致性指的是：一个系统要能够保证来自同一个节点的写操作被顺序的执行。 在实际的实践中，这5种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。 实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的。比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。 参考内容: https://my.oschina.net/foodon/blog/372703 https://juejin.im/post/5b2663fcf265da59a401e6f8 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/11/27/base/"},{"title":"CAP理论","text":"CAP：任何分布式系统在可用性、一致性、分区容错性方面，不能兼得，最多只能得其二，因此，任何分布式系统的设计只是在三者中的不同取舍而已。 CAP的历史 1985年Lynch证明了异步通信中不存在任何一致性的分布式算法（FLP Impossibility）的同时，人们就开始寻找分布式系统设计的各种因素。一致性算法既然不存在，但若能找到一些设计因素，并进行适当的取舍以最大限度满足实现系统需求成为当时的重要议题。比如，在CAP之前研究者就已经发现低延迟和顺序一致性不可能同时被满足。 2000年，Eric Brewer教授在PODC的研讨会上提出了一个猜想：一致性、可用性和分区容错性三者无法在分布式系统中被同时满足，并且最多只能满足其中两个！ 这个猜想首次把一致性、可用性和分区容错三个因素提炼出来作为系统设计的重要特征，断言用此三者可以划分所有的分布式系统，并指明这三个特征之间的不可能性关系。 Brewer教授当时想象的分布式场景是webservice，一组websevrice后台运行着众多的server，对service的读写会反应到后台的server集群，并对CAP进行了定义：C（一致性）：所有的节点上的数据时刻保持同步A（可用性）：服务一直可用，而且是正常响应时间P（分区容错）：分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务 高可用、数据一致是很多系统设计的目标，但是分区又是不可避免的事情： CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。例如对一致性要求较高的银行系统,宁可报错而终止也要保持一致性。 CP without A：如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。 AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。 CAP的出现仿佛是一盏明灯，它揭露了分布式系统的本质，并给出了设计的准则，而这正是1985年以来人们正在寻找的东西！所以CAP在当时的影响力是非常大的！ CAP证明2002年，Lynch与其他人证明了Brewer猜想，从而把CAP上升为一个定理。但是，她只是证明了CAP三者不可能同时满足，并没有证明任意二者都可满足的问题，所以，该证明被认为是一个收窄的结果。Lynch的证明相对比较简单：采用反正法，如果三者可同时满足，则因为允许P的存在，一定存在Server之间的丢包，如此则不能保证C，证明简洁而严谨。在该证明中，对CAP的定义进行了更明确的声明： C：一致性被称为原子对象，任何的读写都应该看起来是“原子“的，或串行的。写后面的读一定能读到前面写的内容。所有的读写请求都好像被全局排序。 A：对任何非失败节点都应该在有限时间内给出请求的回应。（请求的可终止性） P：允许节点之间丢失任意多的消息，当网络分区发生时，节点之间的消息可能会完全丢失 当国内工程师对CAP痴迷的时候，国外的工程师和研究者对CAP提出了各种质疑，纷纷有用反例证明着CAP在各种场合不适用性，同时挑战着Lynch的证明结果！纵观这些质疑，基本都是拿着一个非常具体的系统，用CAP的理论去套，最后发现要么CAP不能Cover所有的场景，要么是CAP的定义非常模糊，导致自相矛盾！一句话，把CAP接地气是非常困难的！你是否看了CAP的概念定义后还是感觉很模糊？如果是，你并不孤独，有很多人都是如此！CAP没有考虑不同的基础架构、不同的应用场景、不同的网络基础和用户需求，而C、A、P在这些不同场景中的含义可能完全不同，这种无视差异化的定义导致了非常大的概念模糊，同时也变成CAP被质疑的源头！ 面对大量的质疑，Brewer和Lynch终于坐不住了，因此两人纷纷出来澄清Brewer于2012年重申： 在某些分区极少发生的情况下，三者能顺畅地在一起配合 CAP不仅仅是发生在整个系统中，可能是发生在某个子系统或系统的某个阶段 Lynch也在10年后的2012年重写了论文，该论文主要做了几件事： 把CAP理论的证明局限在原子读写的场景，并申明不支持数据库事务之类的场景 一致性场景不会引入用户，只是发生在后台集群之内 把分区容错归结为一个对网络环境的陈述，而非之前一个独立条件。这实际上就是更加明确了概念 引入了活性(liveness)和安全属性(safety)，在一个更抽象的概念下研究分布式系统，并认为CAP是活性与安全熟悉之间权衡的一个特例。其中的一致性属于liveness，可用性属于safety 把CAP的研究推到一个更广阔的空间：网络存在同步、部分同步；一致性性的结果也从仅存在一个到存在N个（部分一致）；引入了通信周期round，并引用了其他论文，给出了为了保证N个一致性结果，至少需要通信的round数。也介绍了其他人的一些成果，这些成果分别都对CAP的某一个方面做出了特殊的贡献！ 其实Lynch的论文主要就是两件事：缩小CAP适用的定义，消除质疑的场景；展示了CAP在非单一一致性结果下的广阔的研究结果！并顺便暗示CAP定理依旧正确！ 如何看待CAP首先肯定的是，CAP并不适合再作为一个适应任何场景的定理，它的正确性更加适合基于原子读写的NoSQL场景。质疑虽然很多，但很多质疑者只是偷欢概念，并没有解决各个因素之间的取舍问题。而无论如何C、A、P这个三个概念始终存在任何分布式系统，只是不同的模型会对其有不同的呈现，可能某些场景对三者之间的关系敏感，而另一些不敏感。就像Lynch所说，现在分布式系统有很多特性，比如扩展性、优雅降级等，虽然时间的发展，或许这些也会被纳入研究范畴，而作为开发者，这都是我们需要考虑的问题，而不仅是CAP三者！ 参考内容如下: 【0】https://blog.csdn.net/chen77716/article/details/30635543 【1】http://en.wikipedia.org/wiki/Cap_theorem【2】http://lpd.epfl.ch/sgilbert/pubs/BrewersConjecture-SigAct.pdf【3】http://groups.csail.mit.edu/tds/papers/Gilbert/Brewer2.pdf【4】http://markburgess.org/blog_cap.html【5】http://blog.cloudera.com/blog/2010/04/cap-confusion-problems-with-partition-tolerance/【6】http://cacm.acm.org/blogs/blog-cacm/83396-errors-in-database-systems-eventual-consistency-and-the-cap-theorem/fulltext【7】http://nathanmarz.com/blog/how-to-beat-the-cap-theorem.html【8】http://highscalability.com/blog/2011/11/23/paper-dont-settle-for-eventual-scalable-causal-consistency-f.html var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/11/27/cap/"},{"title":"XA分布式事务原理","text":"XA简介XA是由X/Open组织提出的分布式事务的规范。 XA规范主要定义了(全局)事务管理器(TM)和(局 部)资源管理器(RM)之间的接口。主流的关系型数据库产品都是实现了XA接口的。XA规范可以说是分布式事务理论的开拓者,现如今的分布式事务框架在实现理论上多少都有XA的身影. 详细介绍 XA接口是双向的系统接口，在事务管理器 （TM）以及一个或多个资源管理器（RM）之 间形成通信桥梁。 由全局事务管理器管理和协调的事务，可以跨 越多个资源（如数据库或JMS队列）和进程。 全局事务管理器一般使用 XA 二阶段提交协议 与数据库进行交互。 资源管理器（resource manager）：用来管理系统资源，是通向事务资源的途径。数据库就是一种资源管理器。资源管理还应该具有管理事务提交或回滚的能力。 事务管理器（transaction manager）：事务管理器是分布式事务的核心管理者。事务管理器与每个资源管理器（resource manager）进行通信，协调并完成事务的处理。事务的各个分支由唯一命名进行标识 第一阶段为 准备（prepare）阶段。即所有的参与者准备执行事务并锁住需要的资源。参与者ready时，向transaction manager报告已准备就绪。 第二阶段为提交阶段（commit）。当transaction manager确认所有参与者都ready后，向所有参与者发送commit命令。 XA性能局限性效率低下，准备阶段的成本持久，全局事务状态的成本持久，性能与本地事务相差10倍左右；提交前，出现故障难以恢复和隔离问题。 借鉴资源如下: https://blog.csdn.net/wuzhiwei549/article/details/79925618 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/11/26/xaTransaction/"},{"title":"分布式事务方案Saga理论","text":"一 简介谈到分布式事务不得不提Saga理论,具体可查看论文[1].Saga是基于BASE理论的一种分布式事务实现模式以最终实现”最终一致性”. 1987年普林斯顿大学的Hector Garcia-Molina和Kenneth Salem发表了一篇Paper Sagas，讲述的是如何处理long lived transaction（长活事务）,Saga经过多年发展衍生出多种实现方式,如集中式\\非集中式等。 在我们的业务场景下，一个行程规划的事务就是一个Saga，其中包含四个子事务：机票预订、租车、酒店预订、和支付。 二 Saga的运行原理 Saga中的事务相互关联，应作为（非原子）单位执行。任何未完全执行的Saga是不满足要求的，如果发生，必须得到补偿。要修正未完全执行的部分， 每个saga子交易T1应提供对应补偿事务C1 我们根据上述规则定义以下事务及其相应的事务补偿： 当每个saga子事务 T1, T2, …, Tn 都有对应的补偿定义 C1, C2, …, Cn-1, 那么saga系统可以保证 子事务序列 T1, T2, …, Tn得以完成 (最佳情况) 或者序列 T1, T2, …, Tj, Cj, …, C2, C1, 0 &lt; j &lt; n, 得以完成 换句话说,通过事务/补偿机制saga保证满足如下业务规则:如果有一个子事务失败则全部取消并执行对应的C补偿事务. 2.1Saga的组成 每个Saga由一系列sub-transaction Ti 组成 每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果 可以看到，和TCC相比，Saga没有“预留”动作，它的Ti就是直接提交到库。 2.2Saga的两种执行顺序 T1, T2, T3, …, Tn T1, T2, …, Tj, Cj,…, C2, C1，其中0 &lt; j &lt; n 前者是正常执行Saga长链事务,后者是在出现错误时的补偿机制 2.3Saga的两种恢复策略 backward recovery，向后恢复，即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。 forward recovery，向前恢复，适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中j是发生错误的sub-transaction。该情况下不需要Ci。 三 Saga的使用条件 Saga只允许两个层次的嵌套，顶级的Saga和简单子事务 每个子事务应该是独立的原子行为 Ti和Ci是幂等的 Ci必须是能够成功的，如果无法成功则需要人工介入 Ti - Ci和Ci - Ti的执行结果必须是一样的：sub-transaction被撤销了 要求Ti和Ci是幂等的，举个例子，假设在执行Ti的时候超时了，此时我们是不知道执行结果的，如果采用forward recovery策略就会再次发送Ti，那么就有可能出现Ti被执行了两次，所以要求Ti幂等。如果采用backward recovery策略就会发送Ci，而如果Ci也超时了，就会尝试再次发送Ci，那么就有可能出现Ci被执行两次，所以要求Ci幂等。 要求Ci必须能够成功，这个很好理解，因为，如果Ci不能执行成功就意味着整个Saga无法完全撤销，这个是不允许的。但总会出现一些特殊情况比如Ci的代码有bug、服务长时间崩溃等，这个时候就需要人工介入了。 四 Saga LogSaga保证所有的子事务都得以完成或补偿，但Saga系统本身也可能会崩溃。Saga崩溃时可能处于以下几个状态： Saga收到事务请求，但尚未开始。因子事务对应的微服务状态未被Saga修改，我们什么也不需要做。 一些子事务已经完成。重启后，Saga必须接着上次完成的事务恢复。 子事务已开始，但尚未完成。由于远程服务可能已完成事务，也可能事务失败，甚至服务请求超时，saga只能重新发起之前未确认完成的子事务。这意味着子事务必须幂等。 子事务失败，其补偿事务尚未开始。Saga必须在重启后执行对应补偿事务。 补偿事务已开始但尚未完成。解决方案与上一个相同。这意味着补偿事务也必须是幂等的。 所有子事务或补偿事务均已完成，与第一种情况相同。 为了恢复到上述状态，我们必须追踪子事务及补偿事务的每一步。我们决定通过事件的方式达到以上要求，并将以下事件保存在名为saga log的持久存储中： Saga started event 保存整个saga请求，其中包括多个事务/补偿请求 Transaction started event 保存对应事务请求 Transaction ended event 保存对应事务请求及其回复 Transaction aborted event 保存对应事务请求和失败的原因 Transaction compensated event 保存对应补偿请求及其回复 Saga ended event 标志着saga事务请求的结束，不需要保存任何内容 通过将这些事件持久化在saga log中，我们可以将saga恢复到上述任何状态。 五 与其它分布式理论的对比5.1与TCC对比缺点: Saga相比TCC的缺点是缺少预留动作，导致补偿动作的实现比较麻烦 优点: 有些业务很简单，套用TCC需要修改原来的业务逻辑，而Saga只需要添加一个补偿动作就行了。 TCC最少通信次数为2n，而Saga为n（n=sub-transaction的数量）,TCC的缺点是其两阶段协议需要设计额外的服务待处理状态，以及额外的接口来处理尝试请求。 有些第三方服务没有Try接口，TCC模式实现起来就比较tricky了，而Saga则很简单。 没有预留动作就意味着不必担心资源释放的问题，异常处理起来也更简单（请对比Saga的恢复策略和TCC的异常处理）。 5.2与本地消息表对比优点: 能够服务的动态治理,新服务加入更加顺畅,本地消息表在新增服务的情况下将影响上下游服务,需要配合改动。 六 Saga的实现6.1Apache ServiceComb Pack Saga Execution Component解析请求JSON并构建请求图 TaskRunner 用任务队列确保请求的执行顺序 TaskConsumer 处理Saga任务，将事件写入saga log，并将请求发送到远程服务 ServiceComb Pack实现的Saga是集中式的实现方式,内部具备协调者的角色并支持日志记录. 6.2集中式与非集中式实现非集中式saga没有专职的协调器。启动下一个服务调用的服务就是当前的协调器。例如， 服务A收到要求服务A，B和C之间的数据一致性的事务请求。 A完成其子事务，并将请求传递给事务中的下一个服务，服务B. B完成其子事务，并将请求传递给C，依此类推。 如果C处理请求失败，B有责任启动补偿事务，并要求A回滚。 与集中式相比，非集中式的实现具有服务自治的优势。但每个服务都需要包含数据一致性协议，并提供其所需的额外持久化设施。 集中式还有一个比较大的好处是能够更好的避免事务之间的循环依赖关系 6.3其它saga实现框架Apache Camel Saga https://camel.apache.org/ Eventuate Tram Saga http://eventuate.io/abouteventuatetram.html Seata Saga Seata是阿里开源的分布式事务框架其中支持Saga方式,详情可参考Seata相关资料 https://github.com/seata/seata 参考资料如下: [1]http://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf [2]https://github.com/chanjarster/transactions/blob/master/saga.md [3]https://www.upyun.com/opentalk/310.html var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/12/5/sagabase/"},{"title":"分布式事务现有框架初识","text":"简介本文仅对目前市面上现存的分布式事务框架做简短介绍,用于在实际框架选型中做初步参考. TX-LCN“LCN不生产事务,仅仅是本地事务的协调者”,简单理解LCN通过”协调者服务”来协调各服务内部的本地服务,最终实现分布式事务. TX-LCN由两大模块组成, TxClient、TxManager，TxClient作为模块的依赖框架，提供TX-LCN的标准支持，TxManager作为分布式事务的控制放。事务发起方或者参与反都由TxClient端来控制。 5.0以后由于框架兼容了LCN、TCC、TXC三种事务模式，为了避免区分LCN模式，特此将LCN分布式事务改名为TX-LCN分布式事务框架。 优点: 接入成本低,依赖本地事务即可实现分布式事务,原理类似于通过本地消息表实现分布式事务,避免了手动搭建的繁琐,能够提供较完整的分布式事务控制. 缺点: 由于其依赖TxManager协调者,因此根据目前的版本来看协调者之间不支持多点部署,存在单点问题. Apache ServiceComb Pack首先简单介绍下Apache ServiceComb项目,该项目是针对微服务应用而提供的相关微服务中间件工具,例如微服务框架SDK\\服务注册和发现\\分布式事务\\配置中心等等.其中就具备Apache ServiceComb Pack分布式事务中间件,为了便于叙述,下面简称为ASCP. ASCP是最终一致性分布式事务解决方案,目前提供TCC和Saga两种分布式事务实现方式,其中Alpha作为协调者服务,Omega作为参与者服务. 特点 高可用：支持高可用的集群模式部署。 高可靠：所有的关键事务事件都持久化存储在数据库中。 高性能：事务事件是通过高性能gRPC来上报的，且事务的请求和响应消息都是通过Kyro进行序列化和反序列化。 低侵入：仅需2-3个注解和编写对应的补偿方法即可引入分布式事务。 部署简单：支持通过容器（Docker）进行快速部署和交付。 补偿机制灵活：支持前向恢复（重试）及后向恢复（补偿）功能。 扩展简单：基于Pack架构很容实现多种协调协议，目前支持TCC、Saga协议，未来还可以添加其他协议支持。 Apache Camel SAGA EIPcamel首先是一款规则引擎,其次是一款基于规则快速实现消息流转的开发组件，集成该组件后，你的程序可以编写最少的代码实现复杂的消息在不同的协议规则间流转。 Apache Camel 作为集成项目的利器，针对应用集成场景的抽象出了一套消息交互模型，通过组件的方式进行第三方系统的接入，目前Apache Camel已经提供了300多种组件能够接入HTTP，JMS，TCP，WS-*，WebSocket 等多种传输协议。Apache Camel结合企业应用集成模式（EIP）的特点提供了消息路由，消息转换等领域特定语言（DSL），极大降低了集成应用的开发难度。Apache Camel通过URI的方式来定义需要集成的应用节点信息，用户可以按照业务需求使用DSL快速编写消息路由规则，而无需关注集成协议的细节问题。与传统的企业集成服务总线（ESB）相比，Apache Camel的核心库非常小巧（是一个只有几M的jar包），可以方便地与其他系统进行集成。 Apache Camel 作为基于知名的企业应用模式（Enterprise Integration Patterns）多功能的整合框架.其内部也提供了SAGA EIP组件用于实现SAGA模式,可以自由设定路由规则,设定消息的回滚和补偿方案,在某种程度上可以实现分布式事务. Eventuate TramEventuateTram(以下简称ET)作为内嵌在微服务框架中的平台致力于解决分布式数据管理问题.ET针对基于java/Spring的微服务应用构建,采用JDBC/JAP为基础的一致性模型,其最大的特点是接入成本低,改动小. 特点 能够实现saga模式 支持跨服务的查询指令 基于CQRS(Command Query Responsibility Segregation)的视图 可发布/订阅事件 支持异步收发命令 ET应用架构如上图,应用由两部分组成: Todo Service:将接收到的消息持久化到MySQL数据库分别是TODO表和Message表并支持Todo View Service的订阅和消费. Todo View Service:负责订阅事件并更新到ES ET支持saga模式并提供补偿机制,本质上是BASE理论的实践能够达到最终一致性,是本地消息表+分布式消息的结合.但是ET的缺点也比较明确,CDC依然存在单点问题,事务逻辑依赖Mysql,消息依赖kafka,查询依赖ES,如果原有架构不兼容以上几种组件那么在现有项目实施时会遇到巨大障碍. Seata/FescarFescar 是 阿里巴巴 开源的 分布式事务中间件，以 高效 并且对业务0侵入的方式，解决 微服务场景下面临的分布式事务问题。由2014年最初的TXC发展成2016年的GTS最后到2019年的Fescar.Fescar更名为Seata,两者是同一个东西.详情可见官网[Seata] 优点 支持AT\\TCC\\SAGA\\XA等多种分布式事务模式 对业务无侵入/侵入小(AT) 高性能(TCC) TC独立部署可以方便分布式事务的监控 文档相对齐全\\社区相对活跃\\上手难度小 缺点 目前依然不是太完善,正在不断优化中,如XA模式正在开发 TC目前不支持集群模式,无法避免单点问题 EasyTransaction一站式解决分布式SOA（包括微服务等）的事务问题 特点 引入JAR包即用，无需独立部署协调者，无需独立部署ZooKeeper(使用extensionsuite-database-starter时) 一个框架包含多种事务形态，一个框架搞定所有类型的事务 多种事务形态可混合使用 高性能,大多数业务系统瓶颈在业务数据库，若不启用框架的幂等功能，对业务数据库的额外消耗仅为写入25字节的一行 可选的框架自带幂等实现及调用错乱次序处理，大幅减轻业务开发工作量,但启用的同时会在业务数据库增加一条幂等控制行 业务代码可实现完全无入侵 支持嵌套事务 分布式事务ID可关联业务ID，业务类型，APPID，便于监控各个业务的分布式事务执行情况 整合Seata的AT模式，改造行锁使其存储到本地，改造集中式TC为ET的分布式协调 不存在TC的单点问题,设计架构理念更先进 缺点 没有相对活跃的社区,作者维护频率略低 没有相对完善的学习文档,上手要花费不少时间 其它分布式事务框架 [tcc-transaction].https://github.com/changmingxie/tcc-transaction [Hmily].https://github.com/yu199195/hmily [ByteTCC].https://github.com/liuyangming/ByteTCC [TransactionEssentials].https://www.atomikos.com/Main/WebHome 参考链接: [TX-LCN].https://www.txlcn.org/zh-cn/docs/principle/control.html [Apache ServiceComb].http://servicecomb.apache.org/developers/ [Apache ServiceComb Pack].https://github.com/apache/servicecomb-pack/blob/master/README_ZH.md [Apache Camel SAGA EIP].https://camel.apache.org/manual/latest/saga-eip.html [Apache Camel简介].https://my.oschina.net/u/3569919/blog/3129377 [Eventuate Tram].http://eventuate.io/abouteventuatetram.html [Seata].https://seata.io/zh-cn/docs/overview/what-is-seata.html [EasyTransaction].https://github.com/QNJR-GROUP/EasyTransaction var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/12/9/frame/"},{"title":"分布式系统的数据一致性","text":"一 什么是事务?事务一词是新兴词汇,从字面意思来看可能会感觉比较晦涩陌生,但是在软件行业这个词还是听的挺多的.事务无处不在,先来举个小栗子,比如我们要去逛超市购物那么需要先推一辆车再选购商品,再支付,而这整个流程就是事务.再例如支付这个节点也可以分为掏出手机,打开支付宝/微信,完成扫描,支付成功,这一整个过程又可以看作一个事务,其实我们看不到的还有支付宝内部的一连串处理节点,也是其自身的事务等等等…… 通过上面的简单举例我们可以看出事务有如下特性: 事务的最终目的是完成某件事或实现某目标 事务可被拆分为更小的组成单元/步骤,即事务是一种特殊的集合 事务集合中任何节点的失败都将造成整个事务的失败 二 事务的起源 提到事务不得不提到「XA规范」，详情可参考XA分布式事务原理 三 CAP理论事务问题其实一直存在，只是在分布式系统中被放大了。并且随着系统拆分的粒度越细，问题的复杂度成指数上升。 「CAP」理论由Eric Brewer在2000年PODC会议上提出，所以还被称为Brewer定理。是Eric Brewer在Inktomi期间研发搜索引擎、分布式web缓存时得出的一个猜想,后来Seth Gilbert和Nancy Lynch对其进行了证明[3]，成为我们熟知的「CAP」定理. It is impossible for a web service to provide the three following guarantees : Consistency, Availability and Partition-tolerance. 详情可参考CAP理论 四 BASE理论详情可参考BASE理论 五 分布式事务的常见解决方案-以CAP为基础CAP理论以及BASE理论只是思想指导,基于这两种理论发展出一系列解决方案,每种方案的侧重点各有不同. 5.1 两阶段提交(2PC) 这是最简单的分布式事务解决方案,通过设立协调者来处理事务不同处理节点的相互关系. 两个阶段的执行 1.请求阶段在请求阶段，协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。 2.提交阶段在该阶段，协调者将基于第一个阶段的投票结果进行决策：提交或取消。当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务。参与者在接收到协调者发来的消息后将执行响应的操作。 两阶段提交的缺点 1.同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。 2.单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题） 3.数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这讲导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。 两阶段提交无法解决的问题 当协调者出错，同时参与者也出错时，两阶段无法保证事务执行的完整性。考虑协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。 5.2 三阶段提交协议 三阶段提交协议在协调者和参与者中都引入超时机制，并且把两阶段提交协议的第一个阶段拆分成了两步：询问，然后再锁资源，最后真正提交。 三个阶段的执行 1.CanCommit阶段3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。 2.PreCommit阶段协调者根据参与者的反应情况来决定是否可以继续事务的PreCommit操作。根据响应情况，有以下两种可能。A.假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会进行事务的预执行：发送预提交请求。协调者向参与者发送PreCommit请求，并进入Prepared阶段。事务预提交。参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。响应反馈。如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。 B.假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就中断事务：发送中断请求。协调者向所有参与者发送abort请求。中断事务。参与者收到来自协调者的abort请求之后（或超时之后，仍未收到参与者的请求），执行事务的中断。 3.DoCommit阶段 该阶段进行真正的事务提交，也可以分为以下两种情况: 执行提交 A.发送提交请求。协调者接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。B.事务提交。参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。C.响应反馈。事务提交完之后，向协调者发送ACK响应。D.完成事务。协调者接收到所有参与者的ACK响应之后，完成事务。 中断事务 协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。 三个阶段的特点 3pc中协调者\\参与者都进行了超时设置,2pc中只是协调者进行了超时设置,这样避免了协调者出现宕机后照成参与者产生上时间延时的问题. PreCommit是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的 “非阻塞协议”:三阶段提交在两阶段提交的第一阶段与第二阶段之间插入了一个准备阶段，使得原先在两阶段提交中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。 缺点:如果进入DoCommit阶段，由于网络原因，协调者发送的rollback响应没有及时被参与者接收到，那么部分参与者在等待超时之后执行了commit操作，而和其他接到rollback命令并执行回滚的参与者之间存在数据不一致的情况。 5.3 TCC模式 1、当所有try()方法均执行成功时，对全局事物进行提交，即由事物管理器调用每个微服务的confirm()方法2、 当任意一个方法try()失败(预留资源不足，抑或网络异常，代码异常等任何异常)，由事物管理器调用每个微服务的cancle()方法对全局事务进行回滚否则进行comfirm 基本原理 TCC 将事务提交分为 Try - Confirm - Cancel 3个操作。其和两阶段提交有点类似，Try为第一阶段，Confirm或Cancel为第二阶段，是一种应用层面侵入业务的两阶段提交。 操作方法 含义 Try 预留业务资源/数据效验 Confirm 确认执行业务操作，实际提交数据，不做任何业务检查，try成功，confirm必定成功，需保证幂等 Cancel 取消执行业务操作，实际回滚数据，需保证幂等 其核心在于将业务分为两个操作步骤完成。不依赖 RM 对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。 幂等控制 使用TCC时要注意Try - Confirm - Cancel 3个操作的幂等控制，网络原因，或者重试操作都有可能导致这几个操作的重复执行. 如何控制幂等,具体业务场景具体分析,例如在消费业务中由于网络等其它原因导致消费金额被提交了多次,这时如果不控制幂等将导致金额的持续扣除,我们可以接触业务逻辑进行避免,当第一次提交消费时标记以消费,那么第二次提交即可避免重复. 空回滚 如图所示，事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因为丢包而导致的网络超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；TCC服务在未收到Try请求的情况下收到Cancel请求，这种场景被称为空回滚；TCC服务在实现时应当允许空回滚的执行； 空回滚可以通过业务逻辑进行避免,当然也可以借助中间件实现,如在第一阶段try()执行完后，向一张事务表中插入一条数据(包含事务id，分支id)，cancle()执行时，判断如果没有事务记录则直接返回 防悬挂 如下图所示，事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因网络拥堵而导致的超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；在此之后，拥堵在网络上的一阶段Try数据包被TCC服务收到，出现了二阶段Cancel请求比一阶段Try请求先执行的情况； 用户在实现TCC服务时，应当允许空回滚，但是要拒绝执行空回滚之后到来的一阶段Try请求； 具体怎么解决呢?可以在二阶段执行时插入一条事务控制记录，状态为已回滚，这样当一阶段执行时，先读取该记录，如果记录存在，就认为二阶段回滚操作已经执行，不再执行try方法； TCC特点 通过运用本地事务代替了全局事务使得可以不需要协调者存在,避免了协调者单点问题 3PC协调者的作用时一旦发证宕机可以保证之后的数据回复,TCC中可以通过事务日志解决 以CAP理论为基础的解决方案通常会出现一个类似”协调者”的服务对象,以上这三种就是主流的DTS（Distributed Transaction Service）框架。 六 分布式事务的常见解决方案-以BASE为基础6.1异步消息-本地消息表 服务A在本地事务操作业务的同时插入一条数据到消息表 数据表操作完成后进行消息处理,进行RPC远程调用,并自主实现去重\\顺序\\重试等 服务B接手到消息后同服务A处理逻辑一致,也要向本地消息表插入记录,如果该消息被处理过则进行事务回滚,以保证不重复处理消息 服务B执行成后将更新自己本地消息表状态以及服务A消息表状态 如果服务处理失败则不更新本地消息表,此时服务A会定时扫描消息表对未处理消息进行重复消息处理,知道服务B成功执行服务. 一般情况下为保证最终一致性被调用服务必须执行成功(可多次调用),但上图和说明仅仅是思想原理,具体的实现方案可以根据实际情况定,例如在每一个服务中或单独抽出一个”消息回滚处理应用服务”进行失败消息的回滚处理. 本地消息表方案最初由ebay提出,其完整方案可看参考内容.此方案的核心是将需要分布式处理的任务划分为本地事务并通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。 6.2异步消息-不支持事务的MQ 与本地消息表唯一的区别是将远程调用控制改为由MQ控制的消息消费机制,借助MQ实现消息的顺序执行\\去重\\重试等机制. 其实大部分的MQ都是不支持事务的，所以我们需要自己想办法解决可能出现的MQ消息未能成功投递出去的问题。有个便宜可以捡的是，如果需投递的MQ消息条数仅有1的话，可以将本地事务的commit放于消息投递之后即可避免此问题。伪代码如下： 123456789try{ beginTrans(); modifyLocalData1(); modifyLocalData2(); deliverMessageToMQ(); commitTrans(); }catch(Exception ex){ rollbackTrans(); } 6.3异步消息-支持事务的MQ 如上图1,2,3,4步骤,即整个消息生产方与消息消费方之间的交互类似于TCC模式,但又有一些不同和补充,图解流程如下: MQ发送方(消息生产方)进行第一阶段提交,向MQ server进行确认,如图1,2 MQ发送方第一阶段完成后进行本地事务处理并根据事务处理结果进行commit(告知server可以投递消息)或rollback(告诉server不投递消息),如图3,4 若出现特殊情况如网络问题导致MQ server没有收到MQ发送方的第二阶段指令,那么将进行事务状态回查处理,如图5,6,7 MQ server接收到提交指令后将运行消息被消费并保证消息被消费,如果出现消息消费失败,则MQ server将重复发送,直至成功. 本方案的思路是基于BASE理论实现最终一致性 6.4Saga理论详情可参考分布式事务方案Saga理论 6.5Gossip算法Gossip算法因为Cassandra而名声大噪，Gossip看似简单，但要真正弄清楚其本质远没看起来那么容易。Gossip算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此Gossip有众多的别名“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。 Gossip算法又被称为反熵（Anti-Entropy），熵是物理学上的一个概念，代表杂乱无章，而反熵就是在杂乱无章中寻求一致，这充分说明了Gossip的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。 Gossip是一个带冗余的容错算法，更进一步，Gossip是一个最终一致性算法。虽然无法保证在某个时刻所有节点状态一致，但可以保证在”最终“所有节点一致，”最终“是一个现实中存在，但理论上无法证明的时间点。 因为Gossip不要求节点知道所有其他节点，因此又具有去中心化的特点，节点之间完全对等，不需要任何的中心节点。实际上Gossip可以用于众多能接受“最终一致性”的领域：失败检测、路由同步、Pub/Sub、动态负载均衡。 但Gossip的缺点也很明显，冗余通信会对网路带宽、CUP资源造成很大的负载，而这些负载又受限于通信频率，该频率又影响着算法收敛的速度，后面我们会讲在各种场合下的优化方法。 七 总结通过以上内容我们可以发现基于「CAP」的解决方案都是在线的，而「Base」是允许离线的。 不管怎样，如果每个解决方案中增加「重试」和「回滚」会大大提升程序的自我修正能力，以降低需要人为介入的比例。 这些基于「BASE」的解决方案都是可以作为「CAP」解决方案出现问题时的PlanB来用的，起到补充作用。当然，如非必要，可以优先考虑基于「BASE」的方案，毕竟这才是天然易伸缩的，自然也能带来更好的性能。 解决方案如此多，所以不管我们是架构师、还是在成为架构师的路上，甚至在日常生活中，都需要养成Balance的习惯，找到那个最适合的方案。 「事物都具有两面性」，所以，在选择走向分布式之前，慎重考虑下是否有必要，以免给自己徒增麻烦。 本文部分内容参考: https://www.imooc.com/article/75228 https://www.cnblogs.com/AndyAo/p/8228099.html https://blog.csdn.net/hosaos/article/details/89136666#TCC_100 https://queue.acm.org/detail.cfm?id=1394128 https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/11/25/dataconsistency/"},{"title":"人生规划","text":"为什么要写这篇文章？那是因为年近三十相对焦虑，对今后职业发展、家庭生活、健康、养老等一系列问题的担忧。其实人就是这么奇怪，学生时期为进入社会而焦虑、初工作时为房子车子而焦虑、现在为今后的稳定而焦虑，每一个阶段随着眼界、阅历、需求的变化，我们看待世界的方式也在发生变化，这就是焦虑的根源。 在正儿八经的聊人生规划之前首先需要聊一下国外一老爷子的高论“马斯洛需求理论”，如下图所示： 初次看到这个理论时如获至宝。这不就是一个正常人类的大体发展脉络吗？这不就是我们寻找的人生规划吗？ 从最开始的生理需求到有家室后到安全需求，一层一层构建了我们追求一生的真谛。当然详细的理论可参考网络，这里仅仅是引述，下面我来聊一下经过自己思考和整理的人生规划方法论。 为了做好人生规划的方法论，我看了许多人分享的经历、方法和思考，然后结合自己的认知整理出如下五条策略。 梦想清单（即大目标） 当找寻不到大目标的时候就去模仿，去模仿优秀的人，有了梦想后就要排优先级.这个大目标可以是生活、工作的，也可以是精神层面的。 做五年规划 按照五年的时间线来制定长远目标是合理的，如果时间过长制定的目标极有可能无法实现，因为随着时间的拉长社会和自己的认知都在变化，以过往老旧的思维方式制定的目标有可能过时，然而时间线过短不适合于远期目标的制定。五年刚好，我们如果把每一个五年都看作自己来到这个世界的一次历练，试想一下每一次历练我们可以反思可以继承上次历练的经验，是不是会很爽。 目标分解 远期目标往往是海市蜃楼，可望而不可及，在当下的我们需要将他们转化为切实可行，真真切切的小目标。利用逆向推导来分解小目标，利用smart原则来衡量小目标是否正确。 分段可执行 将目标的执行过程具体化为年/半年/月/周来进行推进。执行阶段也是非常重要的一个环节，计划安排的过于死板有可能使我们无法坚持，致使计划破产，如果过于松散又没有约束力。因此寻找出适合自己的计划执行节奏非常重要。 复盘反思总结调整 唯一可以确定一层不变的就是变化本身。对目标执行过程的反思，对方法论的总结，对目标的实时调整，这些才是符合现实逻辑的套路。 关于规划的一些小思考 时刻关注优先且不紧急的事情 越来越多的人过着看着很忙，实际很空虚的生活。那是因为主要精力都用到了不重要的事情上。合理的处理方式是我们应该将80%的精力用在20%最重要且不紧急的事情上面。为什么不优先做重要且紧急的事情而去做重要不紧急的事情？那是为了防止事情逐渐演变成重要且紧急的事情，使自己的生活节奏彻底打乱。比如我们需要健康的身体，在锻炼身体这件事上就属于重要且不紧急，我们应该优先做，而不是等待成为紧急的事情后再去处理。 努力提升自己，自己才是一切的本钱，包括赚钱。 不断提升自己的认知，不打无准备之仗，不做自己认知外的事情。 无论要实现什么目标或者做什么事情，一定一定要找到自己的动力来源，否则你会找一万种理由不去完成目标 参考资料： [1]https://www.zhihu.com/question/303781246/answer/1560002946 [2]https://zhuanlan.zhihu.com/p/41176561 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/2/22/life-plan/"},{"title":"从业可行性调研","text":"经过行业、职业、巨头、风投等方面的相关调研现整理出四大方向。这四大行业方向的共同特点是发展可持续、发展前景广阔，非常适合持续深耕。另一方面这四大行业对互联网也相对包容，信息化程度不高，适合具有互联网经验的从业人员入局，在入局后应该专注本行业内的业务和管理等方面的提升，互联网技术仅仅只是工具而已。 由于信息量过大，并非一文可以说明，因此本文仅仅针对大健康行业做详细调研，在调研方向上是以互联网从业者可以从事的职位以及具有发展潜力的职位为调研目标。 大健康 大健康目前的问题是什么？大健康目前最大的问题是没有找到一条完美的商业模式，目前的盈利点基本是“医疗电商”线上卖药。然而我认为大健康并不仅仅是看病和卖药，应该关注个人的全流程健康管理，即关注少儿的身心发育、关注青年的健康指导、关注中年的健康养生、关注老年的健康康复等。如果把一个正常个人按照健康阶段进行划分可分为“健康成长阶段”、“亚健康阶段”、“患病阶段”、“康复阶段”、“护理阶段”等，每一个阶段的需求不同，并不是一味的卖药就医就可以解决的。看病难，看病贵只是表象，深层次的原因是患病的前期和后期没有做到位或者说基本空白。 https://www.itjuzi.com/health 大健康的发展方向是什么？大健康是一个比较大的行业范围，其内部又可以分为众多的垂直领域，例如线上问诊、药品电商、药物研发、健康管理、慢性病管理、家庭医生等等等。每一个垂直领域都大有可为，总的来讲今后的大健康行业一定是信息化程度逐渐加强，各大平台以提供tob/toc的服务为主要发展方向，每一个垂直领域或许都会产生巨头。 https://zhuanlan.zhihu.com/p/26510165 大健康比较有前景的职业是什么？大健康行业有哪些独角兽企业？ 平安医保科技 简介： 公司以智慧医保系统为核心，咨询、服务、保险为辅助，打造智慧医保一体化平台，全面赋能医保局。同时，公司打造商保产品方案设计、风控、健康服务等TPA服务，并积极延伸至为医院、医生、药店、药企赋能。此外，公司还可为合作伙伴提供多元化专业医疗租赁服务，并为广大人民群众提供便捷、精准、安全的创新型健康检测服务。 致力于构建全面的医疗生态圈，结合保险、金融等共同构建多元化+科技赋能的全方位服务。 目前主要服务于企业和政府医保部门。 现状：官僚风气重，团队建设差，管理混乱，加班严重，没有核心产品，公司未上市 官网：https://paybkj.com/core-advance?part=part1 平安好医生 简介：全球领先的互联网医疗健康服务平台，目前平安健康医疗科技有限公司已经形成在线医疗、消费型医疗、健康商城、健康管理及互动等重点业务板块。 主要为toC提供服务，从咨询、转诊、挂号、购药、送药等为用户提供全流程服务，自身建设有线下医疗团队，为用户提供线上、线下咨询诊疗服务，除此之外借助ai诊疗系统实现辅助诊疗。 现状：目前的营收主要靠卖药，加班严重，内卷严重 官网：https://www.jk.cn 京东健康 简介：京东健康的产品和服务已经初步实现了对药品全产业链、医疗全流程、健康全场景、用户全生命周期的覆盖，构建了业内布局完整的“互联网+医疗健康”生态，核心业务有医药供应链、互联网医疗、健康管理、智慧医疗。 子品牌及产品，京东大药房、药京采、京东互联网医院、京东健康专科中心、智慧医院、家庭医生。 现状：京东的大健康做的还是比较全面的，以自身的物流供应链为基础构建药品采购、分销供应链，而互联网医院以及专科中心则完全是医院的互联网化，智慧医院面向线下医院为期提供互联互通等服务。家庭医生（京东家医）还是挺有意思的，思路很不错。目前已经上市，属于京东集团旗下独立运营子公司。 百科介绍：https://baike.baidu.com/item/京东健康/23639216 阿里健康 简介：目前，阿里健康开展的业务主要集中在医药电商及新零售、互联网医疗、消费医疗、智慧医疗等领域。简而言之相当于开了一家大医院，这家医院可以自己卖药也可要吸引外部资源入住提供卖药/看病服务，并积极利用大数据+AI来提供科技服务，利用互联网带来的便利性提供疫苗、挂号、体检等便民医疗服务。 现状：已港股上市，卖药为主，看病为辅，并没有解决大健康行业迫切解决的问题，也没有比较明确的健康管理战略，太过于看重患病阶段的投入而忽略了健康管理的价值。与其他同行一样的通病是没有找到一条完美的商业模式。 官网：https://www.alihealth.cn 百度健康 简介：百度的盘子铺的要比平安、阿里、京东等小得多，专注于toC服务，目前提供的服务有健康知识科普、在线咨询、挂号、问诊、卖药、卖保险等。 现状：百度健康2019年六月份才推向市场，目前没有上市，同样的百度健康也没有寻找到一条完美的商业模式，不过其在在线问诊方面做的挺好，签约医生质量高，数量多。 介绍网址：https://baike.baidu.com/item/百度健康/2770593 小荷健康-字节系 简介：简单描述为提供互联网医疗在线问诊、肿瘤名医问诊、疫苗预约和小荷医典健康科普等服务。 现状：字节入局大健康领域比较晚，目前来看相对单薄，2020年九月份收购名医网，十一月份推出小河APP，以提供健康科普内容为主，发展战略暂时不明确。 旗下公司：小荷医药、松果医疗、幺零贰四科技有限公司 介绍网址：https://zhuanlan.zhihu.com/p/272653836 微医 简介：微医的业务范围涵盖了互联网大健康领域的全产业链，包括线上问诊、线上咨询、医药知识库、互联网医院等。按照服务对象来划分几乎涵盖了所有行业对象，例如政府、企业、家庭、医院、药店、诊所等。目前看来其重点发展方向还是在互联网医院、线上问诊上。 现状：微医背靠腾讯具备天然的身份上的优势，但其目前存在的最大问题依然是大健康行业的常见问题-“没有找到一个完美的商业模式”。目前各大巨头在大健康领域实现盈利的大头都是卖药，以各种方式卖药，反而在问诊、健康服务等领域并没有找到合适的商业模式。微医涉及范围过多，没用重点的发展并不是一件好事，不过在大健康领域目前依然处于头部位置。（估值70亿美金，连续多年上市不成功） 官网：https://www.guahao.com 联影医疗 简介：主要做大型专业医疗设备并依靠设备来建设物联网同时构建医疗云。所谓的医疗云就是依靠物联网及大数据相关技术提供共享、智能、开放完全的医疗服务。 现状：总体来讲联影医疗还是不错的，融资能力强、有政府背景，在大健康领域排名靠前。当然也存在不少问题企业文化差（具有国企所特有的官僚风）、福利待遇差、内卷相对严重。 官网：https://www.united-imaging.com/cn/product/ucloud/ 高济医疗 简介：高济医疗践行“科技赋能智慧医疗”的理念，通过智慧药店、智慧医疗、健康管理三位一体的创新模式，实现线上线下一体化、药品与诊疗服务相结合的全方位全周期的长期健康管理。为患者提供以健康检测、智能问诊、在线诊疗、慢病管理、患者教育、新药特药推广、社区家庭医生服务为核心的一站式疾病和健康管理方案，为社会提升基础医疗能力，为医疗大健康产业提供最佳的服务入口。 现状：其主要采用线下药店加盟的方式做药品新零售并依托自身信息化能力提供药店、药品、问诊、健康咨询、健康教育等一系列大健康相关服务，做到线上线下协调发展。目前来看盈利还是在卖药上，且内部管理混乱，一味的靠资本垄断市场。至于关系信息化方面的成功，目前来看还不明显。 官网：https://www.gaojihealth.com/ 爱康国宾 简介：爱康主营业务是体检和健康管理，采用线下实体店的方式进行服务，服务对象包括个人和企业。 现状：目前没有看到线上话的动向，中规中矩的老牌大健康企业 官网：http://www.ikanggroup.com/cn/pc/index.html 全棉时代—稳健医疗winner 简介：致力于为广大医护人员和患者提供全球领先的感染防护、伤口护理和家庭护理整体解决方案。 现状：20年九月份上市A股，稳健医疗的主营方向是护理产品的研发、生产、销售，在信息化程度方面很低。 官网：http://www.winnermedical.cn 安翰医疗 简介：是一家武汉的医疗企业生产企业，主要产品有两款“胃镜系统”、“内窥镜控制设备” 现状：09年成立，目前为止两款产品，无信息化战略，未上市 官网：https://www.ankoninc.com.cn 春雨医生 简介：春雨医生的主营方向是线上问诊，其他的附带服务包括面向企业和个人的健康咨询，针对个人提供免费的医疗问诊服务，医生可以在春雨医生开设自己的在线诊所实行自主定价诊疗，除此之外春雨医生面向全国各大医院医生开放入住服务，医生空闲时登录春雨医生进行轻问诊，提供线上问诊线下就医的全套服务。还有一点比较吸引人的是春雨医生依托自身积累的医生大数据、诊疗数据开发出了“自问诊”，即自己给自己诊断，借助数据和智能算法的加持这项服务值得点赞。 现状：11年成立，暂未上市，亮点是管理层和创始人都是互联网行业的领军人物，不过目前来看仅仅靠线上问诊的模式很难实现盈利，注册医生质量质量参差不齐，免费问诊如何盈利？付费问诊如何保证问诊质量的明显提高？当前的盈利模式是医生诊费的抽成，不卖药，只进行推荐，这种盈利模式很难吃到行业的大蛋糕。 官网：https://www.chunyuyisheng.com 介绍网址：https://baike.baidu.com/item/春雨医生 丁香园 简介：丁香园的角色是做医疗领域连接者，连接医生、科研人士、患者、医院、生物医药企业和保险企业等大健康行业的关键对象。在大众端，丁香园覆盖了优质健康科普、大众知识服务、在线问诊平台、健康产品电商及线下诊疗等多个健康应用场景；在医生专业端，丁香园紧紧围绕医生的职业成长路径展开，满足了学术交流、继续教育、用药指导、职业发展等多个专业需求。 现状：获得多轮融资，受资本青睐，暂未上市。丁香园以服务于医护人员的论坛、资讯、药品查询、考证考级等起家，慢慢发展为连接大健康各总要角色的互联网大健康企业。目前依然以服务专业的医护人员为基础并针对普通用户提供线上诊疗、咨询、知识、电商产品等一系列的健康服务。整体来看发展前景还是不错的，不过个人更喜欢ToB/ToC的健康管理类方向。 官网：https://portal.dxy.cn 好大夫在线 简介：好大夫在线目的是建立医患沟通平台，目前来看已经初具互联网医院雏形，从找医生、线上问诊、专家问诊、线下挂号、电子处方药、合作药店药品配送、医后康复、家庭医生等环节来看构建出了完整的医患沟通流程。目前的发力重点依然是线上问诊。 现状：在互联网医疗领域医生就是宝贵且有限的资源，好大夫的主要目标就是更好的服务于医生，好大夫吸引医生的重要一点是提供了便利的患者管理方式，医生有自己的主页，可润色自己的主页吸引患者，患者可对医生进行评论，构建出良性循环。医生利用闲暇时间实现有利可图自然就会依赖平台，区别于春雨的是好大夫没有春雨的动态医患分配，使得医生反馈时间拉长。不过总的来看好大夫前景不错。 官网：https://www.haodf.com/info/aboutus.php 辣妈帮 简介：其是服务女性的一站式孕产育教综合服务平台，目前主要以论坛的形式提供咨询，同时与外部商家合作销售商品。 现状：经过多轮融资，暂未上市。 官网：http://www.lamabang.com 思派网络 简介：主要发展方向是做肿瘤大数据服务平台，目前经过了多轮融资深受资本青睐，成立于14年，拟21年下半年赴港上市。除了服务中心之外，思派针对tob或者toc都有覆盖，例如针对tob的“全科医疗团队”，针对toc的“专科就医网络”，同时还创造性的增加了一些医疗服务的附加服务，例如与保险相结合、药房服务、新药临床试验等。 现状：总的来说思派是一家重数据、重服务的互联网医疗服务企业，目前还未上市但前景广阔。 官网：https://www.medbanks.cn/aboutSiPai.html 妙手医生 简介：妙手医生成立于2015年，目前拥有妙手互联网医院、圆心药房连锁、妙手医生App、妙手B2C商城、医院处方共享平台等事业板块。妙手医生已建设成全国性的专业医患复诊平台和安全用药配药中心，更基于互联网技术打造“互联网+医疗+药品”的全新健康管理模式。 现状：主要发展方向是建设互联网医院，服务包括线上问诊、药品电商以及医疗相关知识科普。目前来看发展势头不错，15年成立，已经融资E轮，是一家医疗服务行业的独角兽企业。 介绍网站：https://www.itjuzi.com/company/30958 太美医疗 简介：生命科学产业数字化运营平台，其是针对tob面向医药研发相关企业的数字化服务平台，内部有众多专业性医药行业软件，为药企提供数字化信息改造和服务。 现状：其实就是一家服务于药企相关行业的saas服务企业，目前融资到了F轮，融资节奏快。在医疗互联网竞争如此白热化的当下，太美另辟蹊径专注药企垂直领域发展也是个不错的方向。 网站：https://www.taimeitech.com 未来医生—企鹅医生/企鹅杏仁 简介：2021年4月15日，企鹅杏仁集团正式升级为：未来医生综合医疗服务集团。运用科技便捷地提供全链路健康咨询、全流程智能数据健康管理、家庭医生服务、医生多点执业服务、卓越专科及手术中心服务、海外医疗服务等业务类型，旨在“用科技，使高品质的健康与医疗服务，变得人人可及”。 现状：新成立有活力，背靠腾讯有发展。未来医生的模式是线上线下协同发展，线下开设诊所，线上提供诊疗相关服务“医生共享门诊服务”，针对医生设立专属通道吸引各医院精英并组件自身医疗团队坐诊，针对家庭用户开设有家庭医生，针对企业用户开设企业医生。总的来说未来医院的重心是建立线上线下医疗服务体，大力发展对外医疗服务。我看好，前景不错。 官网：https://www.doctorwork.com/index/pc/ 介绍网站：https://baike.baidu.com/item/企鹅杏仁 小小世界集团—小小世界大健康平台 简介：小小世界集团主业其实是做新零售，小小世界大健康平台更像是一个全球大健康产业链进行互联互通的整合平台，本身并不产生产品而是作为产业链交流的平台。 现状：更像是论坛或者社区，目前没有产品产出或者明显的商业方向，未来发展不明。 官网：http://www.miniworld.cn/?p=447 医联—医联健康 简介：医联成立于14年，主做慢性病管理，慢性病范围覆盖领域较广，平台汇聚全国实名认证医生为患者提供包括治疗建议、治疗效果评价、电子处方、用药指导、心理辅导、生活方式干预等一系列有效、低价、可及的院外慢病管理服务。 现状：简单来讲服务模式就是以平台化的方式提供一些便医的服务来吸引医生入住，然后服务于患者并实现线上卖药。目前未上市，受多家著名风投青睐。 官网：https://medlinker.com/product/drugstore 药研社 简介：药研社是专注为制药企业提供创新型药物研发服务的CRO科技平台，业务具体涵盖CRO、SMO、中心快速启动、患者招募、人力外派，及智能数据服务等一站式服务。 现状：简单来说药研社服务于药企，对药企在药物研发过程中需要的项目申报、管理、患者招募等一些列相关环节提供服务。药研社比较有亮点的地方是借助信息化大力发展医药研发数据服务，构建大数据服务和应用。成立于12年，暂未上市，目前融资到D轮。 官网：https://www.yaoyanshe.com/aboutMe 小药药—药帮忙 简介：药帮忙是一家医药行业综合服务平台，立足于国内医药流通行业，以互联网及软件技术为手段，通过聚合行业供应链中不同环节的企业，形成一个互联互通、信息共享、业务互动的商务平台。 现状：简单讲小药药旗下的药帮忙是以tob的卖药电商为发展的突破口，在此基础上逐渐发展出线上问诊、医药知识传播、药店数字化运营等相关领域，并与各药企、药店有合作关系。目前看来其发展战略是以tob电商为主，大通医药产业链为目标。目前深受各大风投青睐，暂未上市。 官网：https://www.ybm100.com/cms/activity/2020/9/5295.htm 养老行业养老行业今后的发展趋势是什么？养老本质上是更好的服务老人，满足老人的需求，这样来看实际上细分领域会非常多，每一个领域能做好也是很大一块蛋糕。 老年人最迫切的需求是什么？ 健康 护理 生活起居 陪伴 养老行业比较有前景的职业是什么？养老行业有哪些独角兽企业？ 职业教育 保险行业 [1]https://med.sina.com/article_detail_100_1_86745.html var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/3/23/industry_feasibility/"},{"title":"各行业或职业调研","text":"前言未来社会自动化、智能化将消灭部分工作岗位并创造一定的工作岗位。 2030年，最多将有1亿中国人将重新就业—重新就业是个机遇点 工作可以分为两类，可预期的工作和不可预期的工作。主业从事可预期的工作，副业重试不可预期的工作，因为不可预期意味着变数，意味着无限可能。 无论主业还是副业，应该以进入有潜力的行业、公司、职业、职位为目标，要能够形成积累不断构建自己的壁垒并以此扩展自己的影响力，不能吃青春饭，成为能够为其他人提供帮助的人。 所谓的人脉不是能够帮助到你的人，而是你能够帮助的人！ 无论选择什么职业，都要能够看到5年10年甚至更长时间的职业发展状态。 只有和人打交道的工作才能有更多的机会才能有提升。 见识和资源对普通人来讲永远是最稀缺的。 本文将参考本站的“行业潜力调研”来做一些个人认为比较有发展潜力的行业/职业方面的浅析。 记住：行动才是一切的开始！ AI相关专用人工智能-&gt;半人工智能-&gt;通用型人工智能这个过程必将是长时间段的且涉及到各行各业的赋能型行业，可以类比为第三次工业革命中的互联网行业，前景广阔，必将改造整个社会，极大的提升效率，改变人类进程。 算法工程师 机器学习工程师 深度学习工程师 计算机视觉工程师 非技术性岗位：与AI相关的营销、策划、市场等 服务业相关AI的崛起必将消灭一部分岗位并创造一部分岗位，人们将从繁琐的劳动中解放出来，这个时候将极大的促进/改变服务业。 互联网连接人与服务 toC发展成熟toB还有很大空间 思考一下企业刚需是什么？ 互联网相关互联网的本质是连接，云计算的彻底普及将是互联网的归途，云计算为服务业上云提供基础 区块链的去中心化如何落地？ 云计算+服务如何落地？ 互联网+大健康如何落地？ 互联网+保健品服务？ 互联网+职业教育？ 互联网+养老相关服务业？ 互联网+保险服务，解决供需问题是关键 大健康养老服务业不错 职业教育 养老行业 保险行业结合互联网也将会诞生很多新玩法并随着人口老龄化以及人民保险意识的提高将迎来较大发展 大健康当前可做的职业未来医生（企鹅杏仁） 医生、技师、护士是招聘的大头，少量招聘运营人员和技术人员。目前从官网进入导航到拉勾网可查看职位。java中级最高可给25k。 丁香园 主要招聘医疗行业专业人员、市场、运营，上海范围内不招聘技术人员。不过丁香园有一个丁香人才板块，里面涵盖了各大医疗行业企业的招聘信息，可以参考。 妙手医生 主要招收药店相关的店员、店长以及药品销售、药品项目经理等与医药相关职位，薪资不高，一万左右。技术人员招的少，薪资20-30k。 好大夫在线 招聘主要面向两方面，第一是面向医生的医生服务代表和服务于医院的医院代表等，第二是各类技术人员，目前来看薪资较高。不过技术人员都是在北京招聘，上海范围内仅仅有第一种。 思派网络 总部在北京，上海也有分布，在上海范围内的招聘主要有医生以及技术人员，其中技术岗位占多数，薪资20-30k。上海办公地点在普陀区，全部行程一个半小时，可以接受。 百度健康 百度在上海的总部大量招聘技术人员以及项目管理相关人员，薪资在行业内算是高的了，当然所招聘的职位也是中高级为主。至于医疗行业的岗位极少，目前只见到智慧医疗的pmo职位。专门针对百度健康的招聘目前没找到，或许是招的方式和途径不对。 小荷健康 20年九月份才新成立，目前小荷健康以及企业公司均未找到招聘信息，可以到字节的招聘下寻找，但目前没有发现相关职位。 京东健康 目前招聘职位均在北京，上海没有。主要招医护人员、药师和技术人员。 小药药 招聘岗位均在武汉，主要有保险方面专业人员、医药方面专业人员、技术人员、产品、数据分析等。 阿里健康 招聘地点在北京和杭州，职位主要有：公关、人力、技术、算法、测试、新媒体内容策划。 春雨医生 招聘地点在北京，主要岗位有：产品、运维、技术、销售、家庭医生。高薪资依然在技术上，家庭医生反而不高。 大健康其他企业 开发工程师、（医学）产品经理、技术相关（技术总监/技术经理）、项目经理、算法工程师、运营、医疗销售顾问（商务策划）、健康内容创作、健康评估师、健康管理师、医学数据分析、健康业务负责人 RPA相关职位 开发工程师（薪资较低）、产品（薪资正常） 不可预期的工作/职业实现副业目标并非一触而就，需要多调研多了解，开阔视野。 有一天失业了，副业能否养活自己 自媒体 视频制作者 摄影师 研究员-调研、整理、报告 网红 开网店-不仅仅是卖实物，不仅仅指代淘宝、咸鱼这些 商业咨询顾问-分答、在行 创作内容线上销售-课程、音频、视频、设计图等等 app独立开发者 SEO优化 专业型新媒体运营 金融理财 古董收藏 回收黄金 知识付费，流量变现，持续受益，聚少成多 技术/职业专业性方面软件技术类职业注定不利于年长者长期存在，职业特点要求有干劲、抗压强、能够付出时间、不断学习的年轻人来替代行业内的老人。行业内的年长者即使拥有丰富的职业经验，但面对年轻人时，其自身也没有明显的竞争优势。技术迭代过快，以往的职业经验并不值钱，技术同样不值钱，无法变现。因此软件技术类职业并不能长久，成为行业内业务精英或者管理者才是长久的选择。 中国最缺的，是懂管理、懂技术、懂业务的人。 程序员、网络工程师、数据库管理员这类人构成了 IT 共和国的主体，这个阶层是十九世纪的产业大军在二十一世纪的再现，只不过劳作的部分由肢体变成大脑，繁重程度却有增无减。在渺如烟海的程序代码和迷宫般的网络软硬件中，他们如二百多年前的码头搬运工般背起重负，如妓女般彻夜赶工。信息技术的发展一日千里，除了部分爬到管理层的幸运儿，其他人的知识和技能很快过时，新的 IT 专业毕业生如饥饿的白蚁般成群涌来，老的人（其实不老，大多三十出头）被挤到一边，被代替和抛弃，但新来者没有丝毫得意，这也是他们中大多数人不算遥远的前景…… 这个阶层被称做技术无产阶级。—《2018 年 4 月 1 日—刘慈欣》 其实，对于我们程序员来讲，悲哀的不仅仅是因为变成了新时代的工人，最重要的是程序员在这个变化的世界中没有认识到技术之外的东西才最挣钱，丧失了对世界的认知，自己的思维却一直陷入在技术里，局限了自己的视野，环顾周围，就知道沉浸在技术世界里，在这个技术世界（IT共和国）里当着辛苦的工人，而没想过突破圈层，去看看更高的世界是什么样？ 归根结底，软件技术类职业的痛点是技术天花板地、上升通道窄、自造围城成为井底之蛙、不能够有效开发与维护资源、与外界隔绝丧失社会竞争力、更新换代快职场老人竞争力差、内卷过于严重。 技术专家-&gt;CTO 架构师-&gt;CTO 产品经理-&gt;CTO—产品可以更接近真实需求，能将需求转换为利润 项目经理-&gt;CTO 去外企继续从事技术类工作 技术写手 教师/培训师 运营 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/8/27/professional/"},{"title":"国家政策","text":"前言在中国没有一个人是不被政策所影响的，也没有一个政策是不针对人的，因此经常了解和掌握国家、地区的建设政策、发展政策、金融政策等由于与更好的融入社会。 我们处在一个信息爆炸的社会，如何高效获取有效信息非常重要。 如何使了解政策入丝般顺滑每个人所处的状态和行为习惯有差异导致对方法的采用有不同的反馈效果，不过总的来说养成适合自己的获取信息的行为习惯很重要。具体可以是借助公众号、APP、网站、论坛、邮件订阅等等。适合自己生活习惯和行为习惯的途径就是好途径。 国家政策类这类政策太庞杂，首先需要理清思路，例如需要了解哪些行业的政策？哪些部门出具的政策？哪些机关制定的政策等？从高到低一次可以了解国家层面、省市级层面、城市层面、地区层面等。 网站 白鹿智库（http://WWW.bailuzhiku.com） 国家政策网站 本地政府网站 城市政府网站 公众号 长安街知事 学习小组 21世纪经济报道 外交部发言人办公室 中国政府网 人民日报 环球日报 新华社 国务院 APP 政策快报-国家政策通 金融政策类金融类政策和信息也是多种多样，并非每天都要刷一遍，看自己的节奏。金融政策信息获取的要点不在于看，而在于分析，例如一个政策出现后所造成的后果是什么？什么时间产生影响？产生哪些影响？自己如何应对等等。 华尔街见闻网站 金十数据 汇通网 各大金融公司公众号（四大行、华夏基金、太平洋保险、中信建投） 彭博社 创投信息类 IT桔子 国家今后大力发展的行业——————————20220410更新—————————————————————————————— 根据国家2021编撰的十四五规划以及各种分析类文章，现在简略整理如下： 高科技行业 人工智能 新材料 芯片 新能源 生物医疗 大数据 养老相关产业 养老：相亲、娱乐、保健器材、陪诊、老年教程（教玩手机等） 医药 健康：诊疗、陪护、社区健康等 保健品 实体行业相关 制造业 高端制造业 进出口行业 物流行业 其它行业 长租房：住房回归消费属性必然促进长租房市场，目前行业处于起步阶段 单身消费领域：老龄化和单身化都将会是今后的人口发展趋势，关于单身人群的消费市场开拓前景广阔，例如宠物相关行业等。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/8/11/nationalPolicy/"},{"title":"巨头布局的行业调研","text":"前言站在风口上，猪都能飞！虽然这句话有些夸张但很好的诠释了运气/趋势对个人的影响，问题的关键是何为风口？作为普通人如何发现风口？本文基于此疑问来做下简要调研，不做详细分析，对国内外的互联网行业巨头的发展趋势和发展规划做调研，仅供参考。 腾讯 面向用户—腾讯的根本，控制流量入口 通讯社交、数字内容、金融科技 面向企业—践行互联网+的策略，不做垂直领域，仅仅对垂直领域做基础服务和解决方案提供 腾讯广告、腾讯云、智慧零售、智慧医疗、智慧出行、智慧教育 创新科技—紧跟前沿科技 人工智能、多媒体、机器人、物联网、量子计算 阿里 电商服务 全球速卖通、1688、Lazada、淘宝、天猫、阿里妈妈、聚划算、一淘 娱乐服务 阿里影业、优酷、阿里体育、土豆、虾米、大麦、阿里游戏 金融服务 支付宝、网商银行 互联网技术型服务 友盟、阿里云、AliOS、yunos 通用型服务 UC、飞猪、钉钉、高德、阿里通信 大健康行业 阿里健康—目前，阿里健康开展的业务主要集中在医药电商及新零售、互联网医疗、消费医疗、智慧医疗等领域。简而言之相当于开了一家大医院，这家医院可以自己卖药也可要吸引外部资源入住提供卖药/看病服务，并积极利用大数据+AI来提供科技服务，利用互联网带来的便利性提供疫苗、挂号、体检等便民医疗服务。 字节 数字创作 头条、抖音、西瓜、火山、懂车帝、番茄小说、faceu、轻颜相机、皮皮虾、半次元、悟空问答、多闪 上海图虫—影像传播及服务平台，旗下拥有图虫社区、图虫创意、图虫Premium三个产品业务。 大健康行业 小荷健康、小荷医药、松果医疗、幺零贰四科技有限公司 教育服务业 gogokid英语、大力创新科技有限公司、好好学习、aikid 通用型服务 飞书 文娱行业 旗下多家游戏公司 金融行业 获取武汉合众易宝科技有限公司支付牌照 百度初略调研下来百度是以搜索作为发展的根本，以搜索积累的数据和技术提供企业服务作为重点，同时对待新技术新风口百度重点押注人工智能，最具代表性的成果是人工智能语音系统、智能驾驶等。而对待其他未来热点风口也均有所涉及采取广撒网的方式，例如教育、文娱、社区。 搜索服务 移动端搜索、网页搜索、与搜索相关的附加服务，例如视频、新闻、翻译、学术等。 企业服务 企业查询、营销策划、企业网站建设小程序开发平台、H5页面制作工具、百度律师、百度指数数据分析、百度脑图、如流办公、输入法 与企业营销相关的数据服务、沟通服务、翻译服务、推广、营销决策、api接入等，在我看来百度针对企业等服务重点放在了利用自身技术和数据积累实现企业商业营销的建设。 社区服务 涉及行业众多，几乎各种热点行业热点风口百度都有所涉及。例如百度阅读、宝宝知道、财经、支付、度小满理财 技术服务 AI硬件产品、DuerOS对话式人工智能系统、百度开发者中心（提供几乎包含百度所以技术产品的推广/接入）、云计算、云测试中心（提供软硬件各种技术栈的测试服务）、百度大脑 教育服务 在线教育、校园任务（百度社团赞助平台）、教育服务开放平台（以技术/解决方案的形式为教育服务商提供服务） 文娱服务 小视频、手游、端游、游戏开放平台、千千音乐 美团 京东拼多多网易滴滴小米bilibili旷视科技蚂蚁金服饿了么 苹果亚马逊alphabet谷歌微软脸书netflix 参考资料： [1]https://www.tencent.com/zh-cn/business.html [2]https://talent.alibaba.com/home/ [3]https://www.baidu.com/more/ var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/2/28/unicom_industry/"},{"title":"职业规划","text":"前言其实这篇文章是我2021年一月到四月一系列调研的结果。在即将奔三面对上有老下有小的困局前，我必须要行动起来了，首先要从职业发展上做好规划以更好的应对未来变化。 目前从事的互联网软件行业是青春饭行业，做技术很难、很少有人能够形成自己的壁垒，从调研来看技术最终都是要落地服务于业务，没有业务赋能的技术是无根之木，无源之水。明白了这一点就决定了我们一定要找到一个有发展前景和自己相对喜欢、想对好转型的行业。 经过调研我从各种潜力行业中选出了大健康行业。其实大健康行业也是非常广泛的一个称呼，其内部涵盖重多的垂直领域，例如制药、问诊、互联网医院、健康管理、慢性病管理、家庭医生、企业医生、药店连锁等等等，每一个垂直领域都大有可为。未来我国的人口老龄化是一个不可逆的过程，面对如此严峻的人口老龄化问题，相应的大健康行业必将迎来更大的发展。未来在大健康行业各垂直领域，谁能抢占先机，谁能提供更便捷更优质的服务，谁将笑到最后。 其实我个人更希望进入健康管理类、家庭医生类、企业医生类这种服务性质的大健康垂直领域。为什么呢？首先今后的互联网一定是服务性质的，其次服务行业更能与大健康相契合，最后服务行业更接近用户更容易形成自身的壁垒。 职业规划思考不做技术，要做能积累技术或业务的职业，要做能接触上下游产业链的职业。 以目前了解到的大健康可从事职业大体分为：技术、产品、项目、销售、运营、医护专业、业务负责人等，不一定全面但是能够展现当前的职业分类，无论是做哪一项首先是自己具备相应的能力可以适应岗位，其次是在本岗位内着重向大健康业务方向发展，最终目标是成为一个沟通产业上下游的专业业务人才。 养老行业/大健康行业的常青藤职业是什么？ 当前行业/工作选择后40-50岁会是什么状态？ 哪有什么一成不变，唯一不变的就是变化本身，心态要放平。人生如戏，规划的再好也抵不过命运，享受当下，关注未来。这个岁数还能有体面收入的职业以现在的角度整理如下： 公务员 投资人 企业高管 合伙人 自己创业当老板 40-50岁时的状态现在还没有办法想象，时代变化太快，那个时候眼界，人脉，资本（这三点很重要，年纪越大越重要）都会不一样或许选择更多，能做的只是现在的选择要选好，认真对待当前每一步。 自身发展规划内卷化、996、阶级固化等等等，这些新名词压的普通年轻人喘不过气，无数的人在焦炉中度过，在压迫中挣扎。很不幸我也是其中一员并且对此深恶痛绝，其实静下心来仔细想一想，现在所谓的努力、吃苦真的能实现阶级的提升吗？打工人可以翻身吗？或许可以，但是已经变得越来越困难，这是现实。问一问自己这是自己想要的吗？ 二十岁之前你想要的或许是学习 三十岁之前你想要的或许是努力奋斗 四十岁之前你想要的或许是陪伴家人 五十岁或许想要的是身体健康 …… 需求和欲望实在不断变化的，我们能做的是适应变化或者做的更好一点是提早为变化做准备。 经过一番思考，我明白了自己真正想要的东西： 健康：一切的基础，不多说 钱够用：不攀比，不追风，做好自己，钱够用，知足常乐 能抵御风险：能力、金钱等可以抵御未来未知的风险，例如买保险 时间自由：这点也是最难实现的或者说最难放下的，所谓的高收入比定是自身的牺牲，这个牺牲可以是身体、家庭但一定包含时间，打工人自不必多说，打工人的时间就是老板的，创业者在前期或者中期也是时间的努力，除非达到已成程度后可以实现时间自由。 结合自己想要的做个简要规划： 规划一：发展计划（积累人脉）:技术管理-&gt;产品专家-&gt;业务负责人-&gt;行业专家-&gt;企业高管 规划二：公务员+第二副业（投资人/up主等） 2021-工资不降，实现时间相对自由，进入大健康行业 2022-以考公务员为主+大健康发展为辅助 2023-以考公务员为主+转大健康产品岗位 2024-以考公务员为主+大健康产品发展为辅助 2025-安心进入大健康行业，制定下一个五年计划 个人缺点 大男子主义 对待小事情，自己不重视的事情过于粗狂，不细致 幽默很好，但是有时候伤到别人的幽默尽量忍住 惰性大 不够坚持 过于看重面子以致伤害自身利益 内心深处依然没有克服交际恐惧，有时过于木讷和腼腆 相对幼稚，不够成熟 总是自己给自己压力，要重视事情，但不要被事情压的无法喘气 心眼小 气量小 有时有点拖延症 有时过于讲义气，不够实际 记不住”痛“ 个人优点 诚信 责任 坦诚 正直 幽默 喜欢思考 逻辑思维能力强 喜欢规划 努力上进 积极乐观 喜欢将事情做好，尽量做到极致 做事趋向完美主义 做决定慎重 重感情讲义气 核心思想 做人做事要有魄力要豪迈不能小家子气，成大事者不拘小节。 志向要远大，要去创业，有房有车不是目标，而是实现目标过程中的产物 目标要与赚钱相结合，这是个现实的事情，我们学习、工作为了什么？归根揭底就是赚钱，给亲人创造好的生活，没有钱的目标都是扯淡 要不停的忙碌，不停的折腾，不停的赚钱（包括理财），生于忧患，死于安乐，顺势而为 唯一公平的只有时间 人脉资源非常重要，有时候会有意想不到的好处 注意： 1、“各行业或职业调研”+“人生规划”+本篇文章，三篇文章是关于职业和规划方面的精髓，可以反复研读 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/4/20/career_planning/"},{"title":"行业潜力调研","text":"机器还无法替代人类的行业，能够在生理或心里服务人类的行业，今后将迎来大的发展。 市场经济中的供需关系，同样适应在行业的发展中 互联网行业 大数据 大数据为我们看待世界提供了一种全新的方法，即决策行为将日益基于数据分析，而不是像过去更多凭借经验和直觉。 大数据的利用过程大体上需要以下步骤：数据收集、预处理、存储/管理、大数据处理、分析/挖掘、展示。 数据逐渐由资源变为资产，既然是资产那么在数据的收集/采集方面大企业大公司将具备先天优势，数据的诞生将依赖于硬件、软件、业务系统等，这种天然的护城河使得小企业难以涉足。大数据实际上是互联网发展至今所必然的产物，就像马云说的，今后大数据会成为互联网的土壤，只有基于大数据的云计算才更有价值，只有基于大数据的AI才更加智能。毫不夸张的说，大数据属于金字塔底座，属于根基。 大数据今后将通过数据挖掘来体现出价值，通过挖掘出的信息来更好的服务于各行各业，成为各个行业新的增长点。[1] 人工智能 人工智能从1956年提出来以后，发展阶段起起落落，自两千年的第二个十年开始人工智能在国内经历了大的发展，这主要得益于社会的发展、基础理论的突破、大数据/互联网/物联网/云计算等的全面进步，缺少任何一环，人工智能的发展也必将受较大影响。 人工智能目前乃至今后很长一段时间的发展将会是以“AI+”的形式向各垂直领域发展，借助人工智能，各行业将会极大提升销量、解放人力，将人类从传统的重复的工作中解放出来。目前在某一个具体领域例如机器人视觉、语音识别、语义处理等方面人工智能已经超越了人类，这个过程还将会持续很长时间，直至彻底应用落地，造福人类。 今后人工智能发展的目标必将是向通用人工智能发展，即人工智能可以在各个方面模仿人类，在智力、算力、自主学习能力乃至创造力等方面与人无异。这会是一个漫长的过程。但我的理解是这个由专用人工智能到通用人工智能的过度不会是直接的跨越，两者中间或许会经历许多小的里程碑阶段，例如专用人工智能-&gt;半人工AI-&gt;通用人工智能，整个过程的发展也必将需要人类社会整体的发展来推动。 关于人工智能的发展我们普通人应该如何看待？首先我们需要理解，人工智能不是来替代人类的而是来解放人类，让人从重复、繁琐、机械式的工作中解放处理，由机器人代替人类做这些枯燥的工作而人类更多的去从事创造性的工作，多思考。AI会消灭一些工作岗位同时也会创造一些工作岗位，所以不必恐慌。 人工智能时代我们作为普通人应该如何赶上这趟潮流？成为尖端科研人员这个固然好，但是此类工作一般要求较高，对学历，知识领域等要求高，而且目前一般由国家的科研院所和高校来实现。另一种是成为企业技术应用落地人员，此类人员对技术性、学历等要求也较高，但相比前者要好很多。还有与人工智能相关的其它工作机会例如商业推广、产品、涉及等辅助岗位。最后我觉得我们可以跳出这个竞争激烈的专业圈子不妨把眼光放到圈外，当人工智能发展到一定程度后必将促使大批人员转岗、一些传统行业的玩法将彻底改变、人们更多的转向创造类工作、人类将有更多服务型需求……这都将是机会 [2] [3] 工业互联网 工业互联网的网络体系将连接对象延伸到机器设备、工业产品和工业服务，可以实现人、机器、车间、企业等主体，以及设计、研发、生产、管理、服务等产业链各环节的全要素的泛在互联，以及数据的顺畅流通。 工业互联网平台体系的本质是通过工业互联网网络采集海量的工业数据，并提供数据存储、管理、呈现、分析、建模及应用开发环境，汇聚制造企业及第三方开发者，开发出覆盖产品全生命周期的业务及创新性应用，以提高资源优化配置的效率，最终推动制造业的高质量发展。 工业互联网平台体系又可以划分为多个功能层级，包括边缘层、IaaS层、PaaS层（平台层）和应用层。 工业互联网平台的本质就是使用数据+模型为各类制造企业提供全方位的智能服务。工业APP的本质是工业Know-How和知识经验的模型化、模块化、标准化和软件化，极大地便利于知识的应用和复用。 工业互联网目前处于起步阶段，各行业针对工业互联网的落地还处在摸索阶段，但可以肯定的是今后的工业互联网必将是政府引导逐渐减弱，各行业巨头垄断行业主体市场，微小型企业以提供工业互联网细分领域服务的形式生存。[4] 云计算 云计算实质上是通过互联网访问应用和服务，而这些应用或者服务通常不是运行在自己的服务器上，而是由第三方提供。它的目标是把一切都拿到网络上，云就是网络，网络就是计算机。云计算依靠强大的计算能力，使得成千上万的终端用户不担心所使用的计算技术和接入的方式等，都能够进行有效的依靠网络连接起来的硬件平台的计算能力来实施多种应用。云计算的新颖之处在于它几乎可以提供无限的廉价存储和计算能力。 云计算的发展与工业互联网、大数据等新型互联网技术及趋势的发展不谋而合，各种技术间相辅相成。新世纪以来云计算开始快速发展，直至目前仍然处于初期阶段，仅仅是在当前技术发展和社会发展的基础上以及当前社会预见力和需求上在Iaas、Paas、Saas等方面有所进展，但这远远不够。 可以预见的未来，我认为云计算讲彻底颠覆当今互联网，今后的各种互联网终端、移动互联网终端、网络应用、网络服务、人与人之间的沟通都将彻底改变。云计算必将是被各巨头垄断以提供基础及主流服务为核心，而互联网服务特别人ToB和ToC的服务需求将更加旺盛，以此必将催生出以提供个性化服务为主的中小型企业。作为普通人，紧跟技术发展潮流，专注某行业，专注互联网服务的深耕必将受益匪浅。 区块链 区块链(Blockchain)是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式。通俗理解，区块链是一种按照时间顺序将数据区块以顺序项链的方式组合成的一种链式数据结构，并以密码学方式保证的不可篡改和不可伪造的分布式账本。 区块链技术能否大规模应用的很重要原因之 一是：区块链技术成熟程度与技术标准化程度。目前，区块链在性能、安全、隐私保护、治理、跨链互操作等方面的技术仍不成熟，在一定程度上阻碍了区块链的广泛应用。未来一段时期内，技术优化仍然是重要的课题。区块链核心技术（如：共识机制、智能合约、跨链技术等为代表的核心技术）不断创新演进和优化，区块链的适用范围才能得到不断拓展。 以去中心化、数据可信、分布式协作为显著特点的区块链技术，将逐渐从金融行业的支付、贸易、保险等方面渗透到各行各业。 区块链作为多种技术的新型应用模式，意在去中心化，同其它新型技术一样，我猜想今后将形成“区块链+”的模式应用到各个行业，其本身并不能盈利也无法构建完美的技术壁垒，但它能够作为互联网新服务的辅助手段使互联网服务更加高效。 [5] 大健康相关行业 心理咨询：心理咨询师 只有在和平盛世，大健康产业及服务产业才会得到较好发展，投注大健康赌的是国运。根据近几年国家相继推出的政策以及社会响应，大健康行业目前正处于发展的初步阶段，特别是需要与互联网相关技术相关联的大健康新型服务模型，产业模式今后将迎来较大发展。 不过虽然前景广阔但对于行业外的人员想要进入该行业扔存在一下几点问题，第一是行业门槛高，需要一定的经验/技术，第二是细分领域过于广泛，想要全面发展的机会少，第三是创业门槛高。 [6] 热点服务行业 美容美体 美容美体行业范围广，具体涵盖美发、美甲、传统美容、医疗美容、教育培训、线上线下营销等。以目前的发展体量来看中国的渗透率2%远远低于欧美的10%，从国家发展的长远角度看至少有五倍的发展空间，可以肯定的是发展前景广阔。 但目前仍然存在一些诚待解决的问题，市场不规范、行业标准不健全、恶性竞争、单打独斗没有形成规模效应等，不过可以预见的是国家监管部门一直在加强监管，行业也越来越规范。今后的发展趋势必然是大鱼吃小鱼、技术性专业性强的淘汰弱的、大品牌淘汰小作坊等。 借助互联网+的产业升级势在必行。 化妆品、装饰品 化妆品行业规范成熟、巨头林立，已经形成较稳固的基本盘，且随着年轻人的加入已经女性经济和地位的提升，该行业将迎来较大发展。 装饰品涵盖了普通装饰品以及贵金属、珠宝装饰品，这些领域更是被巨头垄断，且行业较为规范、市场占有率变化不大。 保健品及配套服务行业 国内的保健品行业目前已经较为成熟，从95年安利进入中国以来近三十年的时间发展使得保健品行业经历了蓬勃发展期、稳定期、监管期，受19年权健事件影响国家对保健品企业的监管逐渐加大。保健品行业的上游为原料/生物制药类企业，中游为制造企业，下游则是销售企业，目前的销售途径仍然以线下人员销售的方式为主，其他的如门店、超市销售也占据不少份额，线上销售份额大约占用30%。 从长期发展趋势看，行业龙头企业将持续收益，中小企业的份额将被逐渐蚕食，线上销售逐渐占用主导地位，公民保健意识增强使得产业规模有望在2025年达到2500亿元。 我认为产品的制造与销售属于保健品传统经营范畴，今后的增长点不仅仅在于此，随着科技的发展、人民保健意识的增强、服务意识的提高，以保健产品为基础的养生服务类企业也将迎来较大发展，能够诞生不少创业机会。如何提供服务？如何产品落地？如何个性化的针对性定制服务将是今后的落脚点。 教育行业 早教：虽然家庭教育支出比重增加，近5年内0-6岁儿童预计将接近一亿，但长远来看由于计划生育及少生优生等理念的普及，新生儿童数量将逐年下降，长远来看行业并不乐观。 兴趣培训：同早教 职业教育：是个不错的行业，有巨头无寡头，线上教育成为新的增长点，能够诞生千亿企业，需要详细研究。具体看参考[6],[7] 技能培训：其实也属于职业教育的一种 远程在线教育：同职业教育 老年经济相关行业养老行业前景广阔，中国的老年人基数大，完全可以诞生千亿级别的养老企业。 养老行业：目前在国内处于发展的初期阶段，入局的基本是地产、保险、医药企业等有实力的参与者，解决的思路是为相对有钱的老年人提供服务，且一线城市优先。如何覆盖更广泛的群体？探索更先进的商业模式/盈利模式是关键。[9] 老年用品：老年用品种类繁多，涵盖消耗品、医疗器械、电子产品等，随着养老行业发展其必然也将迎来较大发展。可专做某一产品，也可以不生产产品，而是向小红书一样做老年产品方面的融合深耕。 家政服务：其实就是养老方式（家庭养老、社区养老、机构养老）中的细分服务方式。 金融/保险相关行业 互联网金融：互联网金融的本质是以互联网的科技优势来促进金融的高效发展，其一定会回归金融属性，一些灰色地带将随着国家监管法规的完善逐渐消失。小企业/创业企业难以立足，今后将是巨头垄断的时代，不过利用技术发展实现金融领域的突破，依然可以实现组织内部的造富。[10] 互联网保险：国内的保险行业目前仍然是个朝阳行业，因为从当前我国保险渗透率较低、人民保险意识逐步提高、生活水平逐步提高、行业更加规范等方面看该行业的发展潜力依然巨大。互联网保险的本质依然是提供保障，只不过需要借助互联网带来的技术优势去创造新的玩法，目的是改变传统保险行业。传统的保险行业最大的问题是供给侧与需求侧不匹配，我想买的和我买的不匹配、买保险需要专业知识、买卖过程复杂、担心上当受骗等等，这些问题急需新的方式去解决，但是目前互联网对保险的贡献多数还是停留在售卖上，例如支付宝、微信都可以买保险，但实际上并没有解决供给与需求的问题，支付宝上的一年期重疾险价格低廉，不明所以的用户以为捡到便宜了，实际上这种保险具有欺骗性，在长期续保和保障效果上存在较大隐患。我觉得互联网保险有点类似互联网金融，必定是由刚开始充满无数灰色地带的躺赢行业转为科技加身的保险行业，各项法规必然健全，人民得到较广泛的保险保障概念。利用互联网技术的先进性以及去中心化的特性建立一个透明、简便、丰富、智能的并涵盖保险销售、购买、知识普及、服务等相关综合性的保险运行机制是未来的方向。 参考资料 [1]http://c.biancheng.net/view/3500.html [2]http://www.qstheory.cn/dukan/qs/2019-02/16/c_1124114625.htm [3]https://zhuanlan.zhihu.com/p/53969617 [4]https://cloud.tencent.com/developer/article/1637669 [5]http://blockchain.people.com.cn/NMediaFile/2019/0905/MAIN201909050920000297932371328.pdf [6]https://www.sohu.com/a/362895105_800248 [7]https://news.pedaily.cn/202007/457352.shtml [8]https://zhuanlan.zhihu.com/p/31275235 [9]https://bg.qianzhan.com/report/detail/300/200928-cc767192.html [10]https://www.zhihu.com/question/342333524/answer/800258624 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/10/15/industryPotential/"},{"title":"风投投资行业调研","text":"前言风投机构作为当今商业嗅觉最灵敏的商业猎犬，他们的一些投资案例/行业值得我们研究。或许投行看中的行业也并非有绝对的发展前景但足以让我们普通人开拓视野。本文仅作初略调研，今后将会陆续更新，调研结果仅供参考。 深创投深创投主要投资成长期的企业，投资的重点行业为高端装备制造，其他的包括智能硬件、企业服务和医疗健康行业。 http://www.szvc.com.cn/main/ourBusiness/investmentBusiness/businessSurvey/index.shtml IDG资本投资重点行业为：企业服务、电子商务、文娱传媒、医疗健康、金融、本地生活 https://cn.idgcapital.com/about-us 红杉资本中国基金投资重点行业为：企业服务、电子商务、医疗健康、工业科技、消费品、现代服务业、科技、传媒 https://www.sequoiacap.com/china/companies/ 高瓴资本专注长期价值投资，发现行业内具有发展潜力的公司、创业团队、管理人才等。高瓴投资覆盖医疗健康、TMT、消费和企业服务等领域。 https://hillhouse.gllue.com/portal/gaolinghome 金沙江创投专注早期，致力于发掘企业服务、消费互联网、医疗领域里蕴藏的巨大投资机会。聚焦有潜力颠覆行业，主导市场的投资机会。重点投资企业服务、电子商务、教育、先进制造。 https://gsrventureschina.com/portfolio-3 达晨创投全阶段投资，重点投资行业：企业服务、先进制造、医疗健康、智能硬件、文娱传媒、电子商务 http://www.fortunevc.com/index/invest.html 参考资料： [1]https://www.itjuzi.com var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/3/13/vc_industry/"},{"title":"为什么35岁失业后会陷入人生低谷","text":"前言前一段时间在知乎偶然看到一个提问，问题大意是“为什么大多数人在35岁事业后容易陷入人生低谷”，看了网友的讨论回复后勾起了我的兴趣，细细想来确实是这么回事。我们经常会听到一些企业的招聘需求是35岁一下，那么以上的人怎么办？ 其实这都是一类问题，即年龄的逐步增长所产生的自身期望与现实之间的矛盾问题。 需要说明一下本人在写这篇文章时还不到三十岁更没有三十五岁，仅仅是此类问题勾起了我的兴趣特写下本文做粗浅讨论，肯定有思维逻辑缺陷的地方，望有幸看到的看客海涵。 三十岁在聊三十五岁之前我们可以首先聊一下三十岁。不知道大家有没有想过，为什么是35岁，为什么不是30、34、36、40岁呢？其实总的来说34，35，36差别不大，之所以选择三十五岁是因为它介于30与40的中间位置，具备代表性。所以我们可以看到三十岁是比较特殊的，需要仔细思考一下。 古人说三十而立，一个立字有众多的解读，被流传甚广的就是在三十岁一定要有车有房有老婆有孩子即归根结底是有钱。其实这是对这句话的误解，三十而立并不是物质上的追求，古人更多表达的是思想上的进步。哪些进步呢？比如知道自己想要什么、有自己完整的三观、有自己为人处世的标准、有自己的价值行为标准等。 三十岁并不是终点而恰恰是另一段征程的开始。 或许在三十岁这个阶段大多数人刚成家立业，刚刚进入另一段征程，大家鼓足了干劲对事业进步与家庭进步而奋斗，在这个年龄段的人是感受不到危机的，感受最多的是工作奋斗所带给自己的成就感、满足感。 四十岁三十岁到四十岁一晃十年就过去了，从刚开始对生活、事业的迷茫到确定了自己今后人生的发展方向、奋斗目标，整个过程下来得到的结果是确定的、稳定的未来。可以在这个阶段一眼看到自己的后半生，当一且都已知晓后心终反而不慌了，一切看淡，不服就干。 所以说，我认为四十岁是踏着三十五岁的煎熬历程走出来的，正是有前面的铺垫才能有四十岁的坦然。即使失业，面对这种小波浪也不容易撼动四十岁大叔沉稳的内询了。 三十五岁三十五岁是人生中煎熬时期的代表时间点，并不是说三十五岁一定焦虑，而是用三十五岁代表焦虑更贴切而已。 通过上面的三十岁、四十岁的分析我们不难发现，三十五岁正处在变与不变的交替节点，如果事业和家庭没有达到自己预期，眼看着四十将近，内心的焦虑与生活的压力会越发的凸显。在这种压力下本就被社会鞭打的脆弱内心更是雪上加霜，面对没有起色的事业、一天天长大的孩子、一天天年迈的父母、生活的琐碎、增长的年龄…这个时候如果在经历一些风浪，例如失业，那么读者们自己品品，是不是想从富士康楼上跳下来。 根本原因 期望太高 和平年代大多数人都是普通人，过好自己的日子就好了，不要整天想着改变世界，改变别人，能把自己管住，能把自己控制好就可以了。欲望既能助人也能害人，理性的审视自己，认识真实的自己。 规划不足 有目标、有行动这是实现自我价值的基础条件，这两点都做不到的话，你还是躺床上玩手机吧。 抗风险能力弱 工作不是全部，人类终生最求的其实是精神自由。这种自由太过于遥不可及，不过我们需要明白在这个最求的过程中要让自己努力生存下去，那么抗风险能力就非常重要了。工作之余发展下自己的爱好，或许这就是危机发生后的救命稻草。 缺乏一个乐观的心态 知足常乐，真正的自由是能拿得起放得下，我们之所以会被社会鞭策归根揭底是心态没有调整好，这一点不多言，懂的自然懂。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/8/13/35trough/"},{"title":"人生的意义","text":"好久没有写过所感所想了，大概是工作太忙也或许是自己太懒，今天刷着抖音顿感疲惫，我想这生活是多么的无趣，自己也是一个很无趣的人，这不是我想要的。 自己想要什么呢？每个人每个不同的阶段都会有不同的答案，这个就不讨论了，今天引发了对另一个重大哲学问题的思考，人生的意义是什么？ 这个问题太深奥太哲学，之前也看过类似的问题和其他人的回答，当时看了也就看了并没有让我醍醐灌顶。今天躺在床上静下心来思考这个问题，我现在觉得人生的意义可能就是为了体验吧。体验亲情、爱情、友情，经历高峰、低谷、平庸，尝试美食、旅游等各种享受，再经历过心酸、困苦与解脱等等，我觉得这就是人生的意义。 仔细静下心来回想下自己最近一段时间、最近一年或者最近几年的状态，做了什么得到了什么？ 工作日工作，很忙很忙，忙到忘了家人和朋友忙到忘记照顾好自己。 周末从繁忙的工作中逃离，脑子里想的都是解脱和逃避，一心只想睡觉、休息、玩手机、吃吃喝喝。 这种日子日复一日年复一年，从过完年的第一天就盼着下次放假，从周一的第一天就盼着周五，但是当你所期盼的到来时，最后你会发现自己并不能做什么，自己无能为力，时间也就是这么过去了。 这样的生活太没意思，我可以承认平庸，我们绝大多数人都是平凡的人，没有什么显赫的家世，没有腰缠万贯的老爹，只能靠自己来过自己的小日子。 但是这平庸并不影响自己去体验这人生啊，可以找一些有意义或者没有意义的新鲜事去做，不要管结果怎么，体验一遭就是收获。 人这一辈子工作、结婚、生子，为了工作烦恼，为了孩子上学烦恼，为了家庭琐事烦恼，为了钱烦恼，为了亲戚朋友的各种事情困扰，或许在现在这个社会，人生的主线就是工作+家庭，支线就是各种其它的琐事。 我认为这很正常，也是逃不掉且没有什么可抱怨的，但是一定要头脑清楚，不能浑浑噩噩，知道那些事情是我们可以去做的，做了后让自己的人生更丰富的。 人生在世，生不带来死不带去，多做些有趣的新鲜事就是人生的大事。 之前也尝试过制定一些目标，关于个人发展的，家庭发展的，很正确很不错，只是自己没坚持下来，今天正好思考人生意义这个事情我发现目标的制定可以，去做也没问题，但是不能太死板，太功利化，体验并不是任何事情都要有个好的收获，太刻板的目标反而会消磨自己的积极性，适当的定一些有享受标签的目标也是体验的一部分呀。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/3/26/life_mean/"},{"title":"使命宣言","text":"严格自律 个人最大的敌人就是自己，这个敌人无时无刻不再阻挡着你奔向你的目标，阻挡你实现野心。人本身就是一个复杂的综合体，有优秀的特征同样也有糟粕，恰恰就是这些糟粕与你为敌！具体哪些呢？或许是 懒惰、目标假大空、执行力低…，有目标的严格自律=成功。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/7/30/mission/"},{"title":"修身养性","text":"时间管理 多读书 改掉懒惰 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/7/30/cultivate/"},{"title":"如何为人处事","text":"为人处事是一门很深的学问，需要一个人一辈子去不断的体会、感悟、积累，本文也仅仅是记录自己的所感所想。 社会中人与人之间的关系是什么样的？人在这个世界中是一个独立的个体，有着自己的肉体、思想、行为、心态等等。这个世界中有形形色色的人，他们在阶级、地位、角色、品行等等都是不同的，那么我们从这里可以引申出当自身与不同的人相处/交往时一定是不同的“人格”，这个特殊的人格有着自己的行为、态度甚至表情、语言。 试想一下如果对待不同的人用相同的一种人格或者略有不同但却都包涵一些相同的缺点，那么势必会造成人与人之间相处的不融洽。 总的来说对待不同的人用不同的人格是必须的，通俗点讲就是“见人说人话见鬼说鬼话” 人与人之间的互动是什么样的？“见人说人话见鬼说鬼话”就是解决一切问题的良策吗？也不一定。 无论用什么样的人格我们都不能丢掉属于自身人格中最“纯粹美好”的东西。如果丢掉了，那么你也就不是你。 那么什么才是“纯粹美好”的东西？或者说如何发现？ 要回答这个问题首先要了解人与人之间是如何互动的。我们知道人是独立的个体，那么两个独立的个体进行互动是一定是借助某些形式。比如说语言、表情、动作、行为等，因此答案也显而易见。 即无论对待什么样的人我们都要：微笑、理性 你更倾向于同什么样的人交往？ 正直 真诚 热心 你想成为什么样的人？ 正直 真诚 乐观 耐心 好脾气 如何对待激怒你/怼你/讽刺你的人？每个人都是独立且独一无二的个体，这样才构成了这个缤纷的世界。当受到对方负能量时一定要做好自控，控制自己的情绪、不要被激怒、冷静分析处理。为什么要这样？怼回去不是更爽吗？因为别人的负能量而被激怒只能证明自己自控力差、软实力不足，不要因为别人的原因而让自己受损。既然改变不了别人那就调整自己，注意这里是“调整”而不是改变，别人的愚蠢行为是他们的问题并不是自己的问题，调整自己的心态和言行举止避免对抗，平和理性的将负能量击退才是上策。总结下来即如下几条： 尽量远离 微笑面对：当错sb来看待就好了，跟sb较真你就输了，哈哈。 心如止水 不要着急做决定，缓一缓冷静下来 理性思考解决问题（击退负能量） var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/10/29/person-and-event/"},{"title":"小感悟","text":"本文记录一些自身所感、所想、所见、所闻，以供自身警醒。 自己对别人有价值，别人才是你的人脉，反之不是。即自身的强大才能收获真正的友谊。 时刻关注自身成长，不要把时间浪费在一些琐事上吗。 除了身体健康没有什么是重要的，没有毕业为其他琐事烦恼。 一定要每天预留给自己独立思考的时间，不要被碎片化的娱乐而麻醉自己。 紧盯前方，走好自己的路，不要被其他人等外部因素所影响。 你看到的仅仅是别人想让你看到的，不要被影响，要有自己的思考。 好的外部环境对自身的影响很大，所谓近朱者赤，近墨者黑不是空言。 失败的经验可以借鉴，成功的经验没有办法直接学习，电梯理论可以很好的诠释。 知识改变命运，那么什么是知识呢？能够转化为具体的东西且为我所用的才是知识。 持续不断的阅读/学习，真的很有用 如何判断你自己到底喜不喜欢一件事？其实就是看你能不能接受这件事的所有负面。 时刻关注优先且不紧急的事情 努力提升自己，自己才是一切的本钱，包括赚钱。 不断提升自己的认知，不打无准备之仗，不做自己认知外的事情。 领导不培养不打压是常态，打压和培养才是很少见的，任何企业都是这样，要多接触多沟通，至少不能成为被讨厌的人。 无论要实现什么目标或者做什么事情，一定一定要找到自己的动力来源，否则你会找一万种理由不去完成目标 为人处事其实很简单，不需要复杂的理论来约束自己。心态乐观、为人真诚善良谦卑、做事积极主动稳重，这就是成功最本质的东西。 关系要常维护，找些合得来的人，不能被工作限制，工作可以成为你的维护助力。 赚钱很重要，找到赚钱与生活的平衡。既然现在工作一样辛苦为什么不努力拿到高薪？工作不是生活的全部，最终我们要回归生活。 赚钱很重要但是长线发展更重要，不要太注重短期的利益得失，扎根行业，维护好关系，跟对人很关键。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/2/20/catchphrase/"},{"title":"软实力","text":"前言硬实力拼的是真才实学，软实力讲究的是个人气场。讲话的方式方法、处理问题的方式方法、沟通、协调、对待不同人的不同处事技巧等等都属于软实力范畴。有些人之所以能成功仅靠硬实力是很难的，软实力在某些情况下是及其重要的，自己琢磨琢磨软实力的提升还是挺有意思的。 开会技巧 主题明确 节奏平缓 心态平稳 避免-吸气、停顿、咬字模糊、语气无力、重复 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/9/30/soft-power/"},{"title":"HTTP协议","text":"简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 特点 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 支持B/S及C/S模式。 HTTP的URLHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成： http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 从上面的URL可以看出，一个完整的URL包括以下几部分： 1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符 2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用 3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 URI与URL的区别URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。 Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的 URI一般由三部组成： ①访问资源的命名机制 ②存放资源的主机名 ③资源自身的名称，由路径表示，着重强调于资源。 URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成： ①协议(或称为服务方式) ②存有该资源的主机IP地址(有时也包括端口号) ③主机资源的具体地址。如目录和文件名等 URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。 URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。 在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。 在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。 Request请求消息客户端发送一个HTTP请求到服务器的请求消息包括以下格式： 请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。 Get请求例子，使用Charles抓取的request： 1234567GET /562f25980001b1b106000338.jpg HTTP/1.1Host img.mukewang.comUser-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept image/webp,image/*,*/*;q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本. GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息 从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等 第三部分：空行，请求头部后面的空行是必须的 即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。 这个例子的请求数据为空。 POST请求例子，使用Charles抓取的request： 12345678POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley 第一部分：请求行，第一行明了是post请求，以及http1.1版本。 第二部分：请求头部，第二行至第六行。 第三部分：空行，第七行的空行。 第四部分：请求数据，第八行。 Response响应消息一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。 HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 12345678910HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;!--body goes here--&gt;&lt;/body&gt;&lt;/html&gt; 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的** 第四部分：响应正文，服务器返回给客户端的文本信息。**空行后面的html部分为响应正文。 HTTP状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见状态码： 1234567200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 HTTP工作原理HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。以下是 HTTP 请求/响应的步骤： 1、客户端连接到Web服务器 一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。 2、发送HTTP请求 通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 3、服务器接受请求并返回HTTP响应 Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 4、释放连接TCP连接 若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 5、客户端浏览器解析HTML内容 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接); 3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为TCP 三次握手的第三个报文的数据发送给服务器; 4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器; 5、释放TCP连接; 6、浏览器将该 html 文本并显示内容; GET与POST请求的区别GET请求 12345GET /books/?sex=man&amp;name=Professional HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive 注意最后一行是空行 POST请求 123456789POST / HTTP/1.1Host: www.wrox.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley 1、GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；POST提交：把提交的数据放置在是HTTP包的包体中。上文示例中红色字体标明的就是实际的传输数据 2、传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。而在实际开发中存在的限制主要有： GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。 因此对于GET提交时，传输数据就会受到URL长度的 限制。 POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 3、安全性:POST的安全性要比GET的安全性高。 4、Http get,post,soap协议都是在http上运行的 Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息. 参考资料: [1]https://www.cnblogs.com/ranyonsue/p/5984001.html [2]http://blog.csdn.net/ergouge/article/details/8185219 [3]http://www.runoob.com/http/http-status-codes.html var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/17/http/"},{"title":"TCP/IP协议简介","text":"简介TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。电脑有了这些，就好像学会了外语一样，就可以和其他的计算机终端做自由的交流了。 协议分层 TCP/IP协议族按照层次由上到下，层层包装。 应用层: 提供应用程序间的服务通信。文件传输访问FTP使用FTP协议来提供网络内机器间的文件拷贝功能。 传输层: 提供应用程序间的数据通信。 网络层 ： 负责相邻计算机之间的通信。其功能包括三方面。 一、处理来自传输层的分组发送请求，收到请求后，将分组装入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口。 二、处理输入数据报：首先检查其合法性，然后进行寻径–假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。 三、处理路径、流控、拥塞等问题。 网络接口层： 这是TCP/IP软件的最低层，负责接收IP数据报并通过网络发送之，或者从网络上接收物理帧，抽出IP数据报，交给IP层。 IP协议 IP 用于计算机之间的通信。 IP 是无连接的通信协议。 它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。 IP 负责将每个包路由至它的目的地。 CP/IP 使用 32 个比特来编址。一个计算机字节是 8 比特。所以 TCP/IP 使用了 4 个字节。 一个计算机字节可以包含 256 个不同的值：00000000、00000001、00000010、00000011、00000100、00000101、00000110、00000111、00001000 ……. 直到 11111111。 参考资料: [1]https://www.jianshu.com/p/ef892323e68f var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/17/tcpip/"},{"title":"TCP协议","text":"TCP报文格式TCP/IP的简介可参考本站”TCP-IP协议简介” 16位源端口号：16位的源端口中包含初始化通信的端口。源端口和源IP地址的作用是标识报文的返回地址。 16位目的端口号：16位的目的端口域定义传输的目的。这个端口指明报文接收计算机上的应用程序地址接口。 32位序号：32位的序列号由接收端计算机使用，重新分段的报文成最初形式。当SYN出现，序列码实际上是初始序列码（Initial Sequence Number，ISN），而第一个数据字节是ISN+1。这个序列号（序列码）可用来补偿传输中的不一致。 32位确认序号：32位的序列号由接收端计算机使用，重组分段的报文成最初形式。如果设置了ACK控制位，这个值表示一个准备接收的包的序列码。 4位首部长度：4位包括TCP头大小，指示何处数据开始。 保留（6位）：6位值域，这些位必须是0。为了将来定义新的用途而保留。 标志：6位标志域。表示为：紧急标志、有意义的应答标志、推、重置连接标志、同步序列号标志、完成发送数据标志。按照顺序排列是：URG、ACK、PSH、RST、SYN、FIN。 16位窗口大小：用来表示想收到的每个TCP数据段的大小。TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16字节字段，因而窗口大小最大为65535字节。 16位校验和：16位TCP头。源机器基于数据内容计算一个数值，收信息机要与源机器数值 结果完全一样，从而证明数据的有效性。检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。 16位紧急指针：指向后面是优先数据的字节，在URG标志设置了时才有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段。 选项：长度不定，但长度必须为1个字节。如果没有选项就表示这个1字节的域等于0。 数据：该TCP协议包负载的数据。 标志域简介 URG：紧急标志。紧急标志为”1”表明该位有效。 ACK：确认标志。表明确认编号栏有效。大多数情况下该标志位是置位的。TCP报头内的确认编号栏内包含的确认编号（w+1）为下一个预期的序列编号，同时提示远端系统已经成功接收所有数据。 PSH：推标志。该标志置位时，接收端不将该数据进行队列处理，而是尽可能快地将数据转由应用处理。在处理Telnet或rlogin等交互模式的连接时，该标志总是置位的。 RST：复位标志。用于复位相应的TCP连接。 SYN：同步标志。表明同步序列编号栏有效。该标志仅在三次握手建立TCP连接时有效。它提示TCP连接的服务端检查序列编号，该序列编号为TCP连接初始端（一般是客户端）的初始序列编号。在这里，可以把TCP序列编号看作是一个范围从0到4，294，967，295的32位计数器。通过TCP连接交换的数据中每一个字节都经过序列编号。在TCP报头中的序列编号栏包括了TCP分段中第一个字节的序列编号。 FIN：结束标志。 TCP三次握手所谓三次握手就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示： 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 SYN攻击： 在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行： 1#netstat -nap | grep SYN_RECV TCP四次握手所谓四次挥手就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示： 由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。 （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？ 这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 原因有二： 一、保证TCP协议的全双工连接能够可靠关闭 二、保证这次连接的重复数据段从网络中消失 先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。 再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。 参考资料: [1]https://www.jianshu.com/p/ef892323e68f var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/17/tcp/"},{"title":"Gremlin常用命令","text":"本文仅针对Gremlin进行常用命令介绍 1234567891011121314151617181920212223242526272829303132333435#连接远程服务#:remote为远程服务连接命令#remote.yaml文件内进行配置远程服务地址等信息#(服务重启后需要重新连接):remote connect tinkerpop.server conf/remote.yaml#脚本远程执行命令#执行该命令后代表今后在gremlin-console执行的命令脚本都将直接在server生效，否则无法生效:remote console#通过命令生成图实例，依照指定路径配置文件进行生成实例，实例名称可自由设定graph = JanusGraphFactory.open('conf/janusgraph-local-inmemory.properties')#加载数据：graph为图实例，图实例可以在server启动时通过指定的yaml文件中的graphs配置进行生成，也可以通过命令进行生成GraphOfTheGodsFactory.loadWithoutMixedIndex(graph, true)#输出所有顶点graph.traversal().V()#通过:&gt;可以直接将命令submit到server无需预先执行:remote console命令，不过每一个执行的命令斗都需要携带:&gt;命令#获取便利对象g，这个g为默认的便利对象无法设定其他的名称g = graph.traversal()#添加顶点g.addV(&quot;test1&quot;).property(&quot;name&quot;,&quot;name1&quot;).property(&quot;age&quot;,333).property(&quot;height&quot;,180)ggraph.traversal().addV(&quot;test2&quot;).property(&quot;name&quot;,&quot;name2&quot;).property(&quot;age&quot;,333).property(&quot;height&quot;,180)gggraph.traversal().addV(&quot;test3&quot;).property(&quot;name&quot;,&quot;name3&quot;).property(&quot;age&quot;,333).property(&quot;height&quot;,180)#添加边g.addE(&quot;testE1&quot;).property(&quot;length&quot;,123).from(g.V(8208)).to(g.V(20656))ggraph.traversal().addE(&quot;testE2&quot;).property(&quot;length&quot;,123).from(g.V(8208)).to(g.V(20656))gggraph.traversal().addE(&quot;testE3&quot;).property(&quot;length&quot;,123).from(g.V(12528)).to(g.V(4152)) var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/4/29/gremlin-line/"},{"title":"SQL优化","text":"基本概念 基数：某个列唯一键（Distinct_Keys）的数量叫作基数。基数的高低影响列的数据分布。 当某个列基数很低，该列数据分布就会不均衡。数据分布不均衡会导致在查询该列的时候容易走全表扫描。一般查询结果占总数据的5%以上就会走全表扫描。 选择性：基数与总行数的比值再乘以100%就是某个列的选择性。某列选择性大于20%的时候证明数据分布相对均衡，适合建立索引。 回表：当对一个列创建索引之后，索引会包含该列的键值以及键值对应行所在的rowid。通过索引中记录的rowid访问表中的数据就叫回表。回表一般是单块读，回表次数太多会严重影响SQL性能，如果回表次数太多，就不应该走索引扫描了，应该直接走全表扫描。 优化目标1、减少IO次数 高IO产生的原因很多，例如未命中索引、使用范围查询、频繁回表等都会产生高IO。举例来说，如果在一棵高度为3的辅助索引树种查找数据，那需要对这个辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问才能得到最终的一个数据页。 2、降低CPU计算 order by，group by，distinct都需要消耗大量CPU。 优化方法-表设计 静态表：所有表字段都有固定长度。优点容易缓存，容易修复，查询速度有优势，缺点需要占用更多的磁盘空间。 动态表：表存在varchar、blob、text等不定长字段。优点占用磁盘空间少，缺点容易产生磁盘碎片，影响数据库性能和查询性能。 压缩表：只读，使用很少的空间，用myisampack工具创建，每条记录分开压缩，所以不能同时访问，可以压缩静态表和动态表。 优化方法-where优化 避免null判断 ！=，&lt;,&gt;尽量避免使用，否则引擎则会进行全表扫描 避免在where中使用in、not in 避免使用局部变量 避免使用表达式 避免对字段进行函数操作 优化方法-索引设计 单列索引：例如ALTER TABLE people ADD INDEX lname (lname);仅对表中的一个字段设置索引，如果查询条件where中包含索引字段则优先使用索引字段结果集1，在结果集1的基础上回表查询其他where条件字段。 多列索引：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。 组合索引：例如以(lname,fname,age)为组合建立的索引。组合索引的好处是使查询条件或者select查询字段尽可能多的涵盖在索引数据中，通过索引直接快速拿到需要的数据而不需要回表。使用组合索引时一定要注意要符合“最左前缀”原则。 最左前缀原则 组合索引的第一个字段必须出现在查询组句中，这个索引才会被用到。 果有一个组合索引(col_a,col_b,col_c)，下面的情况都会用到这个索引： 1234col_a = ``&quot;some value&quot;``;col_a = ``&quot;some value&quot;` `and col_b = ``&quot;some value&quot;``;col_a = ``&quot;some value&quot;` `and col_b = ``&quot;some value&quot;` `and col_c = ``&quot;some value&quot;``;col_b = ``&quot;some value&quot;` `and col_a = ``&quot;some value&quot;` `and col_c = ``&quot;some value&quot;``; 对于最后一条语句，mysql会自动优化成第三条的样子 下面的情况就不会用到索引： 12col_b = ``&quot;aaaaaa&quot;``;col_b = ``&quot;aaaa&quot;` `and col_c = ``&quot;cccccc&quot;``; 索引缺点 降低更新表的速度 占用额外磁盘空间 索引使用注意事项 索引不会包含有NULL值的列：只要列中包含有NULL值都将不会被包含在索引中，组合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的 使用短索引：对串列进行索引，如果在前一定长度的字符内多数值是唯一的，可以指定一个前缀长度。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。 索引列排序：MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。 索引失效场景 前导模糊查询不能利用索引(like ‘%XX’或者like ‘%XX%’) 组合索引（a,b,c）在使用时where条件中必须包括a,而无所谓a在where中的顺序 特殊关联条件如：or、in、not in 避免在索引中判断null值（索引无法存储null值，不利于排序） 避免函数运算 substring(name,1,3)=’abc’ 避免表达式操作 如where num/2=100 优化方法-其他方面 IN与EXIST的区别：区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况 复杂多表尽量少用join 尽量用join代替子查询 尽量少用排序 尽量少用OR 避免使用 select *，查询字段要精确 尽量用union all代替union：差异主要是前者需要将两个(或者多个)结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的 CPU 运算，加大资源消耗及延迟 避免查询字段类型转换 避免频繁操作临时表 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/5/18/sql-optimize/"},{"title":"janusGraph图数据库入门","text":"简介JanusGraph是一款分布式、开源、可伸缩的图数据库。其伸缩性适用于千亿级图存储和查询，并能够将顶点、边分布式存储在多个集群中。 JanusGraph隶属于Linux基金，由其负责开发和维护，参与者包括谷歌、IBM、亚马逊等。 JanusGraph重点关注紧凑的图形序列化、丰富的图形数据建模和高效的查询执行。在批量图处理和图分析方面借助Hadoop实现并对客户端连接、数据索引查询、数据持久化等提供健壮性接口。JanusGraph的模块化架构允许它与广泛的存储、索引和客户端技术进行互操作。 进一步的详细介绍可参考官网[1] 架构 图分析支持（OLAP）：基于Tinkerpop开发，支持以Gremlin图语言为基础的图数据分析 图事务支持（OLTP）：基于Tinkerpop开发，支持以Gremlin图语言为基础的图事务管理 API管理：对外提供完备的API支持和管理 存储后端：用于图数据存储 索引后端：用于图数据搜索 存储后端支持： Apache Cassandra Apache HBase Oracle Berkeley DB Java Edition 索引后端支持： Elasticsearch Apache Solr Apache Lucene JanusGraph目前支持两种接入方式： 嵌入式：JanusGraph服务可以与应用程序在相同的JVM中，所有的缓存、事务等均在此JVM中，存储后端和索引后端可以连接本地或远程。 命令试：JanusGraph服务可以单独部署，部署成功后会长期运行JanusGraph服务进行，外部应用可以借助Gremlin命令进行图数据库实例获取与使用。 基础使用本事例仅仅以单机的形式本地部署JanusGraph服务，使用内存作为存储后端，暂无索引后端，采用gremlin-visualizer/graphexp进行可视化展示。以上配置可以方便初入者更快的了解。 服务端开启 首先从官网gitpub下载release程序包https://github.com/JanusGraph/janusgraph/releases 然后执行bin文件夹中的gremlin-server.sh文件（也可以执行bat类型文件，不同操作系统如何执行sh/bat自行百度） 12#启动默认配置-hostname：127.0.0.1，链接：http://127.0.0.1，端口：8182，不进行图实例加载bin/gremlin-server.sh 1234#根据自定义配置文件yaml启动#可以自由配置hostname、链接、端口#yaml中可以配置多种图实例graphs（properties文件），启动后将自动进行图实例加载bin/gremlin-server.sh ./conf/gremlin-server/socket-gremlin-server.yaml Gremlin-console开启 console作为Gremlin命令的执行客户端需要启动，在启动后可以单独执行Gremlin命令也可以将执行命令提交到已经链接的server服务端生效。 12345678910111213#启动console服务bin/gremlin.sh#连接远程服务#:remote为远程服务连接命令#remote.yaml文件内进行配置远程服务地址等信息#(服务重启后需要重新连接):remote connect tinkerpop.server conf/remote.yaml#脚本远程执行命令#执行该命令后代表今后在gremlin-console执行的命令脚本都将直接在server生效，否则无法生效:remote console 测试数据加载 加载内置的测试图数据 12345#通过命令生成图实例，依照指定路径配置文件进行生成实例，实例名称可自由设定graph = JanusGraphFactory.open('conf/janusgraph-local-inmemory.properties')#加载数据：graph为图实例，图实例可以在server启动时通过指定的yaml文件中的graphs配置进行生成，也可以通过命令进行生成GraphOfTheGodsFactory.loadWithoutMixedIndex(graph, true) 可视化客户端启动 以gremlin-visualizer为例（其他可视化工具大同小异）具体操作如下： 首先官网下载gremlin-visualizerhttps://github.com/prabushitha/gremlin-visualizer 123456789101112#克隆项目git clone https://github.com/prabushitha/gremlin-visualizer.git#可视化插件依赖nodejs因此需要先自行安装nodejs和npm#进入项目文件夹执行npm命令npm install#进入项目文件夹执行npm启动命令npm start#启动成功后可访问如下地址查看http://localhost:3000 图查询命令 在可视化工具中输入查询命令即可，或者在console中输入查询命令可输出结构化原始数据 123#输出所有顶点graph.traversal().V() 基本概念讲解 OLTP：on-line transaction processing联机事务处理，用在图数据库 OLAP：On-Line Analytical Processing联机分析处理，用在图数据分析 图：相当于mqsl中的数据库 图数据库中没有表的概念，同一个图中无关联的子图可以理解为表 参考资料： [1]https://janusgraph.org var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/4/29/janusGraph-brief/"},{"title":"janusGraph图数据库进阶","text":"本文针对在janusGraph使用过程中遇到的使用问题、操作问题、架构问题等进行讨论。 如何进行多图管理？janusGraph支持多图管理，依赖properties文件进行配置来实现，如下图conf中预设的众多配置文件。 在启动服务时加载多图 在“janusGraph图数据库入门”中介绍了如何指定yaml配置文件来启动server服务，部分内容如下： 123456789host: 0.0.0.0port: 8182scriptEvaluationTimeout: 30000channelizer: org.apache.tinkerpop.gremlin.server.channel.WebSocketChannelizergraphs: { graph: conf/janusgraph-inmemory.properties, ggraph: conf/janusgraph-local-inmemory.properties, gggraph: conf/janusgraph-local2-inmemory.properties} 其中graphs集合就是我们预先配置的图实例，每一个图实例对应唯一的一个配置文件。 不同的存储后端可以创建多图，相同的存储后端也可以创建多个图，加载多个properties配置即可，需要注意的是如果同样的存储后端则需要指定不同的hostname，不同的host代表不同的图，如果多个properties配置相同的hostname，即使创建了多图，实际上多图也是指向相同的一个图实例。 在启动服务后加载多图 如果在启动服务配置中没有进行图实例配置，我们也可以使用gremlin命令获取实例。 1234#通过命令生成图实例，依照指定路径配置文件进行生成实例，实例名称可自由设定graph = JanusGraphFactory.open('conf/janusgraph-inmemory.properties')ggraph = JanusGraphFactory.open('conf/janusgraph-local-inmemory.properties')gggraph = JanusGraphFactory.open('conf/janusgraph-local2-inmemory.properties') 1234567#可以在console中输出图实例看一下gremlin&gt; graph==&gt;standardjanusgraph[inmemory:[127.0.0.1]]gremlin&gt; ggraph==&gt;standardjanusgraph[inmemory:[localhost]]gremlin&gt; gggraph==&gt;standardjanusgraph[inmemory:[localhost2]] 顶点/边的数据结构 预存属性：id，lable。其中id在创建顶点和边时无需指定将自动生成，janusgraph不支持手动指定id。lable相当于顶点/边的名称 自定义属性：可以通过property方法进行自定义属性添加，属性类型默认支持字符串/整型，其他特殊类型需要进行配置。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/4/29/janusGraph-adv/"},{"title":"mysql数据库索引","text":"什么是索引？索引是对数据库表中一列或多列的值进行排序的一种存储结构。 它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。 为什么会诞生索引？使用索引检索数据会更加快，就好比使用字典中的目录去查询文字一样。 索引的类型以mysql为例 普通索引：目的仅仅为了加速查询，没有限制，值可以是null，值可以重复 唯一索引：加速查询（普通索引） + 列值唯一（可以有null） 主键索引：加速查询（普通索引） + 列值唯一（不可以有null）+ 表中只有一个 组合索引：指在多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。 全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配。不过目前只有char、varchar，text 列上可以创建全文索引。 空间索引：是对空间数据类型的字段建立的索引 索引的优缺点优点是加速查询，缺点是额外占用磁盘空间，数据变动后索引的维护与更新也会更加消耗资源。 聚集索引与辅助索引在数据库中，B+树的高度一般都在24层，这也就是说查找某一个键值的行记录时最多只需要2到4次IO，这倒不错。因为当前一般的机械硬盘每秒至少可以做100次IO，24次的IO意味着查询时间只需要0.02~0.04秒。 数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index）， 聚集索引与辅助索引相同的是：不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。 聚集索引与辅助索引不同的是：叶子结点存放的是否是一整行的信息 聚集索引 #InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放。 聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。 #如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。 #如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。 #由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。 辅助索引 #辅助索引的叶子节点不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（bookmark）。该书签用来告诉InnoDB存储引擎去哪里可以找到与索引相对应的行数据。 #InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键 #每张表上可以有多个辅助索引，但只能有一个聚集索引 #举例来说，如果在一棵高度为3的辅助索引树种查找数据，那需要对这个辅助索引树遍历3次找到指定主键，如果聚集索引树的高度同样为3，那么还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在的页，因此一共需要6次逻辑IO访问才能得到最终的一个数据页。 索引的数据结构 hash表：具体结构是hash表+链表的组合结构。hash表存储hash值和指向链表的指针，链表存储索引数据。优点是只需要一次hash计算就可以快速找到值，缺点是不适合排序、范围查询、模糊查询以及容易出现hash冲突。 平衡二叉树：具体结构是数据（关键字）+指向两个子节点的指针。每一个节点都存放数据且最多有两个子节点，如果数据量大会导致层级很高，查询叶子节点效率低。且单个节点存储数据少，每次节点进行比较的时候都需要进行一次I/O获取节点的数据（因为两个节点最多两路查找），而在操作系统中，I/O的成本是很高的。 B树（平衡多路查找树）：具体结构是数据（关键字）+指向多个子节点的指针 关键子用于保存数据 查找路径不止两个即不止两个子节点 有 k 个子节点的非叶子节点拥有 k − 1 个关键字 所有的叶子结点都在同一层 简单来理解就是每一层节点可以拥有的子节点个数增加了，而且每一个节点携带的关键字也增加了（这样才能对应多个子节点）。例如上面第二层的第一个节点，P1指针指向的子节点都是是比 8 小的数据，P2指向的则是大于8小于12的。 优点： 每层的节点数增加了，树高也大大减少，这就大大减少了I/O次数 读取一个节点的时候可以一次性读取大量关键字数据 可以充分利用了磁盘块读写的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来） 缺点： 节点既要存索引信息又要存其对应的数据，如果数据大且当树的体量很大时，每次读到内存中的树的信息就会不太够。 B树相对二叉树虽然提高了磁盘IO性能，但并没有解决遍历元素效率低下的问题。 B+树：具体结构是关键字+指向多个子节点的指针，只有叶子结点保存数据。 有 k 个子节点的非叶子节点拥有 k 个关键字 关键字不保存数据，只是用来索引（这样非叶子节点的所占的内存空间就变小了，读到内存中的索引信息就会更多一些，相当于减少了磁盘IO次数） 数据都是存在叶子节点，这样保证了相近的数据都能存在同一块数据块里。另外也使得B+树的查询次数更稳定，每次查询次数都是相同的，需要查询到叶子节点 叶子节点的指针指向下一个数据对应的叶子节点。因此B+树具备了天然排序功能，在排序和范围查找的时候更方便。 B+树可以方便地做全表搜索，只需要从第一个叶子节点顺序往后面扫描即可，而B树则需要做树的遍历。 参考资料：https://www.cnblogs.com/Eva-J/articles/10126413.html var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/5/mysql-index/"},{"title":"事务的隔离级别","text":"事物并发产生的问题 脏读 事物A读取了事物B已经修改但未提交的数据。如果事物B发生回滚则脏读出现。 不可重复读 事物A第一次读取后事物B进行了修改并提交，当事物A再次读取时发现两次读取不一致，这就是不可重复读。侧重的是数据的修改。 幻读 事物A第一次读取并修改了一批数据但未提交，并行的事物B插入或者删除了部分数据并提交，当事物A提交数据时发现数据数量或内容不对，这就是幻读。侧重的是数据的插入或删除。 事物的四种隔离级别 read uncommitted读未提交 读写可并行，可以读到未提交数据，将导致脏读。 读读可并行，读写可并行，写写不可并行。 read committed读已提交 只能读到提交的数据，排除了脏读但可能造成不可重复读。 读读可并行，读写可并行，写写不可并行。 repeatable read可重复读 读数据时对读出的数据加锁防止写操作，避免了脏读和不可重复读但可能造成幻读。mysql默认的方式。 读读可并行，读写不可并行，写写不可并行。 serlalizable可串行化 所有事物均排队串行执行，级别最高，效率最低。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/2/transaction-isolation/"},{"title":"图数据库应用","text":"回想一下关系型数据库或者其他常见的nosql数据库是如何在项目中使用的？简单的应用逻辑是：安装数据库-&gt;项目中加载数据库驱动-&gt;操作数据库/创建数据库操作SDK应用提供对外服务等。 图数据库的使用同样遵循这个应用逻辑，但是通常来讲nosql数据库都有各自的操作命令，直接在应用程序中通过操作命令进行业务实现太过于繁琐，然而构建数据库的SDK程序以提供对外服务的方式操作nosql数据库最常用。 图数据库应用可能的实施环节 业务分析 分析业务现状与期望，划定业务范围，确定对图数据库的技术期望。例如高可用性、强一致性、高吞吐量、支持分布式、可动态伸缩、开源、社区活跃等等。 图数据库选型 根据自身业务特点进行选型 图数据库应用平台设计 本阶段需要考虑的是以何种架构来提供图数据库服务。例如“SDK应用+图数据库”对外提供服务的方式或者“数据生产+数据存储+数据应用+支持平台”等的平台设计思路。 图数据模型设计 将业务逻辑转换为图数据库关系 图数据库应用 基于定义的图数据模型以及图数据平台提供的对外开放能力来设计业务应用场景。 图数据模型设计在构建传统的关系型数据库时我们首先要做的是尽可能的根据数据库设计范式并结合业务场景来定义数据库表模型，模型一旦确定就意味着业务场景的定型。 图数据库的构建没有表的概念，也没有明确的模型制定规则，但是仍然有模型的概念。模型的制定必须根据业务情形梳理出两种数据类型，即“实体（节点）类型”、“关系（边）类型”。一个简单的小例子如下： 五类实体：class, interface,method,field 七类关系：如上图所示 [1]美团案例https://blog.csdn.net/weixin_44324814/article/details/112861464?utm_term=业务数据图数据库&amp;utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-1-112861464&amp;spm=3001.4430 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/6/18/graph-used/"},{"title":"图数据库简介","text":"什么是图数据库在计算机科学中，图数据库（英语：graph database，GDB）是一个使用图结构、边和属性来表示和存储数据。图数据库是一种非关系型数据库，以解决当前关系行数据库的局限性。 那么什么是图呢？图是由节点和向量组成的关联结构，如下图所示： 图数据模型有三种： 超图：边的起始节点有多个，指向节点有多个 属性图：节点之间由边唯一指向，节点间为一对一关系，节点与边都可以设置属性、标签等 三元组（RDF）：用于描述关联关系的语意表达，例如“Tom认识mark”，三元组就是利用“主语”、“谓语”、“宾语”的形式来表达关联关系。三元组的表示准信W3C标准 图数据库的优点 使用图（或者网）的方式来表达现实世界的关系很直接、自然，易于建模 图数据库可以很高效的插入大量数据 图数据库可以很高效的查询关联数据 图数据库提供了针对图检索的查询语言，比如Gremlin、Cypher等图数据库语言 图数据库提供了专业的分析算法、工具，比如ShortestPath、PageRank、PersonalRank、Louvain等等 图数据库的可能用途 知识图谱 图数据库的关联特性天生的适合知识图谱的建设，在存储方面图数据库提供了灵活的设计模式，支持实时存储。在查询方面图数据库提供了关系行数据库无法提供的高效关联查询。 金融领域 通过建立账户（客户）的关系图，根据其社会关系、交易情况，分析客户的还款能力、还款意愿、抗风险能力等，提升金融行业小贷授信、信贷审核、贷后追踪等风控能力，并根据资金交易图谱实现反洗钱、反欺诈等系统。 社交领域 人与人在线上和线下的联系天然形成了一张图，汇集海量的关系数据后，能够做社区发现、舆论追踪、用户推荐等丰富的应用场景。 政企领域 在物联网时代，图模型通过构人、位置、事件、物的关系图，实现智能交通、道路规划、平安城市、钓鱼网站识别，惠及民生。 工业领域 图模型强大的表达力对复杂且快速变化的事物很强适性，在工业领域来管理复杂且快速变化的库存、供应链关系，并推动创新，提供智能制造的解决方案。 医疗领域 根据病人的病情特征、电子病历、历史用药、药物成分、临床试验、保险情况等多维数据绘制以用户为中心的图数据，从而实现智能诊断，提高诊断效率和准确性，共享医疗资源。 零售领域 通过整合用户浏览及购买数据，分析“哪些用户购买了该商品”以及“购买A商品的用户也购买了B商品”等多维数据，实现商品智能推荐，给买家更好的购物体验。 电信领域 人与人的通信是一个非常强的联系，通信的时间和频率则代表了这种联系的强弱。电信运营商在通信图上进行拓展骚扰电话阻断、经营分析等业务。除此之外，电信设备也可以使用图模型进行管理。 军工领域 通过情报网络构建事物的轨迹信息，覆盖并跟踪份子。同时可以利用图模型对复杂军工系统的研发、生产进行全生命周期数据管理。 主流图数据库对比详细的数据库排名可以参考DB-Engines专业机构排名[3] 详细的数据库测评可以参考[4]或者进入各图数据库官网查看 总结一下： Neo4j 分为社区版和商业版，两者最大的区别是社区版不支持集群并对性能有阉割，但neo4j是目前最成熟和老牌的图数据库在稳定性、功能、支持语言等方面比较完备。 ArangoDB 分为企业版和商业版，两者均支持集群，但存储后端适配单一并不支持索引后端，不支持多图管理 OrientDB 与ArangoDB相差不大 JanusGraph 完全开源，排名仅次于Neo4j，在处理性能上要优于Neo4j，支持千亿级节点查询，支持集群，由linux基金会负责维护，支持多图管理，支持多存储后端，支持多索引后端。 HugeGraph 由百度负责开发和维护，在整体性能和功能上与JanusGraph不相上下，两者均是基于阿帕奇的图计算框架Tinkerpop3进行开发，对中文地区相对友好很多。分为商业版和社区版。 参考资料： [1]https://zhuanlan.zhihu.com/p/144469165 [2]https://zhuanlan.zhihu.com/p/114834574 [3]https://db-engines.com/en/ranking [4]https://blog.csdn.net/weixin_43018183/article/details/96101194 [5]https://blog.csdn.net/hellohiworld/article/details/104824764 [6]https://zhuanlan.zhihu.com/p/50171330 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/4/29/graph-brief/"},{"title":"接口性能指标","text":"前言作为后端开发我们可能对接口的响应速度没有太大感觉,但是作为测试与前端乃至客户,他们对接口的性能是有直观感受的.本人做过前端,做过测试,目前专注做后端,近期团队有一个任务是关于接口优化的其实目标很明确就是针对性能较差的接口进行优化,尽可能的提升响应速度,我拿到任务后首先对其进行了分析,我发现这种任务一是需要优化人员对代码执行过程有深刻理解和优化经验,二是优化人员需要知道优化标准,前一点这里不做叙述(代码撸多了自然有经验),本文主要想叙述下接口优化的标准. 废话说了这么多,现在不如正题! 基本概念事务（Transaction）在web性能测试中，一个事务表示一个“从用户发送请求-&gt;web server接受到请求，进行处理-&gt; web server向DB获取数据-&gt;生成用户的object(页面)，返回给用户”的过程，一般的响应时间都是针对事务而言的。 请求响应时间请求响应时间指的是从客户端发起的一个请求开始，到客户端接收到从服务器端返回的响应结束，这个过程所耗费的时间. （1）在1秒钟之内，页面给予用户响应并有所显示，可认为是“很不错的”； （2）在1~2秒钟内，页面给予用户响应并有所显示，可认为是“好的”； （3）在2~3秒钟内，页面给予用户响应并有所显示，可认为是“勉强接受的”； （4）超过3秒就让人有点不耐烦了，用户很可能不会继续等待下去； 用户并发数（1）接口并发:针对某接口在同一时间的所有用户请求 （2）系统并发:针对整个系统平台在同一时间的所有用户请求 两者既有关联也有区别,后者范围囊括前者 吞吐量指的是在一次性能测试过程中网络上传输的数据量的总和.吞吐量/传输时间,就是吞吐率.简单理解为同一时间请求的数据量(字节大小的累加) TPS（transaction per second）每秒钟系统能够处理的交易或者事务的数量.它是衡量系统处理能力的重要指标. 带宽简单来说,带宽是同一时刻网络所能传输的最大数据量.公式：带宽 = 并发量 *数据量 QPSQPS=并发量/花费的时间 TP90标准TP90属于接口性能测试与描述的行业标准.那么什么是TP90呢? 当我们希望向别人解释，有一堆数据（数据的取值0~100）普遍都很小的时候，我们会这样跟对方说，有超过一半的数都小于10，或有一般的数小于5 。 那么这个在统计学里面是这样描述的【TP50=10 或者 TP50=5】 那么，什么是TP90呢？有90%的数小于X 那么TP90 = X 。比如，我考试考了60分，告诉我爸，我爸拿起竹条准备抽打我的时候我就说，这次考试的TP90 = 50啊，我爸估计就不会打了我，因为TP90 = 50表示班里有90%的人考试低于50分，而我考了60分，不是很棒吗？所以，我通过用TP90标准向我爸解释了这次考试分数普遍很低。 常见指标通用指标 指标 说明 ProcessorTime 服务器CPU占用率，一般平均达到70%时，服务就接近饱和 Memory Available Mbyte 可用内存数，如果测试时发现内存有变化情况也要注意，如果是内存泄露则比较严重 Physicsdisk Time 物理磁盘读写时间情况 WEB服务器指标 指标 说明 Requests Per Second（Avg Rps） 平均每秒钟响应次数＝总请求时间 / 秒数 Avg time to last byte per terstion （mstes） 平均每秒业务脚本的迭代次数 ,有人会把上面那个混淆 Successful Rounds 成功的请求 Failed Requests 失败的请求 Successful Hits 成功的点击次数 Failed Hits 失败的点击次数 Hits Per Second 每秒点击次数 Successful Hits Per Second 每秒成功的点击次数 Failed Hits Per Second 每秒失败的点击次数 Attempted Connections 尝试链接数 稳定系统的资源状态 性能项 资源 评价 CPU占用率 70% 好 85% 坏 90%+ 很差 磁盘I/O &lt;30% 好 &lt;40% 坏 &lt;50%+ 很差 网络 &lt;30%带宽 好 运行队列 &lt;2*CPU数量 好 内存 没有页交换 好 每个CPU每秒10个页交换 坏 更多的页交换 很差 HTTP接口性能指标 指标名称 要求 优先级 备注 响应时间 500 millisecond(毫秒) 1 500毫秒是针对正常接口的响应上线,这是基本响应时间必须包装.有些情况下接口内业务可能调用其它第三方服务,针对这种复合接口应尽量控制在500毫秒,有些特殊情况如文件解析,上传等属于特例.符合接口中的子接口一般控制在10毫秒左右 请求成功率 99% 2 TPS 在满足预期要求的情况下服务器状态稳定，单台服务器TPS要求在1000左右 3 资源使用率 要求在TPS正常幅度的情况下资源使用率幅度平稳，服务器状态平稳 3 要求接口的内部实现不能占用太多资源 数据库死锁 0，要求接口在使用过程中不会造成数据库死锁 1 CPU限制 要求接口在使用过程中不会出现大量的计算 3 内存 要求接口在使用过程中不会出现内存大量消耗的情况 3 本文参考内容如下: https://blog.csdn.net/aibisoft/article/details/39340231 https://blog.csdn.net/u010833547/article/details/60961982 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/10/17/interface/"},{"title":"信用卡养成攻略","text":"前言几十年来自己从来没有一张信用卡，平时利用最多的信用支付手段就是花呗了，正是用了花呗让我萌生出使用信用卡、养卡的想法。 信用卡的好处信用卡的好处太多了，例如薅羊毛、超长免息期、构建自己的信用体系、高额度抵御风险、利率相对交底、能够构建更加健康的现金流等等。同样的如果滥用信用卡也会使自己陷入万劫不复的境地，切记万不可用信用卡套现理财，风险太大。 正如[1]中所说的，信用卡仅仅是一个金融工具，是我们奔向财务自由过程中的一个小小的手段之一，用好了能够促进自己的资金管理，如果把信用卡当作套现工具或者盲目消费的工具，那么我这里不建议你使用信用卡。 确定自己养卡的目的既然信用卡的好处如此之多，根据每个人的情况和计划的不同养卡的目标也不尽相同，可以是薅羊毛也可以是建设护体卡以抵御未来风险。 仅从我个人而言我更倾向与构建护体卡，我对待薅羊毛兴趣不是太大。 护体卡如何养优先拿下中农工建四大行的信用卡，另外招商也不错。顺序如下： 第一批：建设、招商 第二批：工行（要先板砖）、农行 第三批：中行 1234567891011信用卡分期费率参考（2020） 1、工行信用卡分期手续费：3期免手续费、6期1.8%，9期2.7%，12期3.6%，18期5.85%，24期15.6% (一次性收取)。 2、农行信用卡分期手续费：每月0.6% (每个月收取)。 3、中行信用卡分期手续费：3期1.95%，6期3.6%，9期5.4%，12期7.5%，18期11.7%，24期15%(一次性收取)。 4、建行信用卡分期手续费：3期0.7%，6期和12期均为0.6% (每个月收取)。 5、中信银行信用卡分期手续费：1期1.50%,3期0.82% 6期0.82%，12期0.77% (每个月收取)。 6、浦发信用卡分期手续费：3期0.72%，6期0.7%，12期0.66%(每个月收取)。 7、招行信用卡分期手续费：2期1.0%，3期0.9%，6期0.75%，10期：0.7%，12期0.66%，18期0.68%，24期0.68%(每个月收取)。 8、交行信用卡分期手续费：每月0.72%(每个月收取)。 9、广发信用卡分期手续费：6期、12期均为0.65%，18期为0.7%，24期为0.72%(每个月收取)。 10、光大信用卡分期手续费：未消费前申请分期还款，12个月分期，每月收取0.5%。账单分期种类有3期、6期、9期和12期，手续费分别为2%、4%、5%、6%(一次性收取)。 申卡注意事项1、2个月内申请信用卡次数不要超过5次；2、当连续被拒次2次时，应该停止申请，总结拒卡原因；3、卡数超过15张后就比较容易被拒，这时应该降低卡负债，广泛性撒网，选择性捕捞。；避免申请占信用卡总授信额度的分期产品，如X发银行，XX金；不要申请消费自动分期的分期卡，资金成本高（13%左右），且占用总授信额度； 4、每一批申请卡到手后需要养至少半年再进行其它申请 多卡使用技巧 在消费总量不变的情况下多张信用卡组合使用最用的使用方法： 越晚还款越好 可多次还款，每次还款越少越好 年度还款金额理想的情况是逐渐递减的 因此多张信用卡使用最好的方式是调整为相同的结算日期，或者结算日期天数相差十天以内，这样的好处有： 同一时间的用卡选择更多 相同的结算日期更方便还款 更有利于满足条件1，2，3 养卡终极法则 1、银行是企业，终极目的是赚钱，最终谁能为银行创造价值谁才是真正的优质顾客。 2、忘记所谓的免息期，银行帮助我们提钱完成梦想，我们回报银行利息是天经地义的，我们和银行是合作关系。 3、仅仅资质好只能让银行放心借钱，但不会情愿借钱，下卡前看资质，下卡后看贡献，银行真正在寻找的客户是：有能力还钱、能按时还钱、创造满意利润。 4、对于一个资质极差的人而言，只要能够吃苦耐劳，有一份稳定合法的收入，都有资格成为银行的优质客户，信用卡终极法则：搬砖、刷卡、分期。 5、你就是未来的卡神。 参考资料： [1]https://mp.weixin.qq.com/s/YRGQz6SVN2y4ibU6puIo4w var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/8/5/creditCard/"},{"title":"投资思考","text":"本文是投资过程中的一些随笔，一些闪现的灵感和思考 投资即是投人，让有才能的人帮你赚钱 投资的本质是购买优质资产，让资产帮你攥钱 价值决定价格+思考社会财富掌握在那些人手中+观察世界/社会的发展规律顺应潮流—例如通货膨胀 货币超发引发通货膨胀，资金流向优质资产来规避通货膨胀，如一线城市房子/股市优质企业 货币发行量增多，购买力就会提升，进而推动消费和投资的增长，物价也将会回升。从历史经验来看，在一轮大规模增发货币后的几年里，通胀就会出现快速的回升。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/2/20/investment/"},{"title":"家庭保险基础知识","text":"本文仅仅针对需要配置保险的家庭做保险相关知识的简单介绍，看完这篇文章不能说对各种保险都了如指掌，至少可以在配置保险的时候能够有准备的配置。 保险的种类有哪些？四大险 重疾险：针对重大疾病进行赔付的保险，一般是出险后一次性赔付保险保障金额，有些还会约定多次赔付内容。重疾类型国家给约定了25种，这25基本上涵盖了高发疾病的95%。 医疗险：针对治疗过程中产生的费用进行赔付的保险，一般有一个起始赔付金额，例如住院费用超过一万以上的部分才会进行赔付，最多赔付400万等。医疗险是一次缴费保障一年，有些比较好的医疗险可以保证续保20年，就是说在保障期限内即使出保，下一年度也保证让你继续续报。 意外险：这个很好理解，因为意外情况造成被保险人受到伤害或者丧生的情况进行一次性赔付的险种。一般给高危险人群配置或者给儿童配置。 寿险：对被保险人寿命进行保障的险种，例如约定保障到70岁，在这之前丧生的无论是什么原因都会根据保险金进行一次性赔付。寿险分为定期寿险和终身寿险，一般家庭购买定期寿险就可以了，性价比高。终身寿险适合有钱人使用，可以作为财富转移的途径。 其它险例如财产险，针对某项固定资产进行保险的行为，例如对房子、贵重物品等，这个一般家庭用不到。 如何配置保险？对于家庭而言，配置保险只要记住1+4+X即可。 1指的是社保：国家给予公民的基本福利，属于基础，一定要配置上 4指的是四大人身险，包括重疾险、医疗险、意外险、定期寿险 重疾险：一般给顶梁柱配置，如果家庭成员出现意外将使家庭陷入巨大困境，那么该成员适合配置重疾险 医疗险：建议家庭成员都要配置，随着年龄的增长每年的费用会有变动，一般也就几百块，建议购买保证长期续报的保险 意外险：给高危人群配置，例如家庭中的儿童，一年购买一次 定期寿险：有条件的家庭成员都要配置，没有条件的优先给顶梁柱配置 X指的是一些比较合适的财产险，比如车险、家财险等。 注意事项 返还型保险不要买，实际利率极低且保障作用不高 不要迷信大保险公司，国家统一管控，大小公司都一样有保障，只要选择性价比最高的 优先给家庭顶梁柱配置保险 不需要大而全或者一步到位的保险，保险是需要慢慢配置补充的 重疾险建议购买保终身 重疾险附加条款建议不要包含身故赔付，性价比低 医疗险一定要选择保证长期续报的保险，例如保证续保20年 参考资料： [1]https://zhuanlan.zhihu.com/p/93562931 [2]https://www.zhihu.com/question/22316395/answer/100909780 [3]https://zhuanlan.zhihu.com/p/95776448 [4]https://zhuanlan.zhihu.com/p/88503077 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/4/9/famliy-insurance/"},{"title":"生育过程中需要注意的事情","text":"前言生育对一个女性和一个家庭来说是一件大事，在生育之前我们需要提前了解关于生育过程中的一些注意事项，这些注意事项关系到金钱、孩子健康等。现在简略总结一下。 生育保险报销（医疗费补贴）生育保险是为女性职工因生孩子而不能工作设立的保险，所以，有了这个保险，女性在产假期间的收入中断会得到相应的保障。而且这个保险不仅女员工要交，男员工也要交。男员工虽然不生孩子，但只要交了保险金，就可以把它拿来给自己的妻子用。只要参保生育保险满 1年，就能对生育医疗进行报销，此外符合条件的还可以领到一笔生育津贴。 报销方式的一种是按比例报销。通俗来讲就是花多少，报销多少，花的多报销的多。另外一种是固定报销金额。不管你生孩子花了多少钱，报销的数额是固定的，不会变，只报销那么多钱。除了生育医疗费能报销，实施计划生育手术，比如人流，安节育器，结扎等费用，生育险也能报销。这里就不具体列了，具体可咨询当地社保局了解。 以上海地区为例： 上海市采取固定额度报销的方法。 正常生育报销3600 自然流产的且大于4个月的报销600 自然流程的且小于4个月的报销400 报销的范围主要是： 早孕检查与建册、产前检查、住院生产(医疗保险基金承担部分除外)、产后访视、产后42天康复检查及自然流产(包括宫外孕、葡萄胎)。 报销流程和材料（以上海为例） “三证一卡一票” 身份证、出生证、准生证、银行卡、医院发票 特别注意： 1.如果是委托办理，需要提交委托书和委托人身份证及复印件。 2.银行卡是指定银行卡，但几大行的卡基本上都能用。 3.一票就是医院费用清单和发票。 4.如果是上海参保，在外省生孩子，需要提交出院小结或者病历本。 5.如果是在港澳台生孩子需要提交能证明生育的病历证明材料。 【报销流程】 1.准备好材料后去社保网点，柜台填写《生育保险待遇申请表》，拿号等待叫号； 2.叫号后到对应窗口，提交申请表和上述材料，并会出现三个结果： 可办理：收取材料并打印《受力情况回执》一式两份，机构拿一份，办事人拿一份。 材料不齐：退回材料并打印《受力情况回执》一式两份，机构拿一份，办事人拿一份。 材料不符合规定：复印全部材料后退回材料并打印《受力情况回执》一式两份，机构拿一份，办事人拿一份。 3.自申领之日起，一个月内报销到账。 生育津贴满足条件 领取生育津贴之前需要确定自己满足如下条件： 一是生育保险要交满一年才能领取（不同地区的要求不一样，这点可以咨询当地社保局） 二是领生育津贴时你要保持在保状态，所以你最好不要随便辞职。 领取规则 能领多少生育津贴，按这个公式算一算就知道了。 生育津贴 = 用人单位上年度职工月平均工资÷30×规定的假期天数。 这里“规定的假期天数”是多少呢？国家统一规定女职工产假是98天，但不同城市，会增加其他的产假。 如何领取 首先要明确的是个人不能直接申请去领取，要由用人单位来进行申请。 职工先填写享受生育保险待遇申请表 然后按照当地要求提供所需资料交给用人单位 由用人单位负责把相关资料送到社保局申报 等待业务人员受理完成后生育基金会直接支付到单位账户然后再由单位发放 婴幼儿医保一定要记得孩子刚出生，最好给孩子办婴幼儿医保。注意事项如下： 办理了婴幼儿医保可以得到报销，报销额度各地不同，但确定的是门诊和住院费用都可以报销 办理越早越好，最好在孩子出生的三个月内办理完成 办理流程参考： ①户籍地办理：先去派出所给孩子上户口 → 带上孩子的出生证明、户口本、父母双方的身份证、结婚证，到区县医保中心进行办理 → 领取孩子医保卡 ②非户籍地办理（夫妻两人户籍在A，想给孩子办b的医保）： 需要满足：父母一方有当地户口（有的地方会有积分要求） 先去老家派出所给孩子上户口 → 带上孩子的出生证明、户口本、父母双方的身份证、结婚证，到社区医保服务点办理 → 领取孩子医保卡 婴幼儿医保是每年交一次费，交一年保一年的。 准生证以上海为例：准生证已改为上海市生育服务单，实行登记制度。办事程序如下： 申办条件： 2016年1月1日以后生育第一个子女或者第二个子女、夫妻一方或者双方为本市户籍或者居住在本市的流动人口夫妻。 申请材料： 1.夫妻双方的有效身份证原件或户籍证明； 2.婚姻状况证明； 3.不在本市医疗机构生育的，还需提供出生医学证明； 4.委托他人办理的，还须提供受委托人的身份证明、委托人出具的委托书。 办理程序： 1\\拟要办理《上海市生育服务单》的公民，可以选择就近的乡（镇）人民政府或者街道办事处(社区事务受理服务中心或计划生育工作的办公室)提出申请。 2\\乡（镇）人民政府或者街道办事处(社区事务受理服务中心或计划生育工作的办公室)受理了申请后，按照以下情形予以处理： （1）对于材料齐全、信息核实比对一致的，即时发放《上海市生育服务登记单》。 （2）对于信息系统中尚未形成生育登记信息的，现场采集相关信息后发放《上海市生育服务登记单》。 （3）对于信息系统中的信息与实际情况不一致的，在与申请人核对信息的基础上，依据申请人的承诺和申请材料发放。 （4）对于不属于生育登记范围的对象，不予发放并书面告知不予发放的原因。 参考资料： [1]https://www.zhihu.com/question/296169427/answer/835215554 [2]https://zhuanlan.zhihu.com/p/69826880 [3]https://zhuanlan.zhihu.com/p/108005378 [4]https://www.zhihu.com/question/291224550/answer/477126775 [5]https://www.zhihu.com/question/21627834/answer/1316851230 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/8/26/fertility/"},{"title":"车险购买问答知识点","text":"前言我做事情有个特点，遇事必定三思而后行，先做好充分的了解再去行动。这都是吃了无数认知不足的亏才总结下来的，本文主要记录一些在购买车险时所需要了解的知识。 车险的种类有哪些？车险主要分为交强险和商业保险，其中交强险是国家要求必须要买的，商业险则是自行购买。具体商业险险种如下： 哪些商业险种需要购买？主险有第三者责任险、车损险、车上人员责任险建议购买，其中需要注意的是车损险要按照自己车辆实际价值申报，否则申报价格低虽然一时省钱，但实际上万一出险则损害了自身利益。第三者责任险建议购买至少100万，现在豪车太多，在大城市生活尤其需要高保额，中小城市可酌情选择。车上人员责任险其实不需要一同购买，可单独购买一份人身意外险，价格可以更优惠。 附加险有自然险、不计免陪险建议购买。其中不计免陪不能单独购买需要附加在主险之上，例如车损险增加不计免陪险，不计免陪的意思是当出险时保险公司已经报销应该报销的部分但仍有超出部分需要车主自行负责，这个时候如果有不计免陪险那么还可以再次把需要车主负责的部分再次转嫁给保险公司一定的比例。 2020车险保费改革内容有哪些？具体可参考[1]，我这里仅将主要内容以及注意事项进行说明。 交强险保额增多 保费降低，针对出险少的车主有利 免责减少，保险公司免责情况减少 责任增多，昔日需要单独购买的附加险现在有些直接涵盖在主险中，如下图 最醒目的是昔日需要单独购买的不计免陪和自然险，现在直接涵盖在车损险中了，无需再次购买。 购买保险的方式？ 网络，如支付宝 电话，业务人员电话/官网电话 4s店代售 职业保险人 保险公司选择？保费改革后各家保险公司的保险价格相差不大，当然是尽可能选择服务网点多的，出险快捷和便利的保险公司，例如平安、太平洋、人保等。 其他福利/优惠的争取有哪些？ 常见的基础救援：比如说搭电、送油、换备胎这一系列东西都是免费的 拖车服务 吊车服务 免费保养、洗车、漆面等 以上这些优惠不会算做出险次数，与次年保费无关。一般来说购买了商业保险后保险公司都会提供一定的免费服务。保费改革后一些保险公司不会赠送以上增值服务，或者需要购买车损险后才予以赠送，因此具体还要在买保险的时候咨询好。 参考资料： [1]https://zhuanlan.zhihu.com/p/216416954 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/1/13/car-insurance/"},{"title":"KMP算法","text":"字符串查找算法，常用于在一个文本串S内查找一个模式串P 的出现位置 KMP算法的关键是求出模式串对应的Next数组，借助next数组来实现字符串匹配失败时的跳转步数。 算法步骤1、假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 2、如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符； 3、如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 关键字说明 文本串：匹配字符串文本，如ababaaabd 模式串：待匹配字符串，如aab 最长相同前缀后缀：如ababacdab中的最长相同前缀后缀为ab（从字符串头和尾分别找寻两者相待的字符串） next数组：next数组研究的是对模式串的“最长相同前缀后缀”的跳转记录。next意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。 寻找最长前缀后缀如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示： 模式串的各个子串 前缀 后缀 最大公共元素长度 A 无 无 0 AB A B 0 ABC A,AB C,BC 0 … ABCDA A,AB,ABC,ABCD A,DA,CDA,BCDA 1 ABCDAB A,AB,ABC,ABCD,ABCDA B,AB,DAB,CDAB,BCDAB 2 ABCDABD … … 0 字符 A B C D A B D 最长前缀后缀 0 0 0 0 1 2 0 寻找next数组next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1 模式串 A B C D A B D 最长前缀后缀 0 0 0 0 1 2 0 next数组 -1 0 0 0 0 1 2 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/19/kmp/"},{"title":"paxos分布式一致性算法","text":"前言Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。Paxos算法问世已经有将近30年的历史了，是目前公认最有效的解决分布式场景下一致性问题的算法之一，但是缺点是比较难懂，工程化比较难。 Paxos算法是用来解决分布式系统中，如何就某个值达成一致的算法。 一致性问题什么是一致性问题? 假设有一组服务器保存了用户的余额，初始是100块，现在用户提交了两个订单，一个订单是消费10元，一个订单是充值50元。由于网络错误和延迟等原因，导致一部分服务器只收到了第一个订单（余额更新为90元），一部分服务器只收到了第二个订单（余额更新为150元），还有一部分服务器两个订单都接收到了（余额更新为140元），这三者无法就最终余额达成一致。这就是一致性问题。 一致性问题的传统解法? 当集群环境存在一致性问题时我们最容易想到的是建立一个”协调者”,通过协调者来保证一致性.但是如果协调者宕机了呢? 如果协调者宕机我们可能回想到建立协调者集群,这时又出现协调者间的一致性问题…. Paxos是能够基于一大堆完全不可靠的网络条件下却能可靠确定地实现共识一致性的算法。也就是说：它允许一组不一定可靠的处理器（服务器）在某些条件得到满足情况下就能达成确定的安全的共识，如果条件不能满足也确保这组处理器（服务器）保持一致。 需要注意的是paxos的应用场景是假定各消息提供方提供的消息是真实有效的,伪造消息不在paxos研究范围内,Byzantine Paxos 以及区块链技术是paxos的升级和应用,能够有效避免伪造消息等情况发生. paxos的发展历史及演变 从上图可以看出paxos发展分为三个阶段: 1988年Lislov(利斯洛夫)等人在PODC(分布式计算原理学术讨论会)上发表了一篇文章,关于副本宕机,分布式系统仍能够正常运行的算法,该算法本质上与Paxos一致 1989年Leslie Lamport在1989年提出Paxos这个名称，但他的论文因为过于艰涩，未能发表。 1996年，Lamport论文的正式发表（与8年前第一次投稿相比，几乎未改）。 1999年，Butler Lampson等人重新描述和证明了Paxos算法，并分析了其时间开销及容错性。 1999年，Liskov等人提出了PBFT（实用的拜占庭容错算法）被Lampson称为Byzantine Paxos，该算法对基础Paxos进行了改进，使其可以处理拜占庭错误。 2000年，Lamport在提出了Disk Paxos，这可以认为是Paxos基于磁盘的版本，以支持持久化。 2004年，Lamport提出了Cheap Paxos,其提升了算法的容错性 2006年，Lamport提出了Fast Paxos,其降低了消息延迟 2007年，google公司研究小组提出了Multi-Paxos,其将paxos中的论证阶段进行简化,提高了效率 2007年及其以后google公司在OSDI发表的两篇论文拉开了paxos工业应用的序幕 Paxos算法流程Paxos中的角色 Proposer(提议人):负责提出提案(Proposal),Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value) Acceptor(接收人):参与决策，回应Proposers的提案 Learner(学习者):不参与决策，从Proposers/Acceptors学习最新达成一致的提案（Value） 注:在多副本状态机中，每个副本同时具有Proposer、Acceptor、Learner三种角色 Paxos的决议阶段 第一阶段：Prepare阶段。Proposer向Acceptors发出Prepare请求，Acceptors针对收到的Prepare请求进行Promise承诺。 第二阶段：Accept阶段。Proposer收到多数Acceptors承诺的Promise后，向Acceptors发出Propose请求，Acceptors针对收到的Propose请求进行Accept处理。 注:在第二阶段结束后如果Proposer收到多数Acceptors的Accept，标志着本次Accept成功，决议形成，将形成的决议发送给所有Learners Acceptor的两个承诺一个应答两个承诺(可重复接受) 不再接受Proposal ID小于等于（注意：这里是&lt;= ）当前请求的Prepare请求。 不再接受Proposal ID小于（注意：这里是&lt; ）当前请求的Propose请求。 一个应答 不违背以前作出的承诺下，回复已经Accept过的提案中Proposal ID最大的那个提案的Value和Proposal ID，没有则返回空值。 Paxos算法伪代码Base-Paxos 步骤1:提议人生成最新提议编号N(N自增且唯一,Paxos不同实现其N的生成算法不同),并将N广播至所有接收人 步骤2:接收人响应提议人Proposal,如果接收人maxN(记录最大N)为null则记录N到maxN并返回(null,null),如果N&gt;maxN则记录N到maxN并返回(acceptN,accetpV),如果N&lt;=maxN则不响应 步骤3:提议人收集所有来自接收人的响应数据,如果响应数量小于等于半数则重新执行步骤1,否则将从所获取所有响应的最大编号accetpedN所对应的acceptedV作为阶段二value的提交值. 步骤4:此步骤提议人将提交(N,value)至所有接收人,其中N将重新生成,value来自步骤3,如果value==null则将有提议人自行决定 步骤5:接收人将针对提议人的(N,value)进行响应,如果N小于maxN,接收人不响应,否则,接收人将更新maxN,accetpedN,accetpedV并返回(acceptN,accetpV) 步骤6:由提议人根据响应结果确定value的决议结果并将结果分发至各Learner,其中如果响应数过半数但响应结果的编号result大于发送编号N,那么证明value有被更新,需要重新执行步骤1 总结: 阶段一本质上是收集各接收人现存(acceptN,accetpV)并为阶段二的数据提交做准备 阶段二本质上是完成决议确定value值并将决议结果发送至各Learner 注:原始的Paxos算法（Basic Paxos）只能对一个值形成决议，决议的形成至少需要两次网络来回，在高并发情况下可能需要更多的网络来回。如果想连续确定多个值，Basic Paxos搞不定了。因此Basic Paxos几乎只是用来做理论研究，并不直接应用在实际工程中。 Paxos算法推导算法目标 T1.一次选举必须要选定一个议案（不能出现所有议案都被拒绝的情况） T2.一次选举必须只选定一个议案（不能出现两个议案有不同的值，却都被选定的情况） 约束条件P0.:当集群中，超过半数的Acceptor接受了一个议案，那我们就可以说这个议案被选定了（Chosen） P0已经是一个完备的一致性算法，保证了P0也就解决了一致性问题。但是P0的实用性不佳，一个议案想被半数以上的Acceptor接受是一件极其困难的事情！ P1:Acceptor必须接受（Accept）它所收到的第一个Proposal 为什么必须满足P1,我们设想一个极端场景,比如环境中只存在一个Proposal和一个Acceptor,当Proposal发送的提案由于特殊原因被acceptor拒绝,那么这时违反了T1,即T1的隐含条件包含了P1 P2:如果一个值为v的议案被选定了，那么被选定的更大编号的议案，它的值必须也是v P2-1:假设v1被选定,由P0可知议案被选定必定有超过半数的Acceptor接受v1 P2-2:同理少于半数的Acceptor可能接受了不同的v2,v3,vx……(为什么少于半数的Acceptor会接受非v1,原因可能是多样的,例如由P1造成,或者网络发送不及时等.) P2-3:由P2-1与P2-2我们知道在整个集群环境下v1是超过半数的,理应被选中的,但是实际环境常常不如人意,例如由于网络问题v1并没有及时的通知到各Proposer,那么有可能产生v2或者v3被认为是超过半数的从而被选定,这是有多个议案被选定显然是违背了T2的. P2-4:如果存在多个v1,v2,v3被选定那么只需要保证v1=v2=v3也可以满足T1.那么如何满足多个被选定值相等呢? P2-5:如果要满足多个选定值相等只需满足”其它的”编号也同为v1(假设为集合A)或者”更大的”编号也为v1(假设为集合B)即可,显然B∈A,我们只需要满足B即可 P2-6:我们知道Acceptor的”两个承诺,一个应答”决定了Accetpor只会接受编号大于当前编号的提案,只需满足最大编号对应的v也是v1即可满足多个被选定值相同从而满足T1.以上即为P2存在的意义. 总结: 如果P1和P2都被满足那么Paxos的目标T1和T2就能够实现,想要确保P1成立很简单,但是想要使P2成立必须要继续添加约束条件. P2a:如果一个值为v的议案被选定了，那么Acceptor接受的更大编号的议案，它的值必须也是v P2a是P2的充分条件,即Acceptor接受议案是Proposer选定议案的前提.所以只需满足P2a即可满足P2,但是想要满足P2a并不容易,例如已经选定v1(超过半数),但是由于网络原因之前的Proposer广播v1时并没有送达某Acceptor(假设a1),这个时候如果a1从未接受过提议,那么根据P1,a1必须接受其它Proposer的提议内容v2,此时v1!=v2这违背了P2a.因此需要P2b来进行进一步约束. P2b:如果一个值为v的议案被选定了，那么Proposer提出的更大编号的议案，它的值必须也是v P2b是P2a的充分条件,即Proposer的提议是Acceptor接受的前提条件.想要满足P2b也不容易,受网络环境影响,例如提议人a(简称Pa)在12:02:20 50时间点发送提议(N1,V1),当在12:02:20 59时提议全部送达所有Acceptor,此时接收人超过半数V1被选定.但是由于网络原因Pb在12:02:20 55时发现当前环境并没有被选中的提案因此提议(N2,V2),这时将违反P2b,需要P2c对其进行进一步约束. P2c:在所有Acceptor中，任意选取半数以上的Acceptor集合，我们称这个集合为S。Proposal新提出的议案（简称Pnew）必须符合下面两个条件之一 P2c-1:如果S中所有Acceptor都没有接受过议案的话，那么Pnew的编号保证唯一性和递增即可，Pnew的值可以是任意值 P2c-2:如果S中有一个或多个Acceptor曾经接受过议案的话，要先找出其中编号最大的那个议案，假设它的编号为N，值为V。那么Pnew的编号必须大于N，Pnew的值必须等于V P2c有效性证明实现了P2c就可以满足P2b进而最终实现Paxos目标,但是如何证明P2c是能够满足P2b的呢?以下内容为作者通过数学归纳法的证明: 题目:已知议案 $(m, v_a)$，是集合中第一个被选定的议案，接受这个议案的Acceptor集合为 **$S_m$**，在满足P2c的规则2的情况下，提出了一个新的议案 $(n, v_b)$，其中$n&gt;m$，证明$v_b = v_a$ 步骤一:当议案的编号$n = m+1$时，证明$v_b = v_a$ 因为$(m, v_a)$是第一个被选定的议案，因此在$m+1$提出之前，$m$必然是集群当中编号最大的议案。根据P2c的规则2，议案$(m+1,v_b)$能够被提出，是因为存在一个多数派集合$S_n$，这个集合中，编号最大的议案的值为$v_b$。因为$Sm$和$Sn$都是多数派集合，所以他们必定存在交集。交集中的Acceptor必定都接受了$(m,v_a)$，$m$是整个集群最大的编号，当然也是$S_n$中最大的编号，根据P2c的规则2，议案$m+1$的值只能是$v_a$，若$v_b$不等于$v_a$，将导致矛盾，因此$v_b = v_a$ 步骤二:当$n &gt; m+1$时，假设编号从$m+1$到$n-1$的议案的值都是$v_a$，证明$v_b = v_a$ 编号为$m+1$到$n-1$的议案提出后，我们没办法判断究竟那一个议案会被选定，但有一点是可以肯定的：所有接受了$v_a$的Acceptor构成了一个新的集合$S_{n-1}$，这个集合包含了集合$Sm$中的所有Acceptor，$S_{n-1}$显然是一个多数派集合，这个集合接受的议案的编号在$m$到$n-1$之间，而且值为$v_a$。没有包含在集合$S_{n-1}$中的Acceptor所接受的议案一定小于$m$。根据P2c的规则2，议案$(n,v_b)$能够被提出，那么一定存在一个多数派集合$Sn$，$Sn$中接受的最大编号的议案的值为$v_b$。因为$S_n$和都$S_{n-1}$是多数派集合，所以他们必定存在交集。交集中的议案的最大编号一定在$m$到$n-1$之间。因此$S_n$集合中编号最大的议案一定位于交集内。根据P2c的规则，此时$v_b$必定等于$v_a$。 编号的生成规则编号用来区分不同的议案,每一个Proposer在提交议案时必须生成编号,编号必须具备如下性质: 唯一性 递增性 编号的生成算法有多种,在《Paxos made simple》中提到，推荐Proposer从不相交的数据集合中进行选择. 方案一: 假设有n个proposer，每个编号为ir(0&lt;=ir&lt;n)，proposal编号的任何值s都应该大于它已知的最大值 s = m * n + i (其中s表示本次编号生成结果,m表示生成次数,n表示proposer数量,i表示下标) 这样即可确保不相交集合. 例如:第一次提交时各proposer的编号生成如下:(假设有三个proposer) P1=1*3+0=3 P2=1*3+1=4 P3=1*3+2=5 …… 方案二: 在实践过程中，可以用 时间戳 + 提出提案的次数 + 机器 IP/机器ID 来保证唯一性和递增性。 活锁的产生活锁的产生原因本质上是多个proposer均认为自己提交的编号过低,从而生成最新的递增版本号重复提交,这样会导致死循环,新轮次的抢占会使旧轮次停止运行，如果每一轮在第二阶段执行成功之前 都 被 新一轮抢占,这种情况被称为活锁.活锁的产生原因多种多样,可能是网络原因等造成. 这个问题在实际应用会发生地比较少，一般可通过 随机改变 ProposalID的增长幅度 或者 增加Proposer发送新一轮提案的间隔 来解决。 参考文献如下: https://blog.csdn.net/cnh294141800/article/details/53768464 https://www.cnblogs.com/stateis0/p/9062130.html https://blog.csdn.net/yowasa/article/details/81224936 https://blog.csdn.net/omnispace/article/details/79653932 https://zhuanlan.zhihu.com/p/43800991 https://zhuanlan.zhihu.com/p/69817030 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/10/19/paxos/"},{"title":"paxos算法的应用场景","text":"在”paxos分布式一致性算法”一文中详细介绍了paxos算法的前世今生以及paxos算法思想,本文主要介绍paxos算法的典型应用场景.paxos主要解决分布式系统一致性问题,确保多节点的数据统一,其在大数据管理,数据备份等方面有重要作用. 数据备份Paxos最常见的应用场景是数据库备份(Database Replication),保证数据在多个节点上的一致性。 工业界在这方面的典型系统包括Chubby（谷歌公司），Zookeeper（Yahoo!的Hadoop项目），Nutanix（Vmware），以及PhxPaxos（腾讯微信） Chubby-使用了paxos来保证日志在各个副本上的一致性，Paxos算法可以确保每个副本的本地日志具有相同的内容，在这之上是高容错的分布式数据库层 Zookeeper-可以看作是一个开源的Chubby,其被应用在Hadoop,帮助提供强一致性的分布式文件系统 Nutanix-分布式文件系统(NDFS)是Vmware虚拟计算平台的核心.该系统负责管理所有的元数据和数据。NDFS具有极高的容错能力，可确保节点发生故障时数据的可用性和一致性。 PhxPaxos是腾讯公司微信后台团队自主研发的一个类库,基于paxos算法思想,实现多机的状态拷贝. 域名服务器网络中每个节点都有一个地址，网络能根据消息的目标地址将消息准确送到对应的节点。域名服务器（Name Server）的作用就是将一个节点或服务的名称转换为对应的位置或地址。 一个中心域名服务器必须位于一个众所周知的地址，且永不改变。但当这个中心域名服务器崩溃时，整个网络都将崩溃。一个中心域名服务器也需要一个极多的存储空间，并且可能导致信息过载。为了解决上述问题，我们可以采用分布式域名服务器。 Config配置管理通常对于小的系统，我们习惯采用手工修改配置文件的方法，这样做有两个问题，其一是容易出错；其二，若系统运行在多个节点上，手工修改难以保证多个节点的状态是一致的。因此，对于大规模的应用系统，特别是分布式的应用，我们必须采用自动化的方式统一修改配置文件。 目前一个流行的做法是采用Zookeeper（核心是Paxos），将配置文件放到Zookeeper的某个目录上，然后各个程序对这个目录节点进行监听。若配置发生改变，各个节点上的应用程序就会收到通知，并自行修改配置。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/10/22/paxosUsed/"},{"title":"paxos算法的应用场景举例","text":"假设的3军问题1） 1支红军在山谷里扎营，在周围的山坡上驻扎着3支蓝军； 2） 红军比任意1支蓝军都要强大；如果1支蓝军单独作战，红军胜；如果2支或以上蓝军同时进攻，蓝军胜； 3） 三支蓝军需要同步他们的进攻时间；但他们惟一的通信媒介是派通信兵步行进入山谷，在那里他们可能被俘虏，从而将信息丢失；或者为了避免被俘虏，可能在山谷停留很长时间； 4） 每支军队有1个参谋负责提议进攻时间；每支军队也有1个将军批准参谋提出的进攻时间；很明显，1个参谋提出的进攻时间需要获得至少2个将军的批准才有意义； 5） 问题：是否存在一个协议，能够使得蓝军同步他们的进攻时间？ 接下来以两个假设的场景来演绎BasicPaxos；参谋和将军需要遵循一些基本的规则 1） 参谋以两阶段提交（prepare/commit）的方式来发起提议，在prepare阶段需要给出一个编号； 2） 在prepare阶段产生冲突，将军以编号大小来裁决，编号大的参谋胜出； 3） 参谋在prepare阶段如果收到了将军返回的已接受进攻时间，在commit阶段必须使用这个返回的进攻时间； 两个参谋先后提议的场景 1） 参谋1发起提议，派通信兵带信给3个将军，内容为（编号1）； 2） 3个将军收到参谋1的提议，由于之前还没有保存任何编号，因此把（编号1）保存下来，避免遗忘；同时让通信兵带信回去，内容为（ok）； 3） 参谋1收到至少2个将军的回复，再次派通信兵带信给3个将军，内容为（编号1，进攻时间1）； 4） 3个将军收到参谋1的时间，把（编号1，进攻时间1）保存下来，避免遗忘；同时让通信兵带信回去，内容为（Accepted）； 5） 参谋1收到至少2个将军的（Accepted）内容，确认进攻时间已经被大家接收； 6） 参谋2发起提议，派通信兵带信给3个将军，内容为（编号2）； 7） 3个将军收到参谋2的提议，由于（编号2）比（编号1）大，因此把（编号2）保存下来，避免遗忘；又由于之前已经接受参谋1的提议，因此让通信兵带信回去，内容为（编号1，进攻时间1）； 8） 参谋2收到至少2个将军的回复，由于回复中带来了已接受的参谋1的提议内容，参谋2因此不再提出新的进攻时间，接受参谋1提出的时间； 两个参谋交错提议的场景 1） 参谋1发起提议，派通信兵带信给3个将军，内容为（编号1）； 2） 3个将军的情况如下 a) 将军1和将军2收到参谋1的提议，将军1和将军2把（编号1）记录下来，如果有其他参谋提出更小的编号，将被拒绝；同时让通信兵带信回去，内容为（ok）； b) 负责通知将军3的通信兵被抓，因此将军3没收到参谋1的提议； 3） 参谋2在同一时间也发起了提议，派通信兵带信给3个将军，内容为（编号2）； 4） 3个将军的情况如下 a) 将军2和将军3收到参谋2的提议，将军2和将军3把（编号2）记录下来，如果有其他参谋提出更小的编号，将被拒绝；同时让通信兵带信回去，内容为（ok）； b) 负责通知将军1的通信兵被抓，因此将军1没收到参谋2的提议； 5） 参谋1收到至少2个将军的回复，再次派通信兵带信给有答复的2个将军，内容为（编号1，进攻时间1）； 6） 2个将军的情况如下 a) 将军1收到了（编号1，进攻时间1），和自己保存的编号相同，因此把（编号1，进攻时间1）保存下来；同时让通信兵带信回去，内容为（Accepted）； b) 将军2收到了（编号1，进攻时间1），由于（编号1）小于已经保存的（编号2），因此让通信兵带信回去，内容为（Rejected，编号2）； 7） 参谋2收到至少2个将军的回复，再次派通信兵带信给有答复的2个将军，内容为（编号2，进攻时间2）； 8） 将军2和将军3收到了（编号2，进攻时间2），和自己保存的编号相同，因此把（编号2，进攻时间2）保存下来，同时让通信兵带信回去，内容为（Accepted）； 9） 参谋2收到至少2个将军的（Accepted）内容，确认进攻时间已经被多数派接受； 10） 参谋1只收到了1个将军的（Accepted）内容，同时收到一个（Rejected，编号2）；参谋1重新发起提议，派通信兵带信给3个将军，内容为（编号3）； 11） 3个将军的情况如下 a) 将军1收到参谋1的提议，由于（编号3）大于之前保存的（编号1），因此把（编号3）保存下来；由于将军1已经接受参谋1前一次的提议，因此让通信兵带信回去，内容为（编号1，进攻时间1）； b) 将军2收到参谋1的提议，由于（编号3）大于之前保存的（编号2），因此把（编号3）保存下来；由于将军2已经接受参谋2的提议，因此让通信兵带信回去，内容为（编号2，进攻时间2）； c) 负责通知将军3的通信兵被抓，因此将军3没收到参谋1的提议； 12） 参谋1收到了至少2个将军的回复，比较两个回复的编号大小，选择大编号对应的进攻时间作为最新的提议；参谋1再次派通信兵带信给有答复的2个将军，内容为（编号3，进攻时间2）； 13） 将军1和将军2收到了（编号3，进攻时间2），和自己保存的编号相同，因此保存（编号3，进攻时间2），同时让通信兵带信回去，内容为（Accepted）； 14） 参谋1收到了至少2个将军的（accepted）内容，确认进攻时间已经被多数派接受； var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/10/24/paxosUsed/"},{"title":"二叉树,AVL树,红黑树,B树,B+树原理","text":"二叉查找树 最多有两个子节点 左节点小于父节点，右节点大于父节点 没有键值相等的节点. 前序、中序、后续、层序遍历 前序遍历：ABCDEFGHK 中序遍历：BDCAEHGKF 后序遍历：DCBHKGFEA 层序遍历：ABECFDGHK 哈夫曼树树的带权路径最小的二叉树叫做哈夫曼树或最优二叉树 例如某二叉树有4个叶子结点a、b、c、d，分别带权7、5、2、4，从根节点到叶子结点的路径都为2，则它们的带权路径长度为 WPL = 7*2 + 5*2 + 2*2 + 4*2 = 36 如何创建？ 从所有的节点中选出两个权值最小的组成一个新的节点A，A与剩余节点再重复上述步骤直到节点使用完。 哈夫曼编码 我们约定左分支表示字符’0’，右分支表示字符’1’，在哈夫曼树中从根结点开始，到叶子结点的路径上分支字符组成的字符串为该叶子结点的哈夫曼编码 AVL树二叉查找树有可能完全退化成了线性结构，即所有节点都是左节点或者右节点。 平衡树通过旋转来保持平衡,而旋转是非常耗时的,由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。 其是二叉查找树并满足二叉查找树性质 任何节点的左右子节点高度差不能够大于1 红黑树红黑树是一种弱平衡二叉树 确保没有一条路径会比其它路径长出两倍 相对于要求严格的AVL树来说,它的旋转次数变少,所以对于搜索,插入,删除操作多的情况下,我们就用红黑树. 特点如下： 节点非黑即白 根节点一定是黑色 每个叶子节点都是黑色的空节点 每个红色节点下的子节点必须为黑色 从任意节点到其每个叶子节点的所有路径都包含相同的黑色节点 在插入后先执行变色，变色到一定程度后无法解决问题再执行旋转 旋转包括左旋转、右旋转 B树 与红黑树相比,在相同的的节点的情况下,一颗B/B+树的高度远远小于红黑树的高度 B/B+树上操作的时间通常由I/O时间和CPU计算时间构成 CPU的速度非常快,所以B树的操作效率取决于访问磁盘的次数 节点存放有key、下一个节点的指针、value B+树 应文件系统所需而产生的一种B树的变形树 非叶子节点只保存索引,不保存实际的数据 数据都保存在叶子节点中 叶子结点中的实际数据通过链表链接在一起，使得遍历整棵树之要遍历叶子结点就行 B+树相对B树的优势 B树的操作效率主要由IO读写次数影响，而由于B+树非叶子结点不存放数据只存放key，那么导致一次io可以从内存中操作更多的节点，因此效率高于b树。 由于只是叶子结点存放内容。那么从根节点查询关键字的路径长度相同，导致每一个数据的查询效率相当 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/19/tree/"},{"title":"分治法、动态规划、贪心算法","text":"分治法将原问题划分成若干个规模较小而结构与原问题相似的子问题，递归的解决这些子问题，然后再合其结果，就得到原问题的解 特征 该问题的规模缩小到一定的程度就很容易解决 该问题可以分解为若干个规模较小的相同问题，即问题具有最优子结构性质 利用该问题分解出的子问题的解可以合并为该问题的解； 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题 动态规划动态规划适用于分解得到的子问题往往不是相互独立的。 有些子问题会被重复计算多次，动态规划通过记录已解决的子问题，可以避免重复计算。 动态规划通常用于求解最优化问题，在这类问题中可能有多个可行解，最终得到的是其中一个最优解。 步骤 描述最优解的结构 递归定义最优解的值 按自底向上的方式计算最优解的值 由计算出的结果构造一个最优解的值 贪心算法通过做一系列的选择来给出某一问题的最优解，对算法中的每一个决策点，做一个当时（看起来）是最优的选择。这种启发式的策略并不是总能产生出最优解。 步骤 将优化问题转化成这样的一个问题，即先做出选择，在解决剩下的一个子问题 证明原问题总是有一个最优解是做贪心选择得到的，从而说明贪心选择的安全性 说明在作出贪心选择后，剩余的子问题具有这样一个性质。即如果将问题的最优解和我们所做的贪心选择联合起来，可以得出原问题的一个最优解。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/19/algo/"},{"title":"布隆过滤器","text":"概念它是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以检查值是 “可能在集合中” 还是 “绝对不在集合中”。 算法原理当你往简单数组或列表中插入新数据时，将不会根据插入项的值来确定该插入项的索引值。这意味着新插入项的索引值与数据值之间没有直接关系。这样的话，当你需要在数组或列表中搜索相应值的时候，你必须遍历已有的集合。若集合中存在大量的数据，就会影响数据查找的效率。 针对这个问题，你可以考虑使用哈希表。利用哈希表你可以通过对 “值” 进行哈希处理来获得该值对应的键或索引值，然后把该值存放到列表中对应的索引位置。这意味着索引值是由插入项的值所确定的，当你需要判断列表中是否存在该值时，只需要对值进行哈希处理并在相应的索引位置进行搜索即可，这时的搜索速度是非常快的。 布隆过滤器（Bloom Filter）本质上是由长度为 m 的位向量或位列表（仅包含 0 或 1 位值的列表）组成，如下所示。 Bloom Filter 0 0 0 0 0 0 位置 1 2 3 4 5 6 为了将数据项添加到布隆过滤器中，我们会提供 K 个不同的哈希函数，并将结果位置上对应位的值置为 “1”。 例如hello经过运算将得到索引位置为2，4，5 Bloom Filter 0 1 0 1 1 0 位置 1 2 3 4 5 6 例如world经过运算得到位置为3，4，5，结合hello后整个过滤器如下： Bloom Filter 0 1 1 1 1 0 位置 1 2 3 4 5 6 我们可以得出一个结论，当我们搜索一个值的时候，若该值经过 K 个哈希函数运算后的任何一个索引位为 ”0“，那么该值肯定不在集合中。但如果所有哈希索引值均为 ”1“，则只能说该搜索的值可能存在集合中。 应用场景 网页爬虫对 URL 去重，避免爬取相同的 URL 地址； 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱； Google Chrome 使用布隆过滤器识别恶意 URL； Medium 使用布隆过滤器避免推荐给用户已经读过的文章； Google BigTable，Apache HBbase 和 Apache Cassandra 使用布隆过滤器减少对不存在的行和列的查找 解决缓存穿透的问题。 参考资料： [1]https://zhuanlan.zhihu.com/p/94433082 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/10/13/bloom-filter/"},{"title":"Eureka原理","text":"简介服务注册中心，包含服务发现、服务治理等。 服务端：提供服务注册服务，缓存服务信息 客户端：服务提供者、服务消费者。会拉取、更新和缓存 Eureka Server 中的服务信息 Eureka Client 和 Eureka Server 可以使用 JSON/XML 格式进行通讯。在默认情况下 Eureka Client 使用压缩 JSON 格式来获取注册列表的信息。 工作流程1、Eureka Server 启动成功，等待服务端注册。在启动过程中如果配置了集群，集群之间定时通过 Replicate 同步注册表，每个 Eureka Server 都存在独立完整的服务注册表信息 2、Eureka Client 启动时根据配置的 Eureka Server 地址去注册中心注册服务 3、Eureka Client 会每 30s 向 Eureka Server 发送一次心跳请求，证明客户端服务正常 4、当 Eureka Server 90s 内没有收到 Eureka Client 的心跳，注册中心则认为该节点失效，会注销该实例 5、Eureka Server 在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，Eureka Server 即会进入自我保护机制。 6、当 Eureka Client 心跳请求恢复正常之后，Eureka Server 自动退出自我保护模式 7、Eureka Client 定时30s全量或者增量从注册中心获取服务注册表，并且将获取到的信息缓存到本地 8、服务调用时，Eureka Client 会先从本地缓存找寻调取的服务。如果获取不到，先从注册中心刷新注册表，再同步到本地缓存 9、Eureka Client 获取到目标服务器信息，发起服务调用 10、Eureka Client 程序关闭时向 Eureka Server 发送取消请求，Eureka Server 将实例从注册表中删除 服务剔除机制 如果开启了自我保护机制，不做操作，不剔除服务 如果未开启，根据 lastUpdateTimestamp 收集已过期的服务，加入到List集合中 服务剔除机制开启，则Eureka服务端并不会直接剔除所有已过期的服务，而是通过随机数的方式进行剔除，避免自我保护开启之前将所有的服务（包括正常的服务）给剔除。 自我保护机制统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，Eureka Server 即会进入自我保护机制。 (1 不再从注册列表中移除过期服务(2 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)(3 当网络稳定时，当前实例新的注册信息会被同步到其它节点中 集群原理 集群相互之间通过 Replicate 来同步数据 不区分主从节点 节点之间互相注册来提高可用性 节点之间状态采用异步方式同步，保持最终状态一致（AP原理） 提供了 Region（地理位置） 和 Zone（机房） 两个概念来进行分区。zone内的服务优先内部同步，否则可以跨zone信息同步。 注册中心收到注册信息后会判断是否是其他注册中心同步的信息还是客户端注册的信息，如果是客户端注册的信息，那么他将会将该客户端信息同步到其他注册中心去；否则收到信息后不作任何操作。通过此机制避免集群中信息同步的死循环。 服务注册（心跳/续约） 客户端启动后创建一些定时任务，其中就有心跳定时任务，通过线程池维护，默认每30s一次 renew方法会发送一个心跳数据到服务端，包括应用名、instanceInfo、instanceInfo的id等 200表示成功，如果返回404则证明服务未注册，需要注册服务 register方法向服务端的注册信息instanceInfo。包括服务名、ip、端口、唯一实例ID等信息。 返回204表示注册成功 服务端保存服务 双层map保存客户端服务。ConcurrentHashMap&lt;String, Map&lt;String, Lease&gt;&gt; 外层map：key是appName,value是服务实例map 内层map：key是服务实例编号，value是服务实例 服务拉取 客户端启动后创建一些定时任务，其中就有服务拉取定时任务 默认每60s拉取一次 每次拉取后刷新本地已保存的信息，需要使用时直接从本地直接获取 获取的方式有两种，全量获取和增量获取。第一次全量获取，后续增量获取；获取到服务器注册实例信息后，保存、或跟新到本地 参考资料 [1]https://blog.csdn.net/u012105931/article/details/104659073 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/25/eureka/"},{"title":"Ribbon原理","text":"简介客户端负载均衡 客户端会有一个服务器地址列表，在发送请求前通过负载均衡算法选择 一个服务器，然后进行访问 如何获取服务列表 通过eurekaClientProvider获取对应EurekaClient（由Spring容器帮忙注入的，并不是由Ribbon主动构造的） 调用EurekaClient获取对应注册表集合信息（EurekaClient是从本地的注册表中获取了指定服务的注册表，其中参数的vipAddress就是我们要调用的服务的appId） 将注册信息组装成DiscoveryEnabledServer列表 将service加到BaseLoadBalancer中的ServersList中 如何更新服务列表定时拉取开启一个后台定时线程，默认延迟1s执行，每30s执行一次 事件通知Ribbon使用EurekaNotificationServerListUpdater实现类进行更新，首先会创建一个Eureka监听器，当接口接受到通知事件之后，会将更新逻辑提交到线程池中执行。 对服务进行心跳检测默认采用了串行的方式进行检测 我们也可以通过自主实现检测结构实现并行的检测 负载均衡策略 策略 描述 RoundRobinRule 轮训策略 RandomRule 随机 RetryRule 重试：选择一个Server，如果失败，重新选择一个Server重试 BestAvailableRule 最小并发：过滤出故障服务器后，选择一个并发量最小的 WeightedResponseTimeRule 响应时间加权轮询 AvailabilityFilteringRule 可用过滤策略：过滤出故障的或高并发的服务实例，然后再以线性轮询的方式从过滤后的实例清单中选出一个; ZoneAvoidanceRule 区域规避策略：从最佳区域实例集合中选择一个最优性能的服务实例 其它介绍 饥饿加载：默认懒加载，意味着只有在发起调用的时候才会创建客户端。可以开启饥饿加载，在项目启动时就完成初始化工作，解决第一次调用慢的问题 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/7/10/ribbon/"},{"title":"feign原理","text":"简介作为HTTP的客户端替代RestTemplate，支持注解的方式 Feign组件中引入了Ribbon和Hystrix组件，这使得Feign也能够为我们提供负载均衡、熔断、降级的功能； @EnableFeignClientsfeign客户端启用注解，目的是加载feign配置到IOC的bean注册表、加载被@FeignClient注解标注的feign客户端bean到bean注册表。 注册feign默认配置：将EnableFeignClients指定的默认配置defaultConfiguration注册到注册表 注册feign客户端：根据@FeignClient注解中的可配置参数注册bean。注意这里的bean只是BeanDefinition（简单意义上的bean），包括url、name、fallback、configuration等内容。 EnableFeignClients详情如下：其中最重要的是FeignClientsRegistrar 12345@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})@Documented@Import({FeignClientsRegistrar.class})public @interface EnableFeignClients {...} FeignClientsRegistrar详情如下：其中最重要的是实现了spring的ImportBeanDefinitionRegistrar接口，目的是自定义的注入feign客户端bean到容器 1234567891011class FeignClientsRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware, EnvironmentAware { ... //实现ImportBeanDefinitionRegistrar的接口 public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { this.registerDefaultConfiguration(metadata, registry); this.registerFeignClients(metadata, registry); } ...} FeignClientFactoryBean上面提到注册feignclient客户端实际上是注册了BeanDefinition到容器，这个BeanDefinition是通过FeignClientFactoryBean来构建的bean。其主要有以下作用： 实现了FactoryBean接口，为bean提供了装饰器模式，使用时是调用的getObject获取 getObject方法返回的是feignclient的代理对象 feignclient代理对象由Builder构造器实现构造 默认的FeignClientConfiguration也是在构建代理对象的过程中加载到feignclient的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class FeignClientFactoryBean implements FactoryBean&lt;Object&gt;, InitializingBean, ApplicationContextAware {... protected Builder feign(FeignContext context) { FeignLoggerFactory loggerFactory = (FeignLoggerFactory)this.get(context, FeignLoggerFactory.class); Logger logger = loggerFactory.create(this.type); //feign构造器获取 Builder builder = ((Builder)this.get(context, Builder.class)).logger(logger).encoder((Encoder)this.get(context, Encoder.class)).decoder((Decoder)this.get(context, Decoder.class)).contract((Contract)this.get(context, Contract.class)); //feignclient配置加载 this.configureFeign(context, builder); return builder; } //实现FactoryBean结构，为feign增加装饰器模式 public Object getObject() throws Exception { return this.getTarget(); } &lt;T&gt; T getTarget() { FeignContext context = (FeignContext)this.applicationContext.getBean(FeignContext.class); //获取feign的构造器 Builder builder = this.feign(context); if (!StringUtils.hasText(this.url)) { if (!this.name.startsWith(&quot;http&quot;)) { this.url = &quot;http://&quot; + this.name; } else { this.url = this.name; } //如果没有ur则走负载均衡 this.url = this.url + this.cleanPath(); //生成代理对象 //1.生成请求客户端，内部用到了ribbon的负载均衡 return this.loadBalance(builder, context, new HardCodedTarget(this.type, this.name, this.url)); } else { if (StringUtils.hasText(this.url) &amp;&amp; !this.url.startsWith(&quot;http&quot;)) { this.url = &quot;http://&quot; + this.url; } String url = this.url + this.cleanPath(); //生成请求客户端，内部用到了ribbon的负载均衡 Client client = (Client)this.getOptional(context, Client.class); if (client != null) { if (client instanceof LoadBalancerFeignClient) { client = ((LoadBalancerFeignClient)client).getDelegate(); } builder.client(client); } //如果有url则走直接链接 Targeter targeter = (Targeter)this.get(context, Targeter.class); //生成代理对象 return targeter.target(this, builder, context, new HardCodedTarget(this.type, this.name, url)); } } ...} feignclient代理对象的生成借助构造器Builder中的build方法实现代理对象生成 入参invocationHandlerFactory可以通过feign配置扩展实现自定义代理实现（可以对请求做一下包装等） 123456789101112public static class Builder { ... public Feign build() { Factory synchronousMethodHandlerFactory = new Factory(this.client, this.retryer, this.requestInterceptors, this.logger, this.logLevel, this.decode404, this.closeAfterDecode, this.propagationPolicy); ParseHandlersByName handlersByName = new ParseHandlersByName(this.contract, this.options, this.encoder, this.decoder, this.queryMapEncoder, this.errorDecoder, synchronousMethodHandlerFactory); //代理生成 return new ReflectiveFeign(handlersByName, this.invocationHandlerFactory, this.queryMapEncoder);} ...} 12345678910111213141516171819202122232425262728293031323334public class ReflectiveFeign extends Feign { ...public &lt;T&gt; T newInstance(Target&lt;T&gt; target) { // 1. Contract 将 target.type 接口类上的方法和注解解析成 MethodMetadata， // 并转换成内部的MethodHandler处理方式 Map&lt;String, MethodHandler&gt; nameToHandler = targetToHandlersByName.apply(target); Map&lt;Method, MethodHandler&gt; methodToHandler = new LinkedHashMap&lt;Method, MethodHandler&gt;(); List&lt;DefaultMethodHandler&gt; defaultMethodHandlers = new LinkedList&lt;DefaultMethodHandler&gt;(); for (Method method : target.type().getMethods()) { if (method.getDeclaringClass() == Object.class) { continue; } else if (Util.isDefault(method)) { DefaultMethodHandler handler = new DefaultMethodHandler(method); defaultMethodHandlers.add(handler); methodToHandler.put(method, handler); } else { methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method))); } } // 2. 生成 target.type 的 jdk 动态代理对象 InvocationHandler handler = factory.create(target, methodToHandler); T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(), new Class&lt;?&gt;[]{target.type()}, handler); for (DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) { defaultMethodHandler.bindTo(proxy); } return proxy;} ...} client与负载均衡构造器Builder中需要指定client，feign有默认的，当然我们也可以自己实现扩展。 client的作用：负责客户端请求、负责是否走负载均衡、请求的底层工具是什么（如HttpURLConnection/okhttp/Apache httpclient） feign默认的请求工具是HttpURLConnection，我们可以自定义 feign负载均衡依赖的是ribbon feign中默认的负载均衡实现是LoadBalancerFeignClient，我们也可以自己实现client 12345678910111213141516171819202122232425public class LoadBalancerFeignClient implements Client { ... public Response execute(Request request, Options options) throws IOException { try { URI asUri = URI.create(request.url()); String clientName = asUri.getHost(); URI uriWithoutHost = cleanUrl(request.url(), clientName); //获取ribbon请求 RibbonRequest ribbonRequest = new RibbonRequest(this.delegate, request, uriWithoutHost); IClientConfig requestConfig = this.getClientConfig(options, clientName); //执行客户端负载均衡 return ((RibbonResponse)this.lbClient(clientName).executeWithLoadBalancer(ribbonRequest, requestConfig)).toResponse(); } catch (ClientException var8) { IOException io = this.findIOException(var8); if (io != null) { throw io; } else { throw new RuntimeException(var8); } } } ...} 执行流程第一步：代理对象的生成 添加EnableFeignClients注解，将feign配置类以及feign客户端注入到容器 feign客户端增加了装饰器模式和构造器模式，效果是可以自定义httpclient、编码器、解码器等 通过Spring IOC 容器实例，装配代理实例，然后进行远程调用 第二步：代理方法执行 执行 InvokeHandler 的invoke(…)方法 InvocationHandle，内部保持了一个远程调用方法实例和方法处理器的一个Key-Value键值对Map映射dispatch。调用的时候从dispatch中找到MethodHandler 方法处理器 MethodHandler方法处理器调用feign对象的client进行远程方法调用 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/25/feign/"},{"title":"springboot简介","text":"简单概括springboot是对spring框架的优化，用于快速、便捷、高效的创建企业级spring应用，避免繁琐的配置工作。 特点1.能够快速创建基于Spring的应用程序。（简化配置） 2.能够直接使用java的main方法启动内嵌的Tomcat，Jetty服务器运行Spring boot程序，不需要部署war包文件。 3.提供约定的starter POM来简化来简化Maven配置，让Maven配置变得简单。 4.根据项目的maven依赖配置，Spring boot自动配置Spring,SpringMVC等其它开源框架。 5.提供程序的健康检查等功能。（检查内部的运行状态等） 6.基本可以完全不使用xml配置文件，采用注解配置。（或者默认约定的配置，代码中已经实现） var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/12/sb-intro/"},{"title":"springboot项目启动原理","text":"我们开发任何一个Spring Boot项目，都会用到如下的启动类，从上面代码可以看出，Annotation定义（@SpringBootApplication）和类定义（SpringApplication.run）最为耀眼 123456@SpringBootApplicationpublic class Application {public static void main(String[] args) {SpringApplication.run(Application.class, args);}} @SpringBootApplication123456789101112@Target(ElementType.TYPE) // 注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明@Retention(RetentionPolicy.RUNTIME) // 注解的生命周期，保留到class文件中（三个生命周期）@Documented // 表明这个注解应该被javadoc记录@Inherited // 子类可以继承该注解@SpringBootConfiguration // 继承了Configuration，表示当前是注解类@EnableAutoConfiguration // 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助@ComponentScan(excludeFilters = { // 扫描路径设置（具体使用待确认）@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication {...} 重要的只有三个Annotation： @Configuration（@SpringBootConfiguration点开查看发现里面还是应用了@Configuration） @EnableAutoConfiguration @ComponentScan @Configuration指示一个类声明一个或多个@Bean方法，并且可以由Spring容器处理。指示类为ioc容器配置类。 通常使用AnnotationConfigApplicationContext或其支持Web变体AnnotationConfigWebApplicationContext进行引导。 1234AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();ctx.register(AppConfig.class);//AppConfig为标注了@Configuration的类ctx.refresh();MyBean myBean = ctx.getBean(MyBean.class);//AppConfig类中声明的bean @ComponentScan目的是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。 我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。 注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。 @EnableAutoConfiguration帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot，并创建对应配置类的Bean，并把该Bean实体交给IoC容器进行管理。 12345678910@SuppressWarnings(&quot;deprecation&quot;)@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage //自动配置包，自动配置被标注类的同级及子级包组件@Import(EnableAutoConfigurationImportSelector.class) //导入自动配置的组件public @interface EnableAutoConfiguration {...} 最关键的要属@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。就像一只“八爪鱼”一样。 SpringApplication执行流程大体如下： 信息收集：是否创建应用程序上下文（ApplicationContext）、有哪些上下文初始化器（ApplicationContextInitializer），有哪些应用监听器（ApplicationListener） 环境创建：包括配置要使用的PropertySource以及Profile，并调用监听器的environmentPrepared()方法进行告知。 应用程序上下文创建：创建ApplicationContext并调用初始化方法初始化，如contextPrepared()方法、contextLoaded()方法等 刷新应用程序上下文：调用refresh()方法进行刷新，并调用监听器finished()方法进行通知 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/12/sb-start/"},{"title":"spring中AOP的实现原理","text":"什么是AOP面向切面编程，一种编程思想，是srping的核心之一。 本质是由 AOP 框架修改业务组件的源代码，为系统中的业务组件添加某种通用功能。 按照 AOP 框架修改源代码的时机，可以将其分为两类： 静态 AOP 实现：AOP 框架在编译阶段对程序源代码进行修改，生成了静态的 AOP 代理类，比如 AspectJ。 动态 AOP 实现：AOP 框架在运行阶段对动态生成代理对（借助动态代理实现），如 SpringAOP。 AOP术语 通知/增强（Advice）: AOP 框架中的增强处理。描述切面何时执行以及如何执行。 前置增强 环绕增强 异常增强 返回值增强 连接点（join point）:增强执行的位置。在 Spring AOP 中，连接点总是方法的调用。 切点（PointCut）: 具体的连接点。 切面（Aspect）: 切面是增强和切点的结合。 引入（Introduction）：特殊增强，向现有的类添加新的方法或者属性。 织入（Weaving）: 将增强添加到目标对象中，并创建一个被增强的对象。织入分为如下三个时期： 编译期：AspectJ 类加载 运行期：spring的动态代理 Spring如何选择是用JDK还是cglib？1、当bean实现接口时，会用JDK代理模式 2、当bean没有实现接口，会用cglib实现 参考资料 https://www.cnblogs.com/joy99/p/10941543.html var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/12/aop/"},{"title":"spring中IOC实现原理","text":"简介通过spring我们无需手动创建对象，对象的创建与生命周期管理交由spring实现，当我们需要使用对象实例时只需要通过spring获取即可。spring利用IOC（控制反转）实现对Bean的管理。 简单来说IOC就是把对象创建和对象之间的调用过程交给Spring框架进行管理，调用方只负责使用。 目的：降低耦合度 IOC是spring中的核心 底层原理 xml配置/注解：定义bean名称、属性等，为后面的反射获取bean打下基础 反射：通过解析xml或者扫描注解来获取bean注册信息，根据反射来获取bean对象 工厂模式：bean创建由工厂完成，提供getbean方法，spring容器中借助BeanFactory完成 **IOC底层就是对象工厂**，Spring框架中对IOC容器实现提供了两种方式（即两种接口） BeanFactory：IOC容器的基本实现，容器加载时不会创建对象，使用时才会创建。不对开发人员开放 ApplicationContext：是BeanFactory的子接口，对开发人员开放，此接口在加载配置文件时就会创建配置文件中所配置的对象 加载逻辑 第一步-bean配置信息：xml、java类、注解等 第二步：读取bean配置信息到spring容器中的注册表 第三步：根据注册表利用反射+工厂模式实例化bean 第四步：将实例化bean放入缓存池（HashMap实现） 第五步：应用程序获取bean 当容器关闭时，销毁（需要配置） 其它内容 IOC与DI是什么关系？同一概念的不同角度描述。对象的控制交由容器完成这是IOC，调用方需要的依赖由容器实现注入这是DI（依赖注入） DI的实现方式：主要有两种，第一是通过类中定义的set方法进行注入，第二是通过有参构造方法进行注入 Spring中的bean模式是单实例的 如何设置bean多实例：在Spring配置文件bean标签中有属性scope用于设置单实例还是多实例，singleton（单实例） prototype（多实例）。单实例在加载配置文件时就会创建，多实例在调用getBean方法时创建。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/12/ioc/"},{"title":"MBR与GUID格式","text":"硬盘分区格式为MBR格式，启动模式应该为Legacy； 硬盘分区格式为GUID（GPT）格式，启动模式应该为UEFI。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/22/mbrguid/"},{"title":"工作小感悟","text":"记录工作、职业相关的一些小感悟 1、要能发现自己的成长点。做能够使自己成长的工作、进能使自己成长的公司，否则就是浪费时间。这个成长可以是软实力，如交际能力、人脉关系扩展等，也可以是硬实力，如技术能力、管理能力等。 2、为什么会焦虑？如何解决焦虑？ 焦虑产生的原因主要有三点：不清楚什么是最重要的、没有目标、不自信 克服焦虑的方法也很简单： 要学会放得下，只有身体健康和家人才是最重要的，其他的都是身外之物 制定切实可行的目标并紧盯目标 没有谁是生下来的强者，也没有谁是注定的弱者，不自信的根源是自己的认知出现问题、自己的能力出现瓶颈，最好的解决方法就是不断学习，不断提升自己。 3、如何进入理想的公司/行业？ 选择是双向的，你可以选择对方，对方也可以选择你。 问题的本质是如何被选中？其实说来也简单，就是不断增加自己的“长处”。自己的短板和一般的能力并不影响大局，只有自己的长板足够长并且符合企业所需那么就一定会被选中。 4、工作中急需提升的软硬实力？硬实力：面对复杂问题的层层细致拆解（寻找问题本质）软实力：职场交际中做到坦然的笑着面对 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/5/29/work-think/"},{"title":"面试方案","text":"前言 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/5/3/interview/"},{"title":"二十四史-吕后本纪","text":"吕后这个历史人物具有复杂的多面性，首先具有女人母性的一面，护子，顾家，嫉妒，争宠。其实还有很强的政治头脑，排除异己，巩固权利，政治手腕很辣。 吕后末年扶持吕室一族，外戚专权，即使死后也希望吕家人能够位高权重甚至取代刘室，但严重误判了形式。 其一是高估了吕室的能力，即使手握兵权但德不配位 其二是低估了刘室忠臣的忠诚度，因此在内忧外患之下失败在所难免。 如果要让吕室彻底篡权必须安内攘外，对内培养氏族中有能力的人做到内部团结，对外将不可控因素全部消灭，瓦解外部对抗势力的团结。 当然吕后也可以选择另外的道路既安心做刘室的外戚，做个忠臣获得好名声也不错。做到这一点必须要权利下放给皇帝孝惠帝，不能刻意扶持吕室。但这点太难做，得到的权利想要放下简直是割肉！ 给我们的警醒是: 成事必须保证内部团结，扫除外部不可控因素 正确判断形式，考虑人的影响，揣摩人心 明确目标与思路，摒弃个人私心 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/9/21/lvhou/"},{"title":"二十四史-吴太伯世家","text":"太伯与弟弟仲雍都是周太王的儿子，为了让位给自己的亲兄弟季历主动离开周来到了荆蛮，也就是现在的无锡一带，为了表达不能继承王位不与季历争权的决心，太伯与仲雍主动纹纹身，剪去头发，这样就不能继承周王位。 太伯为什么极力让贤呢？这是因为当时的周太王之孙，季历只子为姬昌，也就是之后的周文王，姬昌贤明，传位给季历可以在之后让姬昌继承王位。 后来武王伐纣建立周朝，寻找太伯的后人，并将其后人封在了吴地，就是现在的无锡，建立了吴国。吴国最后是在吴王夫差的手上被越王勾践给灭了国。总的来说吴国灭国有内外两重因素！ 对内 夫差连年征战且多胜，有点妄自尊大，不听信贤臣伍子胥的良言没有重视越王勾践。 连年征战人民疲惫，国力开始衰弱 内部不团结，自己的弟弟趁自己出国的时机在国内自立为王，内乱伤了国力 对外 没有认清局势，看不清危机，认识不到真正的敌人，真正的敌人是一定要治你于死地而后快的。 连年对外战争，没有大的战略，不知道为了什么而打仗。 越王勾践攻打吴国时自己确杀亲信以封锁消息，掩耳盗铃 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/9/21/wutaibo/"},{"title":"二十四史-文景之治","text":"孝文帝贤德，在位期间着重发展国内民生。 改革法律，废除严刑酷法 减免徭役赋税，减轻农民负担 鼓励开垦土地增加粮食产量 对外联姻匈奴，韬光养晦 讲到韬光养晦我突然想起金灿荣教授讲解的关于我国韬光养晦的政策。在2008年之前党中央领导层一直在强调韬光养晦，所谓韬光养晦是低调形式、关注自身发展。美国人确把韬光养晦翻译成“卧薪尝胆”，这是完全不对的。 为什么我们现在不再提韬光养晦了，这是因为我们国家变的强大了，无法躲藏，更无法实现韬光养晦。总的来说邓小平时期题出的韬光养晦策略帮助我国度过了一段艰难的时期，索性在这个阶段又有本拉登的帮忙、阿拉伯之春的帮助、新冠肺炎的帮忙，我们国家会越来越强大。 孝景帝谋略，在位期间实行推恩令削弱诸侯力量。 景帝时期最大的问题依然是内忧，各诸侯依然强大，诸侯的强大势必会削弱中央的力量，中央没有办法完全掌控各诸侯国，并且有内乱风险。 遇到这种境遇我们大多数人都会认命了，误解了。这里不得不佩服古人的智慧，景帝采用了贤臣的谏言施行推恩令，这个法令的主要目的是允许各诸侯可分封自己的儿子等近亲，推恩令施行后各诸侯力量分散，不易形成威胁中央的政权。 孝景帝时期解决了帝国内部最大的隐患，使国内空前统一团结。 文景之治功劳不在壤外而在安内，为之后的汉武帝壤外打下了基础。因此需要我们学习的是，真正的强大，真正的挺直腰板是建立在内部团结，建立在自强的基础上的！ var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/9/21/wenjing/"},{"title":"二十四史-汉高祖","text":"沛公之所以成功靠的就是识人善用，自己没才能不要紧但是要有用人的才能。那么问题来了，怎么才能用人或者说别人让你用呢？ 我思来想去无非做到两点: 第一是自身强大，也就是说自己首先要有才能，这个才能可以是为人技巧，处事技巧，演说，内在品德，坚韧，执着，和蔼可亲等等。 第二是在有才的基础上造势，既表面功夫要做好，要让别人知道你很强，获得别人的仰慕。人都是逐利的，跟着你的唯一理由就是你给了他们希望，给了他们身体或心里需要的东西！得道者多助，失道者寡助！ 简单聊一下第一点，为什么想要有成就必须注重自身的修养？ 人的本性都是趋利避害的，这里的利放在人际关系中就是品德高尚、有修养的人。我们每个人在这一生中都会经历各种各样的人，有的人会让你感觉交往很自然舒适，也有一些人会让你感觉总有一种距离感。这就是交往双方的修养相互作用的结果。试想一下，如果交往对象是一个懂礼貌、谦让、和蔼可亲、爱笑这样的一个人，是不是我们更愿意与其交往，在遇到机遇或者挑战的时候是不是更希望与其分享？ 所以，想要有所成就人际关系和机遇必不可少，而这两者的产生会受到个人修养的极大影响，因此我们必须注重自身修养。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/9/21/hangaozu/"},{"title":"二十四史-秦本纪-秦灭亡有感","text":"夺取天下和治理天下的策略本应不同 嬴政能够成为始皇帝统一天下并不是一个人的功劳，从秦襄公开始被分封为诸侯到始皇帝统一天下，可以说没有一位皇帝是贪图享乐的，每一任秦王都在努力经营好自己的封地。这个过程中诞生出数不胜数的英雄人物，其中不得不提的是贡献巨大的四大名相，这里简要说一下。 商鞅 尽人皆知的商鞅变法从内部彻底解决了阻碍秦国向外扩张的内部矛盾，削弱了贵族的权利，还利于国，处使国内空前统一稳定团建，为之后历代秦王的对外扩张政策打下了基础。 张仪 张仪则是依靠“合纵连横”的对外策略使秦国外部环境由暗转名，化解了战国各国对秦国的侵略。 范睢 远交近攻策略使得秦国由被动转向主动，灵活高效的开拓领土。 吕不韦 成为相国后先后为秦国收取了广袤的土地，使得秦国越发强大，六国更加难以遏制秦国的崛起。 从四位名相的治国策略我们也可以看出，一环套一环，一步步稳扎稳打，解决国内矛盾使得秦国不被内部环境所制约，国力逐渐强大。紧接着挑拨敌人的内部矛盾，使得对方困于内，最后乘胜追击，在敌弱我强的趋势下一统六国。 秦国强盛始于内，衰弱也始于内。 就像本文开始所说，夺取天下与治理天下本不同。在夺取天下后如果还是照搬照套原来的治国方略，还是将非秦地的人民看作奴隶或敌人又怎么能谈得上长久的统一。秦始皇的刚愎自用，不信任有才能到人，不亲近人民，不讲仁义道德，徭役赋税刑法过重，在秦二世胡亥治理下的秦国由于受到赵高的蛊惑，徭役服输以及历法已经到了压迫的顶点，人民不得不反。 国家/团体/组织等最艰难的时刻之一一定包含初创期，这个时期形成的制度，规范，默契，组织架构，使命，宗旨，用人等方方面面将深刻入灵魂，不会被轻易改变，而灭亡也常常是因为这些内因。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/2/20/china/"},{"title":"二十四史-霸王覆灭有感","text":"哀其不幸，怒其不争可以很好的概括项羽的悲情经历了。 项羽能称霸王靠的是继承项梁的衣钵，其本人又有勇有谋，屡立战功，最终树立了威信成为反秦力量中最强大的一只。 这里不得不说成为一个富二代的重要性，人们常说穷不过三代，这是对的，因为三代后穷人都没了，富可以过三代。成为富人也并非一朝一夕，更多的是要依仗父辈打下的基础，就如同项羽在项梁战死后成为新的反秦先锋，兵多将广且占据道德高地。 项羽败在眼界狭隘 “富贵不还乡如锦衣夜行”这是项羽在灭掉秦国成为起义军名副其实的霸主后所说的话。按照我们当下的上帝视角来看，应该取代秦国建立另外一个大一统的国家，比如新楚国、项国、羽国等等。但项羽没有这样做，而是选择建都彭城自立为霸王并以霸王的名义分封天下，走的还是周王朝的分封制。现在看来这是没有战略眼光，没有远大志向的行为表现，贪图眼前的虚荣，放弃关中要地而建都彭城错失战略先机。 项羽败在内部矛盾 韩信曾在项羽麾下任职，其评价项羽相对客观，其中谈霸王对权利的掌控欲时说到“下属立功本应封赏，早已篆刻好的官印却被霸王攥在手里反复把玩，直到磨平了棱角也舍不得送出”。在对待手下方面也具有两面性，霸王常亲自看望受伤或病重的手下，每到情不自己处不由的落下泪来，而对待犯了错的下属或者占领区的人民却极其的残虐暴力，无不杀之而后快。 在刚开始的队伍中项羽手下不乏有才有智之士，但不重用他们，对自己的文韬武略盲目自信，听信谗言，自断双臂驱逐范增，至此再没有人能够进忠言，全凭自己的决断 作战刚愎自用，残虐暴力导致失去民心，天下人反叛，处处与之为敌。 项羽败在外部困局 倚仗自己的武力，在未取得天下权利和天下人心的时候分封诸侯导致自己成了天下诸侯的敌人。将好的土地分封给与自己亲近的弱者，而将蛮荒之地分封给外部势力，这种做法极大的激发了外部矛盾。 项羽败在豪杰义气 兵败乌江，不思悔改，认命自刎。 胜败乃兵家常事，只要活着就还有希望，人死了就什么都没有了。即使到了兵败乌江的最后时刻，项羽依然为了自己的自尊心不肯渡江，认为是天要亡他，而不是自己的作战不利，不思悔改，不足怜悯。 项羽是被世俗大义囚禁了思想的莽夫，不值得同情！反思一下，做领导的一定要知人善用，看清形式，长远规划，内部团结！！！ var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/2/20/xiangyu/"},{"title":"嗜血的皇冠读后感","text":"前记 以强胜弱易，以弱胜强难！然人生多逢强敌，若想取胜必知己知彼，多策共施，非一策所得也！ 击溃敌人的并不是外部因素而恰恰是敌人自己！ 所思所感汉朝是个令人向往的朝代，西汉的历史典故最为人熟知的便是刘邦、项羽之争，期间的各种事迹也多被文学、影师作品宣扬的尽人皆知。但汉朝是分为西汉和东汉的，相比于西汉，东汉却显的默默无闻，为什么会这样？东汉与西汉到底是什么样的关系？东汉又是如何做到中兴的？种种问题勾起了我的好奇心，因此特意拜读了“嗜血的皇冠”这本书。 刘演说到刘秀必然要先说他的哥哥刘演，刘演这个历史人物更类似与项羽，其对推翻新莽政权恢复汉室从始至终都充满了强烈的欲望，刘演之志天下皆知。说他类似项羽是因为这个人物还是有很多优点的，例如有勇有谋、果断、豪放、仗义疏财、不拘小节、知大义。但同样也有缺点而且是致命的缺点，例如过于自信乃至自负、容易意气用事、过于相信别人… 害人之心不可有，防人之心不可无。 要学会知人善用 刘秀整体读下来刘秀给我的感觉还是挺中庸的，没有锋芒毕露的才能，没有令人鄙夷的弱点，整体感觉就像是个普通人。但如果细细回想发现刘秀并不像外部表现的这样，他还是有很多超出常人的有点的。 甘于平庸：在跟随哥哥起义之前，自己甘心做多年农民，踏踏实实等待时机，这种隐忍和耐力超出常人 忍辱负重：哥哥刘演被杀后，忍受极大的悲伤和愤怒向仇人俯首称臣，自甘人臣并表现的胸无大志，这种演技和隐忍令人配符 知人善用：善用人、敢用人，又是刘秀另外一大优点，用人不疑，一人不用。邓奉、冯异、云台28将帮助刘秀夺取天下 审时度势：刘秀每一步走的都很稳，这个稳就体现在他的审时度势上，没做一个决定必定要蛰伏，等待最佳时机出手，这一点也是令人难以企及。就像买股票一样，一般人看到大涨早就安奈不住去跟进了，却不是这是割韭菜前期的造势。 拿得起放得下：当胜券在握，天下大局一定时对待昔日愁人能够做到放下恩怨，以大局为重 总的来讲，刘秀胜就胜在一个子“稳”，每一步每一次都很稳。 王莽王莽这个历史人物挺神奇的，在之前不了解历史的时候仅仅通过网络的传播真的以为王莽是未来人穿越过去的，为什么这么说呢？因为他超前的实现了社会主义，你没听错真的是社会主义。他将土地收归国有、平均地权、给人民放贷款、创造了最早的游标卡尺… 话说回来，王莽起家有借助家族势力的因素但更多的是靠自己的才能。年轻时的王莽有学识、有品德、有威信，在汉室衰败后能够建立新朝并使天下臣民甘于臣服，证明他的才能。或许是王莽时运不济，在新朝末年，天下大旱，多灾多难，流民四起，对王莽的统治产生了极大的影响，同时年迈的王莽自身问题也有很多，例如： 内部叛乱 亲人近臣屠杀殆尽 沉迷修仙 轻视流民 制度过于超前导致损害各诸侯利益 攘外必先安内，最大的敌人往往并非外因而是内困，纵观历史，所有强大国家/团体的覆灭必定起于内因。 其它 赤眉军：无战略、无纲领、无根据地，脱离群众，战乱年代尚可苟活，混吃等死，各处征战。 绿林军：各地豪强与流民的组合，无纲领，但不乏有志之士，缺点就是内部极度分化。 蜀国（公孙述）：认不清形势，偏居一隅，晚年注重享乐，本质还是内溃与自身。 邓奉：具有大才能，有才、有胆、有勇、有谋，但缺乏大志向，拘泥于儿女情长，感情用事，此人比刘演更像项羽。 邓禹：大才子，治国好手，打仗一般。每个人都有自己的长短处。 刘玄：最失败的傀儡皇帝，没有想方设法夺取权力反而在末年注重享乐，干预沉沦，乐不思蜀。 隗嚣（wěi áo）：有公孙述的胆没公孙述的才，认不清形势，不善任用贤能。 苏茂：如果能学会刘秀的忍耐，也不必落得身首异处的结果。被逼无奈造反，结果可想而知。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/7/30/liuxiu/"},{"title":"富爸爸穷爸爸-读后感","text":"背景2020年的新年是令人难以忘记的，全中国的人民都没有想到这个假期会这么长，更没有想到过假期的方式会是呆在家里。以前期盼已久的宅在家里不上班终于实现了。这段时间刚开始还是非常幸福的，但随着时间的延长自己慢慢觉得无比的无聊，怀念自己忙碌的时光，人就是这么贱，得不到的永远是最好的。也许是无聊的太久了不知道自己抽了什么风脑袋里蹦出一句话“看书学习是对自己最好的投资”，自此自己走上了看书的不归路，买了一个官翻kindle，下载各种自己感兴趣的书。富爸爸穷爸爸并不是我读的第一本书，但却是我第一次认真读完并思考的书，希望以此为开端继续用知识投资自己。 简介富爸爸穷爸爸这本书我相信很多朋友都读过，出版的也比较早，他主要讲述了主人公从年少开始如何一步步实现财务自由实现理财的，其中的一些观点非常接地气，很适合年轻人以及开始想要理财、管理自己人生的朋友去读。 读后感 资产：什么是资产？能够不断把钱带到你口袋里面的就是资产 负债：什么是负债？能够不断把钱从你口袋拿出来的就是负载 富人和穷人的区别：富人投资资产，穷人投资负债 现金流：现金流简单来说有四大块组成，收入、支出、资产、负债，个人或家庭必须能够梳理出金钱在这四者之间的流转关系，开源节流投资资产才是致富之道。要学会用资产和现金流来满足自己的欲望 要有目标：无论是理财目标还是人生目标必须要树立，可以分阶段 饥渴感：要有自己渴望实现的事情或得到的东西，要对自己的目标有饥渴感，这样行动起来才会更加顺利 路：书中有句话我很喜欢”轻松的路越走越艰难，艰难的路越走越轻松“ 金钱的选择：你把钱用于消费那么你就会成为穷人，你把钱投入负债你就会成为中产阶级，你把钱投入资产你将成为富人 行动：只有思考和想法是不够的，要用于实践，一定要行动，一定要勇于试错。可以找本好书或者报个好的机构去学习理财知识并马上付诸行动 学习：你能够学到的任何东西当你学到时就已经是过时的了，关键在于如何快速学到更多的东西 商业模式：任何生财之道都离不开商业模式，社会在变化商业模式更是千变万化，我们理解一些商业模式并用发现的眼光去发现其它的商业模式 发现的眼光：任何时代都有发财的机会，关键在于你是否足够有耐心去发现事物在不变中发生的微妙变化，有变化就有新的机会产生 财商：财商包括财务知识、市场知识、发现的眼光、商业思维等等，在日常生活中需要逐步培养自己的财商 技能：开创事业最主要的三种技能，现金管理、人事管理、时间管理 自律：自律是做成任何事情的基础，如果自律都无法实现更谈不上发财 胆量：有胆量不随大流才能致富，你也许并不弱，但是一旦涉及金钱就会变得怯懦 听从自己：自己认准的事情就勇敢去做，不要被其它”噪音“所影响，能发财的永远是少数人，你为什么要听大多数人的噪音呢 储蓄：穷人有很多不好的习惯，其中的共同点是他们很轻易的动用自己的储蓄 时间和思考：时间和思考对待每一个人都是平等的也是最宝贵的 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/3/5/richPoorDad/"},{"title":"月亮与六便士读后感","text":"读这本小说也是一个偶然的机会，因为每天上下班四小时都在路上，坐地铁玩手机实在是浪费生命因此想找一些指导人生的书记，月亮与六便士恰好出现。 原本以为这是一本讲述如何励志，如何对待未来对待生活的书籍，但当我真正去拜读的时候发现却是一本人物传记小说，小说整体不算太长如果连续阅读我相信6个小时就可以读完。这本小说主要讲述了男主人公从一个大家眼中的人生赢家（金融类经理，出身名门，妻女成群，上流生活）变为落魄画家最后客死他乡的故事。作者以第三视角“我”的叙述方式通过与主人公相识的人口述进行刻画。 不得不赞叹作者的文采，人物描述非常的细致，细节处理非常流畅，让读者脑海中能够想象完整的场景，犹如身临其境。对书中涉及到的人物举止、性格等并非仅仅通过主观刻画，而是采用第三方类比的方式刻画。 针对主人公，我从刚开始的不理解到后面的讨厌再到最后的敬佩，整个心里路程跌宕起伏。是的一个伟人在我们普通人严重必须是有教养、有道德、有才华、有品行的圣人，但是主人公却给我呈现出另一幅景象。他是自私的、狭隘的、卑鄙的，但又是坚韧的、不屈的、勇敢的。是啊，人本身就是复杂的生物，人有多面性很正常，我们不能用自己的标准去衡量别人。主人公前40年全身心投入事业为了家庭而奋斗，40岁毅然决然离开妻子儿女，离开上流生活，为的只是实现自己追求的精神境界“月亮”。即使饥寒交迫，即使被人冷嘲热讽被人不理解，但一切的外部因素都无法影响他，在他的世界里只有画画，画出自己真正最求的精神真理。 试想一下，现在这个快节奏、物欲横流的社会，能有几个人有这等气魄能够舍弃一切为了理想？当然我也不建议大家这么做，月亮确实可贵，但六便士也要得到，生活并非非黑即白，有时候像月亮妥协有时候像六便士妥协，或许这才是能够真实实践的人生。 只要人还在一切都还有希望，不要被外部环境影响，要时刻盯紧你的目标并为之奋斗！！！ 下面摘抄一些书中文字： 有人说灾难不幸可以使人高贵，这句话不对；叫人做出高尚行动的有时候反而是幸福得意，灾难不幸在大多数情况下只能使人变得心胸狭隘，报复心更强。 为什么你认为美，世界上最宝贵的财富，会同沙滩上的石头一样，一个漫不经心的过路人随随便便就能捡到？ 我不想过去，对我来说追重要的是永恒的现在 我认为有些人诞生在某一个地方可以说未得其所。机缘把他们随便抛掷到一个环境中，而他们却思念着一处他们自己也不知道落在何处的家乡。 是否成功，人生是否有意义并非靠金钱来衡量，这一切都取决于一个人如何看待生活的意义，取决于他认为对社会应该尽什么义务，对自己有什么要求。 我们并不是野心勃勃，如果说我们也有骄傲的话，那是因为在想到通过自己的双手获得的劳动成果时的骄傲。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/7/5/moon/"},{"title":"AQS原理","text":"简介AbstractQueuedSynchronizer,简称AQS，AQS是一个用来构建锁和同步器的框架 ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。 数据结构 volatile int state（代表共享资源） Queue：一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列） state的访问方式有三种 getState() setState() compareAndSetState() 资源共享方式 Exclusive（独占，只有一个线程能执行，如ReentrantLock） Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch） 自定义同步器实现方法自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。 自定义同步器实现时主要实现以下几种方法： isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。 tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 案例解读 以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。 以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/19/aqs/"},{"title":"ArrayList原理","text":"简介 是一个数组队列，容量能动态增长 继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable等接口 实现了RandmoAccess接口，即提供了随机访问功能，我们可以通过元素的序号快速获取元素对象 实现了Cloneable接口，能被克隆 实现java.io.Serializable接口，能通过序列化去传输 操作不是线程安全的 数据结构 elementData：是”Object[]类型的数组”，支持动态增长。若使用默认构造函数，则ArrayList的默认容量大小是10。 size：动态数组的实际大小 扩容方案：ArrayList会重新设置容量：新的容量=“(原始容量x3)/2 + 1”，比当前容量的一半多一个。数据会被拷贝到新数组中。 遍历方式 迭代器：效率低 随机访问：效率较高 for循环 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/13/arraylist/"},{"title":"BeanFactory和FactoryBean","text":"BeanFactoryBeanFactory是IOC最基本的容器，负责生产和管理bean，它为其他具体的IOC容器提供了最基本的规范，例如DefaultListableBeanFactory和ApplicationContext等。 FactoryBeanFactoryBean是一个接口，当在IOC容器中的Bean实现了FactoryBean后，通过getBean(String BeanName)获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的getObject()方法返回的对象。要想获取FactoryBean的实现类，就要getBean(&amp;BeanName)，在BeanName之前加上&amp;。 FactoryBean可以说为IOC容器中Bean的实现提供了更加灵活的方式，FactoryBean在IOC容器的基础上给Bean的实现加上了一个简单工厂模式和装饰模式，我们可以在getObject()方法中灵活配置 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/8/bean-factory/"},{"title":"CAS原理","text":"什么是CASCAS的全称是Compare And Swap 即比较交换，它将指定内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 CAS具有原子性，可以实现多线程同步 CAS就是乐观锁的典型代表 执行函数：CAS(V,E,N) V表示要更新的变量 E表示预期值 N表示新值 更新逻辑 V==E表明变量符合预期值，可以对其进行更新。将V设置为N V!=E证明有其他线程已经做了更新，本次线程不进行操作。可以读取E值重复一次 ABA问题如线程1从内存X中取出A，这时候另一个线程2也从内存X中取出A，并且线程2进行了一些操作将内存X中的值变成了B，然后线程2又将内存X中的数据变成A，这时候线程1进行CAS操作发现内存X中仍然是A，然后线程1操作成功。虽然线程1的CAS操作成功，但是整个过程就是有问题的。比如链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。 所以JAVA中提供了AtomicStampedReference/AtomicMarkableReference来处理会发生ABA问题的场景，主要是在对象中额外再增加一个标记来标识对象是否有过变更。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/18/cas/"},{"title":"ConcurrentHashMap原理","text":"JDK1.7版本原理分段锁机制简而言之，ConcurrentHashMap在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。因此，ConcurrentHashMap在多线程并发编程中可是实现多线程put操作。 Segment继承了ReetrantLock，表示Segment是一个可重入锁，因此ConcurrentHashMap通过可重入锁对每个分段进行加锁。 数据结构 Segment数组：key/value数组，key存放hash值，value存放指向“分段”的指针，分段类似hashtable 分段：类似hashtable，是一个HashEntry的数组 分段元素HashEntry：内部包含hash值、key、value、next。单项链表 初始化 第一步初始Segment数组：构造函数中的参数concurrencyLevel用来初始化数组。在初始化时创建了两个中间变量ssize和sshift，它们都是通过concurrencyLevel计算得到的。 ssize表示了segments数组的长度，在初始化时通过循环计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为数组的长度。 sshift表示了计算ssize时进行移位操作的次数 第二步初始化分段：构造函数中的initialCapacity和loadFactor用来初始化分段。前者规定了每个分段的初始化长度，后者规定了加载因子。通过分段数组长度*loadFactor获得每个Segment的阈值threshold. 默认情况下，initialCapacity等于16，loadFactor等于0.75，concurrencyLevel等于16. JDK1.8版本原理简介通过分段锁机制其最大并发度受Segment的个数限制。因此，在JDK1.8中选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现。 数据结构 数组：一个table数组，其类型是一个Node数组 链表：Node是一个继承自Map.Entry&lt;K, V&gt;的链表，果元素所在的红黑树节点个数小于6，则会触发红黑树向链表结构转换。 红黑树：链表结构中的数据大于8，则将数据结构升级为TreeBin类型的红黑树结构 初始化 通过初始容量initialCapacity，加载因子loadFactor和预估并发度concurrencyLevel三个参数计算table数组的初始大小sizeCtl的值 hash表的初始化是在插入第一个元素时进行 其它说明 Hashtable对get,put,remove都使用了同步操作 ConcurrentHashMap只对put,remove操作使用了同步操作 Hashtable在使用iterator遍历的时候，如果其他线程，包括本线程对Hashtable进行了put，remove等更新操作的话，就会抛出ConcurrentModificationException异常，但如果使用ConcurrentHashMap的话，就不用考虑这方面的问题了 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/15/con-hashmap/"},{"title":"ConcurrentSkipListMap原理","text":"SkipListSkip list让已排序的数据分布在多层链表中，通过“空间来换取时间”的一个算法，在插入、删除、查找时可以忽略一些不可能涉及到的结点，从而提高了效率。 其插入和查找的效率O(logn)，其效率不低于红黑树，但是其原理和实现的复杂度要比红黑树简单多了。 特性 由很多层结构组成，level是通过一定的概率随机产生的 每一层都是一个有序的链表，默认是升序，也可以根据创建映射时所提供的Comparator进行排序，具体取决于使用的构造方法 最底层(Level 1)的链表包含所有元素 如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现（换句话说上层元素是从下层元素中挑选出来的） 整体结构类似一个金字塔类型，通过每层的索引从上层向下层跳跃查询 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素 插入操作 查找合适的位置。这里需要明确一点就是在确认新节点要占据的层次K时，采用丢硬币的方式，完全随机。如果占据的层次K大于链表的层次，则重新申请新的层，否则插入指定层次 申请新的节点 调整指针 ConcurrentSkipListMap内部采用SkipLis数据结构实现。为了实现SkipList，ConcurrentSkipListMap提供了三个内部类来构建这样的链表结构：Node、Index、HeadIndex。 通过CAS来实现同步 数据结构 HeadIndex：用来维护索引层次，通过Index从最上层开始往下层查找，一步一步缩小查询范围。 1234567static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; { final int level; //索引层，从1开始，Node单链表层为0 HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) { super(node, down, right); this.level = level; }} Index：提供了一个基于Node节点的索引Node，一个指向下一个Index的right，一个指向下层的down节点 1234567static class Index&lt;K,V&gt; { final ConcurrentSkipListMap.Node&lt;K,V&gt; node; final ConcurrentSkipListMap.Index&lt;K,V&gt; down; volatile ConcurrentSkipListMap.Index&lt;K,V&gt; right; /** 省略些许代码 */} Node：数据节点。包含key、value和一个指向下一个节点的next。 1234567static final class Node&lt;K,V&gt; { final K key; volatile Object value; volatile ConcurrentSkipListMap.Node&lt;K, V&gt; next; /** 省略些许代码 */} 参考资料： https://juejin.cn/post/6844903958499033095 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/16/con-skiplistmap/"},{"title":"GC回收与算法","text":"什么时候发生GCMinor GC（新生代GC）：当jvm无法为新的对象分配空间的时候就会发生Minor gc，所以分配对象的频率越高，也就越容易发生Minor gc Full GC/Major GC（年老代GC）：①当老年代无法分配内存的时候,②当发生Minor GC的时候可能触发Full GC GC回收算法 Stop-the-world意味着 JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。 GC优化很多时候就是指减少Stop-the-world发生的时间 常见的回收算法 标记清除算法：对存活对象进行标记，对未存活对象进行回收。标记和清除两个过程效率不高且容易产生空间碎片。 复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。 实践中会将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间 ，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。虚拟机默认Eden和Survivor的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的90% ( 80%+10% )，只有10% 的内存会被“浪费”。 标记整理算法：标记存活对象然后让所有存活的对象都向一端移动，直接清理掉端边界以外的内存。适用于对象存活率高的场景（老年代） 分代回收算法：新生代对象存活率低，就采用复制算法；老年代存活率高，就用标记清除算法或者标记整理算法 对象存活划分新生代（Young Generation） 新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0，survivor1)区 在进行垃圾回收时，先将eden区存活对象复制到survivor0区，然后清空eden区 当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区 此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。 当三个区域都存放满了后，就将存活对象直接存放到老年代 如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收。 老年代（Old Generation）在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。 老年代的内存也比新生代大很多(大概比例是1:2) 当老年代满时会触发Major GC(Full GC) 永久代（Permanent Generation）永久代主要用于存放静态文件，如Java类、方法等 永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/18/gc/"},{"title":"HashMap原理","text":"简介 是一个散列表，它存储的内容是键值对(key-value)映射 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口 不是同步的（不是线程安全的） key、value都可以为null（当HashMap的key为null时，HashMap会将其固定的插入table[0]位置(即HashMap散列表的第一个位置)；而且table[0]处只会容纳一个key为null的值，当有多个key为null的值插入的时候，table[0]会保留最后插入的value。） 映射不是有序的 数据结构由数组+单向链表组成，数组决定桶的数量 初始容量 ：容量是哈希表中桶的数量，默认为16 加载因子：是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。默认加载因子是 0.75，过低则数据分布稀疏浪费空间且频繁rehash，过高则数据分布稠密增加查询成本 增加键值对时将key和链表中的每一个节点的key进行对比。若key已经存在Entry链表中，则用该value值取代旧的value值；若key不存在Entry链表中，则新建一个key-value节点，并将该节点插入Entry链表的表头位置 hash算法采用自定义的哈希算法 构造函数1234567891011// 默认构造函数。HashMap()// 指定“容量大小”的构造函数HashMap(int capacity)// 指定“容量大小”和“加载因子”的构造函数HashMap(int capacity, float loadFactor)// 包含“子Map”的构造函数HashMap(Map&lt;? extends K, ? extends V&gt; map) 数据结构 table是一个Entry[]数组类型，而Entry实际上就是一个单向链表（拉链法解决哈希冲突）。哈希表的”key-value键值对”都是存储在Entry数组中的 size是HashMap的大小，它是HashMap保存的键值对的数量 threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 loadFactor就是加载因子 modCount是用来实现fail-fast机制的，原理是当多线程操作时会修改modCount，如果发现有变动则触发fail-fast机制 JDK1.7与1.8的区别 JDK7之前hashmap又叫散列链表：基于一个数组以及多个链表的实现，hash值冲突的时候，就将对应节点以链表的形式存储。JDK8中，当同一个hash值（Table上元素）的链表节点数不小于8时，将不再以单链表的形式存储了，会被调整成一颗红黑树。这就是JDK7与JDK8中HashMap实现的最大区别。 遍历方法当我们通过entrySet()获取到的Iterator的next()方法去遍历HashMap时，实际上调用的是 nextEntry() 。而nextEntry()的实现方式，先遍历Entry(根据Entry在table中的序号，从小到大的遍历)；然后对每个Entry(即每个单向链表)，逐个遍历。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/14/hashmap/"},{"title":"Hashtable原理","text":"简介 是一个散列表，它存储的内容是键值对(key-value)映射 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口 是同步的，通过悲观锁synchronized实现，这意味着它是线程安全的 key、value都不可以为null 映射不是有序的 数据结构由数组+单向列表组成，数组决定桶的数量，单向列表采用链表法避免hash冲突 初始容量 ：容量是哈希表中桶的数量，默认为11 加载因子：对哈希表在其容量自动增加之前可以达到多满的一个尺度。默认加载因子是 0.75 hash算法采用key的hashcode 构造函数1234567891011// 默认构造函数。public Hashtable()// 指定“容量大小”的构造函数public Hashtable(int initialCapacity)// 指定“容量大小”和“加载因子”的构造函数public Hashtable(int initialCapacity, float loadFactor)// 包含“子Map”的构造函数public Hashtable(Map&lt;? extends K, ? extends V&gt; t) 数据结构 table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的 count是Hashtable的大小，它是Hashtable保存的键值对的数量 threshold是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”，当Hashtable的 “实际容量” &gt;= “阈值”时，(阈值 = 总的容量 x 加载因子)，就将变为“原始容量x2 + 1”。 loadFactor就是加载因子 modCount是用来实现fail-fast机制 遍历方式 实现了Enumeration接口，通过枚举接口实现遍历 实现了迭代器接口，通过迭代器遍历 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/14/hashtable/"},{"title":"Iterator和Enumeration","text":"针对集合我们可以通过 “Iterator(迭代器)” 或 “Enumeration(枚举类)” 去遍历集合，但两者是有区别的。 两者区别 Enumeration只有2个函数接口，可以读取数据不能修改数据 Iterator只有3个函数接口，可以读取和修改数据 Iterator支持fail-fast机制，而Enumeration不支持 fail-fastfail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 解决方式使用“java.util.concurrent包下的类”去取代“java.util包下的类” 原理fail-fast产生的步骤如下： (01) 新建了一个ArrayList，名称为arrayList。 (02) 向arrayList中添加内容。 (03) 新建一个“**线程a*”，并在“线程a”中**通过Iterator反复的读取arrayList的值。* (04) 新建一个“**线程b*”，在“线程b”中**删除arrayList中的一个“节点A”。* (05) 这时，就会产生有趣的事件了。 ​ 在某一时刻，“线程a”创建了arrayList的Iterator。此时“节点A”仍然存在于arrayList中，创建arrayList时，expectedModCount = modCount(假设它们此时的值为N)。 ​ 在“线程a”在遍历arrayList过程中的某一时刻，“线程b”执行了，并且“线程b”删除了arrayList中的“节点A”。“线程b”执行remove()进行删除操作时，在remove()中执行了“modCount++”，此时modCount变成了N+1！ “线程a”接着遍历，当它执行到next()函数时，调用checkForComodification()比较“expectedModCount”和“modCount”的大小；而“expectedModCount=N”，“modCount=N+1”,这样，便抛出ConcurrentModificationException异常，产生fail-fast事件。 至此，我们就完全了解了fail-fast是如何产生的！ 即，当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/10/ite-enu/"},{"title":"JDK动态代理的底层实现","text":"JavaEE的开发中，许多框架用到了动态代理机制，例如Spring的AOP编程。Java中的动态代理一般就两种：1. JDK自带 ； 2. cglib库，本文主要介绍第一种。 什么是代理真实对象的访问控制交由代理类实现，代理类成为外部对象与委托类的中间桥梁。 通过代理类这中间一层，能有效控制对委托类对象的直接访问，也可以很好地隐藏和保护委托类对象，同时也为实施不同控制策略预留了空间，从而在设计上获得了更大的灵活性。 基于此，代理类可以做一些不影响真实对象功能的附加功能，例如内容校验、日志记录等。 静态代理代理类的生成必须人为手动编写，无法自动生成，在程序运行前代理类的.class文件就已经存在。 例如：UserServiceImpl与StaticProxy都实现了接口IUserService 1234IUserService userService = new UserServiceImpl(); StaticProxy proxy = new StaticProxy(userService); proxy.sayHello(&quot;andy&quot;); proxy.sayBye(&quot;andy&quot;); 动态代理-原理简介动态代理是动态的生成代理类，已JDK动态代理为例，实现代理需要两个关键对象：代理类、调用处理器InvocationHandler。大致流程如下： 编写InvocationHandler调用处理器 被代理类实现接口 生成代理类 实现代理调用 示例代码如下： 1234567891011121314151617181920212223242526272829public class DynamicProxyHandler implements InvocationHandler { private IUserService target; public DynamicProxyHandler(IUserService target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object result = null; System.out.println(&quot;++++++before &quot; + method.getName() + &quot;++++++&quot;); result = method.invoke(target, args); System.out.println(&quot;++++++after &quot; + method.getName() + &quot;++++++&quot;); return result; } public Object getProxy(){ /* * Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) * 方法的第一个参数的作用就是 获取当前类的类加载器,作用是用来生成类的 * 第二个参数是获取真实对象的所有接口 获取所有接口的目的是用来生成代理的,因为代理要实现所有的接口 * 第三个参数是 调用处理器 这里传入调用处理器，是因为生成代理实例需要 调用处理器 为什么需要调用处理器，因为生成的代理不能直接调用真实对象的方法, * 而是通过调用处理器来调用真实对象的方法，具体就是通过上面定义的DynamicProxyHandler重写父类InvocationHandler的invoke方法 */ return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this ); }} 1234567public static void testDynamicProxy() { DynamicProxyHandler handler = new DynamicProxyHandler(new UserServiceImpl()); IUserService userService = (IUserService) handler.getProxy(); userService.sayHello(&quot;jeck&quot;); userService.sayBye(&quot;jeck&quot;);} 动态代理-底层代码分析动态代理的核心是代理类如何生成？大体上如下流程： 生成代理类字节码 类加载器加载字节码 生成代理类class 实力化代理类 123456789101112131415161718192021222324252627public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException { Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); //生成代理Class对象 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); try { //代理对象的构造方法 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) { AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() { public Void run() { cons.setAccessible(true); return null; } }); } //实例化代理对象 return cons.newInstance(new Object[]{h}); } catch (IllegalAccessException|InstantiationException e) { }} getProxyClass0用于生成class对象，其首先去缓存WeakCache&lt;ClassLoader, Class[], Class&gt;取值，如果取不到则生成。核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) { Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) { Class&lt;?&gt; interfaceClass = null; try { interfaceClass = Class.forName(intf.getName(), false, loader); } catch (ClassNotFoundException e) { } if (interfaceClass != intf) { throw new IllegalArgumentException( intf + &quot; is not visible from class loader&quot;); } /* * Verify that the Class object actually represents an * interface. */ if (!interfaceClass.isInterface()) { throw new IllegalArgumentException( interfaceClass.getName() + &quot; is not an interface&quot;); } /* * Verify that this interface is not a duplicate. */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) { throw new IllegalArgumentException( &quot;repeated interface: &quot; + interfaceClass.getName()); } } String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ for (Class&lt;?&gt; intf : interfaces) { int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) { accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? &quot;&quot; : name.substring(0, n + 1)); if (proxyPkg == null) { proxyPkg = pkg; } else if (!pkg.equals(proxyPkg)) { throw new IllegalArgumentException( &quot;non-public interfaces from different packages&quot;); } } } if (proxyPkg == null) { // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;; } /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ //生成代理对象字节码 byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try { //返回代理Class对象 return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); } catch (ClassFormatError e) { /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); } }} InvocationHandler的invoke方法如何被代理类使用？我们把代理类解析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy11 extends Proxy implements IUserService { private static Method m1; private static Method m3; private static Method m2; private static Method m4; private static Method m0; //构造方法中传入处理对象 public $Proxy11(InvocationHandler var1) throws { super(var1); } public final boolean equals(Object var1) throws { try { return ((Boolean)super.h.invoke(this, m1, new Object[]{var1})).booleanValue(); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } //实现了相同的接口，通过处理对象的invoke方法调用 public final void sayHello(String var1) throws { try { super.h.invoke(this, m3, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final String toString() throws { try { return (String)super.h.invoke(this, m2, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final void sayBye(String var1) throws { try { super.h.invoke(this, m4, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final int hashCode() throws { try { return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } static { try { m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[]{Class.forName(&quot;java.lang.Object&quot;)}); m3 = Class.forName(&quot;com.github.sources.proxy.service.IUserService&quot;).getMethod(&quot;sayHello&quot;, new Class[]{Class.forName(&quot;java.lang.String&quot;)}); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); m4 = Class.forName(&quot;com.github.sources.proxy.service.IUserService&quot;).getMethod(&quot;sayBye&quot;, new Class[]{Class.forName(&quot;java.lang.String&quot;)}); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); } catch (NoSuchMethodException var2) { throw new NoSuchMethodError(var2.getMessage()); } catch (ClassNotFoundException var3) { throw new NoClassDefFoundError(var3.getMessage()); } }} 由以上可以得知，在实力化代理类时传递invocationHandler对象cons.newInstance(new Object[]{h});，在代理类构造方法中接收对象。 总结 JDK代理需要依赖代理类、调用处理器 代理类的生成是核心：生成字节码、生成class对象、实力化代理类 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/8/9/jdk-invoke/"},{"title":"Java8中的Stream详解","text":"为什么需要 StreamStream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。 什么是流Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。 Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 而和迭代器又不同的是，Stream 可以并行化操作,Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下： 1.0-1.4 中的 java.lang.Thread 5.0 中的 java.util.concurrent 6.0 中的 Phasers 等 7.0 中的 Fork/Join 框架 8.0 中的 Lambda Stream 的另外一大特点是，数据源本身可以是无限的。 流的构成当我们使用一个流的时候，通常包括三个基本步骤： 获取一个数据源（source）→ 数据转换→执行操作获取想要的结果 有多种方式生成 Stream Source： 从 Collection 和数组 Collection.stream() Collection.parallelStream() Arrays.stream(T array) or Stream.of() 从 BufferedReader java.io.BufferedReader.lines() 静态工厂 java.util.stream.IntStream.range() java.nio.file.Files.walk() 自己构建 java.util.Spliterator 其它 Random.ints() BitSet.stream() Pattern.splitAsStream(java.lang.CharSequence) JarFile.stream() 流的操作类型分为两种： **Intermediate(中间)**：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。 **Terminal(终点)**：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。 在对于一个 Stream 进行多次转换操作 (Intermediate 操作)，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个转换操作只会在 Terminal 操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在 Terminal 操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。 还有一种操作被称为 short-circuiting。用以指： 对于一个 intermediate 操作，如果它接受的是一个无限大（infinite/unbounded）的 Stream，但返回一个有限的新 Stream。 对于一个 terminal 操作，如果它接受的是一个无限大的 Stream，但能在有限的时间计算出结果。 当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件。 流的构造与转换简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。 下面提供最常见的几种构造 Stream 的样例。 构造流的几种常见方法123456789// 1. Individual valuesStream stream = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);// 2. ArraysString [] strArray = new String[] {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};stream = Stream.of(strArray);stream = Arrays.stream(strArray);// 3. CollectionsList&lt;``String``&gt; list = Arrays.asList(strArray);stream = list.stream(); 需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream： IntStream、LongStream、DoubleStream。当然我们也可以用 Stream、Stream &gt;、Stream，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。 Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。 数值流的构造123IntStream.of(new int[]{1, 2, 3}).forEach(System.out::println);IntStream.range(1, 3).forEach(System.out::println);IntStream.rangeClosed(1, 3).forEach(System.out::println); 流转换为其它数据结构123456789// 1. ArrayString[] strArray1 = stream.toArray(String[]::new);// 2. CollectionList&lt;``String``&gt; list1 = stream.collect(Collectors.toList());List&lt;``String``&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));Set set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. StringString str = stream.collect(Collectors.joining()).toString(); 一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。 流的操作接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。 Intermediate： map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered Terminal： forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator Short-circuiting： anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit 这里不在举例每一个具体操作如何使用,详情可参考[1] reduce(汇聚操作)汇聚操作（也称为折叠）接受一个元素序列为输入，反复使用某个合并操作，把序列中的元素合并成一个汇总的结果。比如查找一个数字列表的总和或者最大值，或者把这些数字累积成一个List对象。Stream接口有一些通用的汇聚操作，比如reduce()和collect()；也有一些特定用途的汇聚操作，比如sum(),max()和count()。注意：sum方法不是所有的Stream对象都有的，只有IntStream、LongStream和DoubleStream是实例才有。 java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。 下面会分两部分来介绍汇聚操作： 可变汇聚：把输入的元素们累积到一个可变的容器中，比如Collection或者StringBuilder； 其他汇聚：除去可变汇聚剩下的，一般都不是通过反复修改某个可变对象，而是通过把前一次的汇聚结果当成下一次的入参，反复如此。比如reduce，count，allMatch； 可变汇聚 可变汇聚对应的只有一个方法：collect，正如其名字显示的，它可以把Stream中的要有元素收集到一个结果容器中（比如Collection）。先看一下最通用的collect方法的定义（还有其他override方法）： 1&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,BiConsumer&lt;R, ? super T&gt; accumulator,BiConsumer&lt;R, R&gt; combiner); 先来看看这三个参数的含义：Supplier supplier是一个工厂函数，用来生成一个新的容器；BiConsumer accumulator也是一个函数，用来把Stream中的元素添加到结果容器中；BiConsumer combiner还是一个函数，用来把中间状态的多个结果容器合并成为一个（并发的时候会用到）。看晕了？来段代码！ 12345List&lt;Integer&gt; nums = Lists.newArrayList(1,1,null,2,3,4,null,5,6,7,8,9,10);List&lt;Integer&gt; numsWithoutNull = nums.stream().filter(num -&gt; num != null).collect(() -&gt; new ArrayList&lt;Integer&gt;(),(list, item) -&gt; list.add(item),(list1, list2) -&gt; list1.addAll(list2)); 上面这段代码就是对一个元素是Integer类型的List，先过滤掉全部的null，然后把剩下的元素收集到一个新的List中。进一步看一下collect方法的三个参数，都是lambda形式的函数。 第一个函数生成一个新的ArrayList实例； 第二个函数接受两个参数，第一个是前面生成的ArrayList对象，二个是stream中包含的元素，函数体就是把stream中的元素加入ArrayList对象中。第二个函数被反复调用直到原stream的元素被消费完毕； 第三个函数也是接受两个参数，这两个都是ArrayList类型的，函数体就是把第二个ArrayList全部加入到第一个中； 但是上面的collect方法调用也有点太复杂了，没关系！我们来看一下collect方法另外一个override的版本，其依赖Collector。 1&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); 这样清爽多了！Java8还给我们提供了Collector的工具类–Collectors，其中已经定义了一些静态工厂方法，比如：Collectors.toCollection()收集到Collection中, Collectors.toList()收集到List中和Collectors.toSet()收集到Set中。 这样的静态方法还有很多，这里就不一一介绍了，大家可以直接去看JavaDoc。下面看看使用Collectors对于代码的简化： 12List&lt;Integer&gt; numsWithoutNull = nums.stream().filter(num -&gt; num != null).collect(Collectors.toList()); 其它汇聚 – reduce方法：reduce方法非常的通用，后面介绍的count，sum等都可以使用其实现。reduce方法有三个override的方法，本文介绍两个最常用的。先来看reduce方法的第一种形式，其方法定义如下： 1Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); 接受一个BinaryOperator类型的参数，在使用的时候我们可以用lambda表达式来。 12List&lt;Integer&gt; ints = Lists.newArrayList(1,2,3,4,5,6,7,8,9,10);System.out.println(&quot;ints sum is:&quot; + ints.stream().reduce((sum, item) -&gt; sum + item).get()); 可以看到reduce方法接受一个函数，这个函数有两个参数，第一个参数是上次函数执行的返回值（也称为中间结果），第二个参数是stream中的元素，这个函数把这两个值相加，得到的和会被赋值给下次执行这个函数的第一个参数。要注意的是：第一次执行的时候第一个参数的值是Stream的第一个元素，第二个参数是Stream的第二个元素。这个方法返回值类型是Optional，这是Java8防止出现NPE的一种可行方法，后面的文章会详细介绍，这里就简单的认为是一个容器，其中可能会包含0个或者1个对象。 reduce方法还有一个很常用的变种： 1T reduce(T identity, BinaryOperator&lt;T&gt; accumulator); 这个定义上上面已经介绍过的基本一致，不同的是：它允许用户提供一个循环计算的初始值，如果Stream为空，就直接返回该值。而且这个方法不会返回Optional，因为其不会出现null值。下面直接给出例子，就不再做说明了。 12List&lt;Integer&gt; ints = Lists.newArrayList(1,2,3,4,5,6,7,8,9,10);System.out.println(&quot;ints sum is:&quot; + ints.stream().reduce(0, (sum, item) -&gt; sum + item)); – count方法：获取Stream中元素的个数。比较简单，这里就直接给出例子，不做解释了。 – allMatch：是不是Stream中的所有元素都满足给定的匹配条件 – anyMatch：Stream中是否存在任何一个元素满足匹配条件 – findFirst: 返回Stream中的第一个元素，如果Stream为空，返回空Optional – noneMatch：是不是Stream中的所有元素都不满足给定的匹配条件 – max和min：使用给定的比较器（Operator），返回Stream中的最大|最小值 其它操作简要介绍如下 distinct: 对于Stream中包含的元素进行去重操作（去重逻辑依赖元素的equals方法），新生成的Stream中没有重复的元素； filter: 对于Stream中包含的元素使用给定的过滤函数进行过滤操作，新生成的Stream只包含符合条件的元素； map: 对于Stream中包含的元素使用给定的转换函数进行转换操作，新生成的Stream只包含转换生成的元素。这个方法有三个对于原始类型的变种方法，分别是：mapToInt，mapToLong和mapToDouble。这三个方法也比较好理解，比如mapToInt就是把原始Stream转换成一个新的Stream，这个新生成的Stream中的元素都是int类型。之所以会有这样三个变种方法，可以免除自动装箱/拆箱的额外消耗； flatMap：和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中； peek: 生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新Stream每个元素被消费的时候都会执行给定的消费函数； limit: 对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于N，那就获取其所有的元素； skip: 返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream，如果原Stream中包含的元素个数小于N，那么返回空Stream； 整体调用例子： 12List&lt;Integer&gt; nums = Lists.newArrayList(1,1,null,2,3,4,null,5,6,7,8,9,10);System.out.println(“sum is:”+nums.stream().filter(num -&gt; num != null).distinct().mapToInt(num -&gt; num * 2).peek(System.out::println).skip(2).limit(4).sum()); 这段代码演示了上面介绍的所有转换方法（除了flatMap），简单解释一下这段代码的含义：给定一个Integer类型的List，获取其对应的Stream对象，然后进行过滤掉null，再去重，再每个元素乘以2，再每个元素被消费的时候打印自身，在跳过前两个元素，最后去前四个元素进行加和运算(解释一大堆，很像废话，因为基本看了方法名就知道要做什么了。这个就是声明式编程的一大好处！)。 大家可以参考上面对于每个方法的解释，看看最终的输出是什么。 2 4 6 8 10 12 sum is:36 可能会有这样的疑问：在对于一个Stream进行多次转换操作，每次都对Stream的每个元素进行转换，而且是执行多次，这样时间复杂度就是一个for循环里把所有操作都做掉的N（转换的次数）倍啊。其实不是这样的，转换操作都是lazy的，多个转换操作只会在汇聚操作（见下节）的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在汇聚操作的时候循环Stream对应的集合，然后对每个元素执行所有的函数。 进阶：自己生成流Stream.generate 通过实现 Supplier 接口，你可以自己来控制流的生成。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。 生成 10 个随机整数123456Random seed = new Random();Supplier&lt;``Integer``&gt; random = seed::nextInt;Stream.generate(random).limit(10).forEach(System.out::println);//Another wayIntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).limit(10).forEach(System.out::println); Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。 自实现 Supplier123456789101112Stream.generate(new PersonSupplier()).limit(10).forEach(p -&gt; System.out.println(p.getName() + &quot;, &quot; + p.getAge()));private class PersonSupplier implements Supplier&lt;Person&gt; {private int index = 0;private Random random = new Random();@Overridepublic Person get() {return new Person(index++, &quot;StormTestUser&quot; + index, random.nextInt(100));}} 输出结果： 12345678910StormTestUser1, 9StormTestUser2, 12StormTestUser3, 88StormTestUser4, 51StormTestUser5, 22StormTestUser6, 28StormTestUser7, 81StormTestUser8, 51StormTestUser9, 4StormTestUser10, 76 Stream.iterate iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。 生成一个等差数列 1Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + &quot; &quot;));. 输出结果： 10 3 6 9 12 15 18 21 24 27 与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。 结束语 不是数据结构 它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。 它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。 所有 Stream 的操作必须以 lambda 表达式为参数 不支持索引访问 惰性化(即intermediate操作) 很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。 并行能力 当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。 可以是无限的 集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。 参考内容: [1]https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/ var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/4/15/java8Stream/"},{"title":"LinkedList原理","text":"简介 继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作 实现 List 接口，能对它进行队列操作 实现 Deque 接口，即能将LinkedList当作双端队列使用 实现了Cloneable接口，能克隆 实现java.io.Serializable接口，能通过序列化去传输 是非同步的 数据结构 header：双向链表的表头，为Entry类的实例 size：双向链表中节点的个数 注：Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值 遍历方式 迭代器遍历 随机访问：如list.get(i);效率低 pollFirst()：while(list.pollFirst() != null) pollLast()：while(list.pollLast() != null) removeFirst()：while(list.removeFirst() != null) removeLast()：while(list.removeLast() != null) 特性说明 双向链表顺序访问高效，随机访问效率低 如何支持索引（随机）访问（即方法*get(int location)*）：首先会比较“location”和“双向链表长度的1/2”；若前者大，则从链表头开始往后查找，直到location位置；否则，从链表末尾开始先前查找，直到location位置 不存在容量不足的问题 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/12/linkedlist/"},{"title":"ReentrantLock原理","text":"简介 实现Lock接口的一个类，支持重入性，表示能够对共享资源能够重复加锁 当前线程获取该锁再次获取不会被阻塞 ReentrantLock还支持公平锁和非公平锁两种方式 公平锁与非公平锁12Lock lock=new ReentrantLock(true);//公平锁Lock lock=new ReentrantLock(false);//非公平锁 公平锁指的是线程获取锁的顺序是按照加锁顺序来的，而非公平锁指的是抢锁机制，先lock的线程不一定先获得锁，效率更高。 公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成“饥饿”现象。 公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。 Condition类Lock类可以创建Condition对象，Condition对象用来是线程等待和唤醒线程 一个condition对象的signal（signalAll）方法和该对象的await方法是一一对应的，也就是一个condition对象的signal（signalAll）方法不能唤醒其他condition对象的await方法。 123456789101112131415161718192021222324public class MyService {private Lock lock = new ReentrantLock();private Condition condition=lock.newCondition();public void testMethod() {try {lock.lock();System.out.println(&quot;开始wait&quot;);condition.await();for (int i = 0; i &lt; 5; i++) {System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName()+ (&quot; &quot; + (i + 1)));}} catch (InterruptedException e) {// TODO 自动生成的 catch 块e.printStackTrace();}finally{lock.unlock();}}} Condition类的awiat方法和Object类的wait方法等效 Condition类的signal方法和Object类的notify方法等效 Condition类的signalAll方法和Object类的notifyAll方法等效 底层原理 ReentrantLock先通过CAS尝试获取锁， 如果此时锁已经被占用，该线程加入AQS队列并wait() 当前驱线程的锁被释放，挂在CLH队列为首的线程就会被notify()，然后继续CAS尝试获取锁，此时： 非公平锁，如果有其他线程尝试lock()，有可能被其他刚好申请锁的线程抢占。 公平锁，只有在CLH队列头的线程才可以获取锁，新来的线程只能插入到队尾。 lock()函数12345678910final void lock() { //非公平锁 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);}final void lock() { //公平锁 acquire(1);} 如果成功通过CAS修改了state，指定当前线程为该锁的独占线程，标志自己成功获取锁。 如果CAS失败的话，调用acquire(); acquire()中调用tryAcquire()，会尝试再次通过CAS修改state为1 如果失败而且发现锁是被当前线程占用的，就执行重入（state++） 如果锁是被其他线程占有，那么当前线程执行tryAcquire返回失败，并且执行addWaiter()进入等待队列，并挂起自己interrupt() Unlock()函数 释放时候，state–，通过state==0判断锁是否完全被释放。 成功释放锁的话，唤起一个被挂起的线程 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/19/reent-l/"},{"title":"ReentrantReadWriteLock","text":"简介多线程环境下对资源的读操作和写操作会造成数据的不一致，因此读和写需要加锁，ReadWriteLock诞生。 ReentrantReadWriteLock是可重入读写锁，意味着已经获取到资源的线程可以重复的获取锁，获取次数+1，相应的也要释放对应的次数。 资源分配方式 公平性选择：默认的方式，按照阻塞队列的先后顺序将资源分配给对应的线程 非公平性选择：资源的分配与阻塞队列的先后顺序无关，很可能出现一个线程多次长期占用某资源，从而造成死锁。 特点 “读-读” 不互斥 “读-写” 互斥 “写-写” 互斥 读锁是可以被多线程共享的，写锁是单线程独占的。也就是说写锁的并发限制比读锁高，这可能就是升级/降级名称的来源。 触发条件 读操作：可以有多个读操作，但是读操作与写操作互斥，因此读操作的前提是阻塞队列中不存在写操作及读操作时对一切写操作加锁禁止写操作 写操作：写操作与写操作互斥，因此同一时刻只允许一个写操作对资源的占用 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/19/reent-rw/"},{"title":"Servlet的多线程和线程安全","text":"什么是servlet狭义的Servlet是指Java语言的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类。 即作为处理web请求与java后端业务逻辑交互的桥梁，如tomcat就是servlet容器，其会将java项目中的servlet类加载至容器成为servlet对象。 工作流程 java web项目要实现servlet接口并借助servlet容器发布 servlet容器启动时会将servlet加载至容器或者请求来临时需要使用servlet时加载进容器 HTTP请求发送至servlet容器 servlet容器根据请求信息查询对应的servlet-name并将请求包装为HttpServletRequest类型的request对象转给servlet实例 servlet实例将处理结果返回给servlet容器，容器将结果信息封装为HttpServletResponse类型的response对象，容器进一步将response对象转换为http响应文本给到浏览器 servlet生命周期 加载：通过java类加载器来加载servlet类并实例化一个对象，且只会实例化一次 初始化：容器调用初始化方法来初始化servlet对象，即根据ServletConfig来初始化 处理请求 销毁：容器关闭或重启时 几个重要对象 ServletConfig：包含了servlet名称、ServletContext，初始化参数等 ServletContext：tomcat为每个web项目都创建一个ServletContext实例，tomcat在启动时创建，服务器关闭时销毁，在一个web项目中共享数据，管理web项目资源，为整个web配置公共信息等 request：将请求文本封装而成的对象，所以通过request能获得请求文本中的所有内容，请求头、请求体、请求行 response：响应体 servlet是线程安全的吗？不是线程安全的 servlet是单实例的且是无状态的，多个请求过来即多线程下访问的是同一个servlet实例，如果servlet实例中有静态变量、静态属性等，那么多线程是可以共享的，因此不安全。 如何实现线程安全？ 避免使用实例变量、静态变量 可以加锁 可以利用线程安全的集合等 servlet与spring boot的关系springboot可以自动装配springmvc，springmvc的核心类是DispatcherServlet，这个就是servlet。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/11/servlet/"},{"title":"Set原理","text":"set是一个不存在重复元素的集合。接口的底层实现有两个hashset和treeset。 HashSet 一个没有重复元素的集合。 由HashMap实现不保证元素的顺序 允许使用 null 元素 是非同步的 迭代器是fail-fast的 数据结构 它是通过HashMap实现的。HashSet中含有一个”HashMap类型的成员变量”map 实际上的存值是将值存在map的key中，而value默认创建一个object代替 构造函数支持传递“加载因子”和“初始容量”，当实际大小&gt;最大容量*加载因子，容量将翻倍 遍历方式 迭代器 for-each TreeSet 一个有序的且没有重复元素的集合 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。 实现了NavigableSet接口，意味着它支持一系列的导航方法。比返回小于、小于等于、大于等于、大于给定元素的元素 实现了Cloneable接口 实现了java.io.Serializable接口 基于TreeMap实现的 是非同步的 它的iterator 方法返回的迭代器是fail-fast的 数据结构 它是通过TreeMap实现的。TreeSet中含有一个”NavigableMap类型的成员变量”m 实际上的存值是将值存在map的key中，而value默认创建一个object代替 构造函数支持比较器传递，无参构造函数默认自然比较器，否则可传入自定义比较器 遍历方式 迭代器 for-each var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/14/set/"},{"title":"Stack原理","text":"简介 Stack是栈。它的特性是：先进后出(FILO, First In Last Out)。 继承于Vector，意味着Stack也是通过数组实现的 基本用法 执行push时(即，将元素推入栈中) 执行peek时(即，取出栈顶元素，不执行删除) 执行pop时(即，取出栈顶元素，并将该元素从栈中删除) var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/13/stack/"},{"title":"StampedLock原理","text":"简介ReentrantReadWriteLock中的读–写锁时互斥的，在读的时候都会悲观的去加锁，防止同时刻的写操作，如果读操作数量远远大于写操作则会造成写饥饿。 不幸的是大多数情况下读操作都远远大于写操作，因此StampedLock登场。 原理 StampedLock有两种锁，一种是悲观锁，另外一种是乐观锁。 如果线程拿到乐观锁就读和写不互斥，每次去拿数据的时候，都没锁上，而是判断标记位是否有被修改，如果有修改就再去读一次。 如果拿到悲观锁就读和写互斥。 StampedLockd的内部实现是基于CLH锁的 CLH锁原理：锁维护着一个等待线程队列，所有申请锁且失败的线程都记录在队列。一个节点代表一个线程，保存着一个标记位locked,用以判断当前线程是否已经释放锁。当一个线程试图获取锁时，从队列尾节点作为前序节点，循环判断所有的前序节点是否已经成功释放锁。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/19/stampedlock/"},{"title":"Synchronized的实现原理","text":"基本用法作用（1）确保线程互斥的访问同步代码 （2）保证共享变量的修改能够及时可见 （3）有效解决重排序问题 用法（1）修饰普通方法 （2）修饰静态方法 （3）修饰代码块 Synchronized 原理 Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的 监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的 其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。 对象监视器锁-monitorenter每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下： 1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。 2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1. 3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。 对象监视器锁-monitorenter执行monitorexit的线程必须是objectref所对应的monitor的所有者。 指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/19/synchronized/"},{"title":"ThreadLocal详解","text":"ThreadLocal是什么ThreadLocal是线程本地副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不同的变量值完成操作的场景。 基本使用如下： 123456789101112131415161718//在自定义类中创建ThreadLocal对象，EngineContext为我们自定义的Value对象类//java是多线程的，父类初始化后，内部定义的ThreadLocal对象即在本线程内起效public class ThreadLocalTest{ private static final ThreadLocal&lt;testContext&gt; CONTEXT_HOLDER = new ThreadLocal&lt;&gt;(); public void initalize(testContext context) { CONTEXT_HOLDER.set(context); } public void clean() { CONTEXT_HOLDER.remove(); } public testContext get() { return CONTEXT_HOLDER.get(); } ...} ThreadLocal数据结构先看线程内部变量，线程中本身就有threadLocals与inheritableThreadLocals对象，两者都是ThreadLocalMap类型，主要目的是存放属于本线程的ThreadLocal值对象。这也是线程间做到数据隔离的关键。 12345678910111213141516public class Thread implements Runnable {... /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. * 与此线程相关的ThreadLocal值。由ThreadLocal类维护*/ ThreadLocal.ThreadLocalMap threadLocals = null; /* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. * 与此线程相关的可继承父类的ThreadLocal值。由InheritableThreadLocal类维护 */ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;...} 以threadLocals为例，那么线程中的threadLocals是如何被赋值和获取的呢？ ThreadLocalMap是ThreadLocal工具类的内部类，ThreadLocalMap中有get、set方法用于操作。 1234567891011121314151617181920212223242526272829303132...public T get() { //获取当前线程 Thread t = Thread.currentThread(); //获取当前线程中的threadLocals ThreadLocalMap map = getMap(t); if (map != null) { //从threadLocals中取值Entry，注意key为ThreadLocal对象本身 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; } } return setInitialValue();}... public void set(T value) { //获取当前线程 Thread t = Thread.currentThread(); //获取当前线程中的threadLocals ThreadLocalMap map = getMap(t); if (map != null) //赋值：注意key为ThreadLocal对象本身 map.set(this, value); else createMap(t, value); }... 总结： 每一个Thread内都存在独立的ThreadLocalMap对象 ThreadLocalMap对象是key为ThreadLocal的map Thread内的ThreadLocalMap被ThreadLocal进行统一管理，实现get/set等功能 ThreadLocalMap数据结构123456789101112static class ThreadLocalMap { static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } } ...} 总结： ThreadLocalMap是由自己定义的Entry组成 Entry为key-value键值对对象，其中key为ThreadLocal本身 key是弱引用的，会在下次GC时被回收 ThreadLocalMap一致性原理ThreadLocalMap采用线性探测的方式寻找位置，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。 ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置。 1234567891011121314151617181920212223242526272829private void set(ThreadLocal&lt;?&gt; key, Object value) { Entry[] tab = table; int len = tab.length; //获取数组下标 int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal&lt;?&gt; k = e.get(); //如果当前遍历的ThreadLocal与传入的ThreadLocal一致，则覆盖value值 if (k == key) { e.value = value; return; } //如果遍历到的位置key为null，证明此处没有对象，则创建entry放入该位置 if (k == null) { replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();} 简单来说，set 方法会先计算该 ThreadLocal 的数据下标，如果该位置上为空，则新建 Entry 键值对并插入；如果该位置有数据且 key 一致，则覆盖原有 value；如果 for 循环一直找不到对应位置，在循环外直接给 tab[i] 赋新得 Entry 123456789101112131415161718192021222324252627282930private Entry getEntry(ThreadLocal&lt;?&gt; key) { //计算出下标 int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) //匹配到相同的ThreadLocal return e; else //没有匹配到相同的ThreadLocal return getEntryAfterMiss(key, i, e);}private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) { ThreadLocal&lt;?&gt; k = e.get(); //找到相同的就返回，找不到就继续遍历下一个，都找不到就返回null if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null;} get方法也是很简单找到相同的就返回，找不到就继续遍历下一个，都找不到就返回null 内存泄漏问题由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。 ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal 方法后 最好手动调用remove()方法 为什么使用弱键？下面我们分两种情况讨论： （1）key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。 （2）key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set、get、remove的时候会被清除。 比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set、get、remove的时候会被清除。 因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。 如何实现线程资源共享使用 InheritableThreadLocal 类可以实现多个线程访问 ThreadLocal 的值，我们在主线程中创建一个 InheritableThreadLocal 的实例，然后在子线程中得到这个 InheritableThreadLocal 实例设置的值。使用ThreadLocal threadLocal = new InheritableThreadLocal();即可 总结： 一个线程有一个ThreadLocalMap 一个线程可以有多个ThreadLocal即ThreadLocalMap存放多个ThreadLocal ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。 ThreadLocal仅仅是工具类，可以将其理解为list、map等集合类（特殊的是其只能存放单个对象），ThreadLocal对象的创建可以是自定义线程类内部，也可也是其它非线程类内部，只要某句代码使用ThreadLocal对象的get、set等方法，其实此时该工具类自动会同当前进程相管理，讲变量副本关联到当前线程Thread内置的ThreadLocalMap内以实现变量隔离效果。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/5/21/threadlocal/"},{"title":"TreeMap原理","text":"简介 一个有序的key-value集合，它是通过红黑树实现的 实现了NavigableMap接口，意味着它支持一系列的导航方法。 实现了Cloneable接口 实现了java.io.Serializable接口 适合读取操作频繁，插入、删除操作少的业务，因为红黑书在变动后必须保持平衡 基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。 基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。 是非同步的 它的iterator 方法返回的迭代器是fail-fastl的 构造函数1234567891011// 默认构造函数。使用该构造函数，TreeMap中的元素按照自然排序进行排列。TreeMap()// 创建的TreeMap包含Map，构造函数会调用putAll()将m中的所有元素添加到TreeMap中TreeMap(Map&lt;? extends K, ? extends V&gt; copyFrom)// 指定Tree的比较器TreeMap(Comparator&lt;? super K&gt; comparator)// 创建的TreeSet包含copyFrom，通过buildFromSorted()来创建对应的MapTreeMap(SortedMap&lt;K, ? extends V&gt; copyFrom) 数据结构 root 是红黑数的根节点。它是Entry类型，Entry是红黑数的节点 entry包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry中的key比较大小是根据比较器comparator来进行判断的。 size是红黑数中节点的个数 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/14/treemap/"},{"title":"Vector原理","text":"简介 矢量队列 Vector 继承了AbstractList，实现了List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。 Vector 实现了RandmoAccess接口，即提供了随机访问功能 Vector 实现了Cloneable接口，它能被克隆。 Vector中的操作是线程安全的 构造函数1234567891011// 默认构造函数Vector()// capacity是Vector的默认容量大小。当由于增加数据导致容量增加时，每次容量会增加一倍。Vector(int capacity)// capacity是Vector的默认容量大小，capacityIncrement是每次Vector容量增加时的增量值。Vector(int capacity, int capacityIncrement)// 创建一个包含collection的VectorVector(Collection&lt;? extends E&gt; collection) 数据结构 elementData ：”Object[]类型的数组”，未设置初始大小时使用默认大小10 elementCount：动态数组的实际大小。 capacityIncrement：动态数组的增长系数。若容量增加系数 &gt;0，则将容量的值增加“容量增加系数”；否则，将容量大小增加一倍。 遍历方式 迭代器：效率最低 随机访问：vec.get(i)，效率最高 for循环 Enumeration遍历 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/13/vector/"},{"title":"WeakHashMap原理","text":"简介 是一个散列表，它存储的内容是键值对(key-value)映射 键和值都可以是null 键是“弱键” 数据结构同HashMap 是不同步的 弱键实现原理 通过WeakReference和ReferenceQueue实现的。 WeakHashMap的key是“弱键”，即是WeakReference类型的；ReferenceQueue是一个队列，它会保存被GC回收的“弱键”。 实现步骤是： 弱键被GC回收时这个“弱键”也同时会被添加到ReferenceQueue(queue)队列 当下一次我们需要操作WeakHashMap时，会先同步table和queue。同步它们就是删除table中被GC回收的键值对。 构造函数1234567891011// 默认构造函数。WeakHashMap()// 指定“容量大小”的构造函数WeakHashMap(int capacity)// 指定“容量大小”和“加载因子”的构造函数WeakHashMap(int capacity, float loadFactor)// 包含“子Map”的构造函数WeakHashMap(Map&lt;? extends K, ? extends V&gt; map) 数据结构 table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。 size是Hashtable的大小，它是Hashtable保存的键值对的数量。 threshold是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。 loadFactor就是加载因子。 modCount是用来实现fail-fast机制的 queue保存的是“已被GC清除”的“弱引用的键”。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/14/weakhashmap/"},{"title":"hashcode与equals","text":"equals介绍 equals是Object类提供的方法之一,java中每一个对象都有equals这个方法。 public boolean equals(Object obj) { return (this == obj); } 此时比较的是两个引用是否指向内存中的同一个对象。 hashcode介绍 hashcode()这个方法也是从object类中继承过来的，在object类中定义如下： public native int hashCode(); hashCode()返回该对象的哈希码值，该值通常是一个由该对象的内部地址转换而来的整数。程序先进行 hashcode 的比较，如果不同，那没就不必在进行 equals 的比较了，这样就大大减少了 equals 比较的次数 相互关系 规则1：如果两个对象equals是相等的，那么他们必须拥有一样的hashcode 规则2：如果两个对象有一样的hashcode，但仍不一定相等，因为还需要第二个要求，也就是equals方法的判断。 注意事项 重写equals时一定要重写hashcode 例如：只重写了A对象的equals方法，如果创建两个A对象实例A1,A2并使两者满足equals相等hashcode不等。 A1,A2存放入hashmap时会被当作不同的对象重复存储，如果此时创建A3并以A3为key进行查询则永远不可能查到A1,A2。 重写equals举例 12345678910111213141516171819@Overridepublic boolean equals(Object obj) {if(this == obj){return true;//地址相等 }if(obj == null){return false;//非空性：对于任意非空引用x，x.equals(null)应该返回false。 }if(obj instanceof User){User other = (User) obj;//需要比较的字段相等，则这两个对象相等if(equalsStr(this.name, other.name)&amp;&amp; equalsStr(this.age, other.age)){return true;}}return false;} 重写hashCode举例 1234567@Overridepublic int hashCode() {int result = 17;result = 31 * result + (name == null ? 0 : name.hashCode());result = 31 * result + (age == null ? 0 : age.hashCode());return result;} 为什么要使用31 原因一：更少的乘积结果冲突 31是质子数中一个“不大不小”的存在，如果你使用的是一个如2的较小质数，那么得出的乘积会在一个很小的范围，很容易造成哈希值的冲突。而如果选择一个100以上的质数，得出的哈希值会超出int的最大范围，这两种都不合适。而如果对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，并使用常数 31, 33, 37, 39 和 41 作为乘子，每个常数算出的哈希值冲突数都小于7个（国外大神做的测试），那么这几个数就被作为生成hashCode值得备选乘数了。 所以从 31,33,37,39 等中间选择了 31 的原因看原因二。 原因二：可以被jvm优化 JVM里最有效的计算方式就是进行位运算了： * 左移 &lt;&lt; : 左边的最高位丢弃，右边补全0（把 &lt;&lt; 左边的数据*2的移动次幂）。 * 右移 &gt;&gt; : 把&gt;&gt;左边的数据/2的移动次幂。 * 无符号右移 &gt;&gt;&gt; : 无论最高位是0还是1，左边补齐0。 ​ 所以 ： 31 * i = (i &lt;&lt; 5) - i（左边 312=62,右边 22^5-2=62） - 两边相等，JVM就可以高效的进行计算 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/6/dashcode-equals/"},{"title":"java8-Optional教程","text":"简介Optional作为对象容器可以容纳空/非空对象.Optional对象作为值对象,在使用等价比较\\hash code获取\\同步操作等时可能会出现不可预知的异常,应该避免使用. Optional的出现主要是起到两点作用: 第一,其可以有效的解决空指针异常问题,通过内置isPresent方法来判断容器内是否有值,通过else等内置方式可针对空/异常情况做特殊处理. 第二,极大的促进了函数式编程的发展,我们在使用lambda表达式上不仅有Stream的选择,也可以借助Optional实现. 注:本文以java8为例进行讲解,java9或更高版本有功能的扩展,本文知识点弄清后对扩展功能将更容易接受. 方法介绍 内置方法 方法简介 public static Optional of(T value) 设置值为value public static Optional ofNullable(T value) 设置值为可空value public T get() 获取值 public boolean isPresent() 值是否为空 public void ifPresent(Consumer&lt;? super T&gt; consumer) 如果值非空则对值进行处理 public Optional filter(Predicate&lt;? super T&gt; predicate) 如果值非空且匹配lambda表达式则返回Optional,否则返回空,若不匹配则返回当前Optional public Optional map(Function&lt;? super T, ? extends U&gt; mapper) 根据lambda重新映射值,返回值自动封装 public Optional flatMap(Function&lt;? super T, Optional&gt; mapper) 根据lambda重新映射值,返回值需手动封装 public T orElse(T other) 如果值非空则返回值,否则返回指定对象 public T orElseGet(Supplier&lt;? extends T&gt; other) 如果值非空则返回值,否则返回lambda表达式执行结果 public T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) 如果值非空则返回值,否则抛出由lambda表达式执行结果所指定的异常对象 核心方法案例ifPresent 123456789101112@Testpublic void ifPresentTest() { Student student = new Student(20, 90); //如果value(值)不为空则通过lambda处理值,否则不进行任何处理 Optional&lt;Student&gt; optionalStudent = Optional.of(student); optionalStudent.ifPresent(item -&gt; { int grade = item.getAge() &gt; 20 ? item.getGrade() + 5 : item.getGrade() - 1; item.setGrade(grade); }); System.out.println(optionalStudent);} filter 12345678@Testpublic void filterTest() { Student student = new Student(20, 90); //如果value(值)不为空则可实现过滤,否则返回原Optional Optional&lt;Student&gt; optionalStudent = Optional.of(student).filter(item -&gt; item.getGrade() &gt; 90); System.out.println(optionalStudent);} map 12345678@Testpublic void mapTest() { Student student = new Student(20, 90); //如果value(值)不为空则可借助lambda表达式实现map处理,否则返回Optional.empty Optional&lt;Student&gt; optionalStudent = Optional.of(student).map(item -&gt; new Student(item.getGrade(), item.getAge())); System.out.println(optionalStudent);} flatMap 12345678910111213141516171819202122232425@Testpublic void flatMapTest() { Student student = new Student(20, 90); //flatMap的返回结果需要自行封装成Optional,如果value为空则返回Optional.empty //Optional&lt;Student&gt; optionalStudent = Optional.of(student).flatMap(item -&gt; Optional.of(new Student(item.getGrade(), item.getAge()))); //System.out.println(optionalStudent); Student student2 = new Student(22, 92); Student student3 = new Student(23, 93); List&lt;Student&gt; students = Lists.newArrayList(); students.add(student); students.add(student2); students.add(student3); Optional&lt;List&lt;Student&gt;&gt; optionalStudent = Optional.of(students).flatMap(item -&gt; Optional.of(this.flatMapTest2(item))); System.out.println(&quot;结果输出&quot;); System.out.println(optionalStudent);}public List&lt;Student&gt; flatMapTest2(List&lt;Student&gt; students) { System.out.println(&quot;flatMapTest2输出&quot;); System.out.println(students); return students;} orElseThrow 123456789101112@Testpublic void orElseThrowTest() { Student student = null; //如果容器值存在则返回容器值,否则将根据lambda表达式抛出异常对象 try { //Student optionalStudent = Optional.ofNullable(student).orElseThrow(IllegalStateException::new); //Student optionalStudent = Optional.ofNullable(student).orElseThrow(Exception::new); Student optionalStudent = Optional.ofNullable(student).orElseThrow(() -&gt; new Exception(&quot;错误&quot;)); } catch (Exception e) { System.out.println(e); }} 相关资料: [1]测试代码https://github.com/monkeyGeek369/demoTest var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/16/Optional/"},{"title":"java8新特性-lambda表达式","text":"简介lambda表达式作为java8的新特性极大的提高了编程效率以及可读性,本质上来讲lambda表达式是对传统面向对象编程到函数式编程的转变.举个简单的小栗子来感受下lambda的魅力. 123Map&lt;String, String&gt; cargo = specialCargo.getChildren().stream() .filter(item -&gt; item.getValue() != null) .collect(Collectors.toMap(x -&gt; x.getId(), x -&gt; x.getValue().toString())); lambda与stream API的结合会使得java中的集合操作更加便利和高效.Collectors.toMap(x -&gt; x.getId(), x -&gt; x.getValue().toString())实现将list转换为指定的map集合 语法一般语法 123456(Type1 param1, Type2 param2, ..., TypeN paramN) -&gt; {statment1;statment2;//.............return statmentM;} 单参数语法 123456param1 -&gt; {statment1;statment2;//.............return statmentM;} 当lambda表达式的参数个数只有一个，可以省略小括号 例如：将列表中的字符串转换为全小写 12List&lt;String&gt; proNames = Arrays.asList(new String[]{&quot;Ni&quot;,&quot;Hao&quot;,&quot;Lambda&quot;});List&lt;String&gt; lowercaseNames1 = proNames.stream().map(name -&gt; {return name.toLowerCase();}).collect(Collectors.toList()); 单语句写法 1param1 -&gt; statment 当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号 例如：将列表中的字符串转换为全小写 12List&lt;String&gt; proNames = Arrays.asList(new String[]{&quot;Ni&quot;,&quot;Hao&quot;,&quot;Lambda&quot;});List&lt;String&gt; lowercaseNames2 = proNames.stream().map(name -&gt; name.toLowerCase()).collect(Collectors.toList()); 方法引用写法 具体可参考本站”java8新特性-方法引用” 例如：将列表中的字符串转换为全小写 12List&lt;String&gt; proNames = Arrays.asList(new String[]{&quot;Ni&quot;,&quot;Hao&quot;,&quot;Lambda&quot;});List&lt;String&gt; lowercaseNames3 = proNames.stream().map(String::toLowerCase).collect(Collectors.toList()); lambda表达式变量12345678//将为列表中的字符串添加前缀字符串String waibu = &quot;lambda :&quot;;List&lt;String&gt; proStrs = Arrays.asList(new String[]{&quot;Ni&quot;,&quot;Hao&quot;,&quot;Lambda&quot;});List&lt;String&gt;execStrs = proStrs.stream().map(chuandi -&gt; {Long zidingyi = System.currentTimeMillis();return waibu + chuandi + &quot; -----:&quot; + zidingyi;}).collect(Collectors.toList());execStrs.forEach(System.out::println); 输出如下: lambda :Ni —–:1474622341604 lambda :Hao —–:1474622341604 lambda :Lambda —–:1474622341604 变量解释: 变量waibu ：外部变量 变量chuandi ：传递变量 变量zidingyi ：内部自定义变量 解读如下: lambda表达式访问外部变量有一个非常重要的限制： 变量不可变（只是引用不可变，而不是真正的不可变）。 当在表达式内部修改waibu = waibu + “ “;时，IDE就会提示你： Local variable waibu defined in an enclosing scope must be final or effectively final 编译时会报错。因为变量waibu被lambda表达式引用，所以编译器会隐式的把其当成final来处理。 以前Java的匿名内部类在访问外部变量的时候，外部变量必须用final修饰。现在java8对这个限制做了优化，可以不用显示使用final修饰，但是编译器隐式当成final来处理。 Java8中的lambda表达式,并不是完全闭包，lambda表达式对值封闭，不对变量封闭。简单点来说就是局部变量在lambda表达式中如果要使用，必须是声明final类型或者是隐式的final。其内部使用静态变量或者实例变量则不会出现问题，这是因为final、static、实例变量等存放在堆区，线程间可共享，而局部在栈区线程间不共享，将导致被回收的风险，如果是多线程使用lambda表达式存在不安全因素。 lambda表达式中的this在lambda中，this不是指向lambda表达式产生的那个SAM对象，而是声明它的外部类对象。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/4/15/lambda/"},{"title":"java8新特性-方法引用","text":"作用相较于lambda表达式,通过方法引用的方式使程序代码更加易读\\自然,是进一步简化lambda表达式的声明的一种语法糖. 用法lambda表达式如下: 1list.sort(Comparator.comparing((String s) -&gt; s.length())); 方法引用如下: 1list.sort(Comparator.comparing(String::length)); 适用条件 适用于静态方法\\实例方法\\构造方法 方法对应的参数必须是函数式编程接口,如上例中的comparing 通过::来分割类名和方法名 参考内容: [1]https://www.jianshu.com/p/4309519a25d0 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/4/15/instanceMethod/"},{"title":"java8新特性-构造器引用","text":"作用相较于lambda表达式,通过构造器引用的方式使程序代码更加易读\\自然,是进一步简化lambda表达式的声明的一种语法糖.(与方法应用相同) 用法lambda表达式如下: 1Supplier&lt;Apple&gt; c1 = () -&gt; new Apple(); 方法引用如下: 1Supplier&lt;Apple&gt; c1 = Apple::new; 适用条件 适用于构造方法 方法对应的参数必须是函数式编程接口 通过::来分割类名和方法名 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/4/15/constructor/"},{"title":"java中annotation注解详解","text":"什么是注解对于很多初次接触的开发者来说应该都有这个疑问？**Annontation**是Java5开始引入的新特征，中文名称叫注解。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。 Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。 注解的作用是什么 生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等 跟踪代码依赖性，实现替代配置文件功能。比如Dagger 2 依赖注入，未来java 开发，将大量注解配置，具有很大用处; 在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。 源码/代码详解元注解元注解是指注解的注解。 Annotation型定义为@interface, 所有的Annotation会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口. 参数成员只能用public或默认(default)这两个访问权修饰 参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String、Enum、Class、annotations等数据类型,以及这一些类型的数组. 要获取类方法和字段的注解信息，必须通过Java的反射机制来获取 Annotation对象,因为你除此之外没有别的获取注解对象的方法 注解也可以没有定义成员 元注解包括 @Retention @Target @Document @Inherited四种 @Target：用于标注该注解适应的目标 1234567ElemenetType.CONSTRUCTOR 构造器声明ElemenetType.FIELD 域声明(包括 enum 实例) ElemenetType.LOCAL_VARIABLE 局部变量声明 ElemenetType.METHOD 方法声明 ElemenetType.PACKAGE 包声明 ElemenetType.PARAMETER 参数声明 ElemenetType.TYPE 类，接口(包括注解类型)或enum声明 @Retention：用于标注该注解的生命周期 123RetentionPolicy.SOURCE 注解将被编译器丢弃 RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃 RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息 @Document：指示将该注解包含在javadoc中 @Inherited：指示允许子类继承父类中的注解 @Repeatable:用于标识该自定义注解可以被重复标注到同一个对象，并指定容器 示例如下： 12345678910111213141516@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Persons {Person[] value();}@Repeatable(Persons.class)public @interface Person{String role() default &quot;&quot;;}@Person(role=&quot;father&quot;)@Person(role=&quot;son&quot;)public class Man {String name=&quot;&quot;;} 内置注解在java.lang中包含三种内置注解 @Override，表示当前方法定义将覆盖超类中的方法，如果签名出错会收到编译器的提示； @Deprecated，表示过期或不推荐的方法； @SuppressWarnings，关闭不当的编译器警告信息。 自定义注解自定义注解即通过元注解来构建自己需要的注解 12345678910111213141516171819@Target({METHOD})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface RestMethod {Class&lt;?&gt; queryClass() default ObjectUtils.Null.class;boolean login() default false;long ttl() default 0;boolean parseOpenId() default false;boolean useCookie() default false;boolean headerContext() default true;} 注解的底层实现机制 annotation的底层实现机制如上图所示，注解本质是一个继承了Annotation 的特殊接口，而该接口的具体实现类是Java 运行时生成的动态代理类。我们可以通过反射获取注解，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。 注解的具体使用如上所属注解的实现机制是通过反射，那么在使用时无论何种业务、何种途径归根结底都是通过JVM提供的反射机制实现获取注解和使用，因此我们要构建自己的“注解处理器”，常见如下途径： 注解与拦截器结合：通过拦截器传递的handler参数获取反射对象进而获取注解 注解与AOP结合：通过AOP传递的ProceedingJoinPoint参数获取反射对象进而获取注解 参考资料： [1]https://www.cnblogs.com/lbangel/p/3523741.html var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/30/javaannotation/"},{"title":"java中三目运算符踩过的坑","text":"这是一个什么样的坑?直接上代码: 12//H付款方式Integer hPaymentWayId = fullfillDTOShip != null ? fullfillDTOShip.getHPaymentWayId() : 0; 看似正常的代码在遇到fullfillDTOShip.getHPaymentWayId()为null时会报NPE错误,为什么会这样呢? 重新认识java中的三目运算符以JDK8为例通过JLS我们知道三目运算符形如下:(JDK7略有差异详情可看JLS7) 1234条件表达式：ConditionalOrExpressionConditionalOrExpression ? 表达式 : ConditionalExpressionConditionalOrExpression ? 表达式 : LambdaExpression 三目运算符由?:将整体表达式分为三部分,依此称为第一操作数\\第二操作数\\第三操作数其中第一操作数被硬性要求必须为Boolean类型表达式,而整个三目运算符的运算结果由第二\\第三操作数共同决定,就因为这个共同决定造成了我们本文开头的问题. 第二操作数与第三操作数只能是布尔条件表达式\\数值条件表达式\\参考条件表达式,而第二和第三操作数所对应的不同表达式类型共同作用完整三目表达式结果,其中涉及到拆装箱问题(即引起NPE问题的元凶) 布尔条件表达式布尔条件表达式的类型确定如下： 如果第二和第三操作数均为type Boolean，则条件表达式的类型为Boolean。 否则，条件表达式的类型为boolean。 总结以下:如果第二或第三操作数其中之一是原始类型,那么整个三目表达式结果即为原始boolean类型,否则全为原始类型或全为封装类型则最终表达式一致. 这里就会出现NPE风险,例如 123Boolean bo3 = (1 == 1 ? fullfillShipDTO.getIsActive() : false);System.out.print(&quot;bo3\\n&quot;);System.out.print(bo3 + &quot;\\n&quot;); 以上代码会报错,经过反编译我们可以找到原因: 123Boolean bo3 = (boolean)fullfillShipDTO.getIsActive();System.out.print(&quot;bo3\\n&quot;);System.out.print(bo3 + &quot;\\n&quot;); 如果fullfillShipDTO.getIsActive()为null那么此时进行拆箱操作必定会报NPE. 数值条件表达式数值条件表达式的类型确定如下： 如果第二个和第三个操作数具有相同的类型，那么这就是条件表达式的类型。 如果第二和第三个操作数中的一个是原始类型的Ť，其它的类型是施加装箱转换（结果§5.1.7）到Ť，那么条件表达式的类型是Ť。 如果其中一个操作数的类型为byte或Byte，而另一个操作符的类型为short或Short，则条件表达式的类型为short。 如果操作数之一的类型为Ť其中Ť是byte，short，或char，另一操作数为常量表达式（§15.28型的）int，它的值是在式表示的Ť，那么条件表达式的类型是Ť。 如果一个操作数的类型为T，其中T为Byte，Short或Character，而另一个操作数为类型int的常量表达式，其值可表示为U型，这是对T进行拆箱转换的结果，则类型为条件表达式是ü。 否则，将二进制数值提升（第5.6.2节）应用于操作数类型，条件表达式的类型是第二和第三操作数的提升类型。 请注意，二进制数值升级会执行值集转换（第5.1.13节），并且可能会执行拆箱转换（第5.1.8节）。 总结以下:同布尔条件表达式相同如果第二或第三操作数其中之一是原始类型,那么整个三目表达式结果即为原始类型,否则全为原始类型或全为封装类型则最终表达式一致. 例如: 12345678910111213141516//2.数值条件表达式 Integer in1 = 1 == 1 ? 1 : 0; System.out.print(&quot;in1\\n&quot;); System.out.print(in1 + &quot;\\n&quot;); Integer in2 = 1 == 1 ? Integer.valueOf(1) : Integer.valueOf(0); System.out.print(&quot;in2\\n&quot;); System.out.print(in2 + &quot;\\n&quot;); Integer in3 = (1 == 1 ? 0 : fullfillShipDTO.getHPaymentWayId()); System.out.print(&quot;in3\\n&quot;); System.out.print(in3 + &quot;\\n&quot;); Integer in4 = 1 == 1 ? fullfillShipDTO.getHPaymentWayId() : 0; System.out.print(&quot;in4\\n&quot;); System.out.print(in4 + &quot;\\n&quot;); 上例中in4会报错,其它正常执行,通过反编译代码我们发现: 123456789101112Integer in1 = 1; System.out.print(&quot;in1\\n&quot;); System.out.print(in1 + &quot;\\n&quot;); Integer in2 = 1; System.out.print(&quot;in2\\n&quot;); System.out.print(in2 + &quot;\\n&quot;); Integer in3 = 0; System.out.print(&quot;in3\\n&quot;); System.out.print(in3 + &quot;\\n&quot;); Integer in4 = (int)fullfillShipDTO.getHPaymentWayId(); System.out.print(&quot;in4\\n&quot;); System.out.print(in4 + &quot;\\n&quot;); 如果fullfillShipDTO.getHPaymentWayId()为null在进行拆箱操作时报NPE 值得注意的是in3并不报错,因为返回结果直接为第二操作数的0而不会对第三操作数进行拆箱操作 参考(引用)条件表达式如果参考条件表达式出现在分配上下文或调用上下文中（第5.2节，第5.3节），则它是一个多边形表达式。否则，它是一个独立的表达式。 当多引用条件表达式出现在目标类型为T的特定种类的上下文中时，其第二和第三操作数表达式类似地出现在目标类型为T的相同种类的上下文中。 多边形引用条件表达式的类型与其目标类型相同。 独立引用条件表达式的类型确定如下： 如果第二个操作数和第三个操作数具有相同的类型（可能是null类型），则这是条件表达式的类型。 如果第二个操作数和第三个操作数之一的类型为空类型，而另一个操作数的类型为引用类型，则条件表达式的类型为该引用类型。 否则，第二和第三操作数分别为S 1和S 2类型。令T 1为对S 1进行装箱转换所产生的类型，而T 2为对S 2进行装箱转换所产生的类型。条件表达式的类型是将捕获转换（第5.1.10节）应用于lub（T 1，T的结果2）。 参考条件表达式的含义是其可以为lambda表达式\\Map\\集合\\自定义对象等 总结以下:当二\\三操作数相同类型时表达式的值即为该类型,否则若出现不同则根据第二或第三操作数所对应的非原始类型进行装箱转换操作,不进行拆箱操作 参考条件表达式相对安全,如下: 123456789101112Map&lt;String, Boolean&gt; map = new HashMap&lt;&gt;(); Boolean reference1 = (map != null ? map.get(&quot;test&quot;) : map.get(&quot;test2&quot;)); System.out.print(&quot;reference1\\n&quot;); System.out.print(reference1 + &quot;\\n&quot;); Boolean reference2 = (map != null ? map.get(&quot;test&quot;) : null); System.out.print(&quot;reference2\\n&quot;); System.out.print(reference2 + &quot;\\n&quot;); Boolean reference3 = (map != null ? true : map.get(&quot;test&quot;)); System.out.print(&quot;reference3\\n&quot;); System.out.print(reference3 + &quot;\\n&quot;); 如上代码分别对应参考条件表达式三种状态,均不会报NPE错误,伪代码如下: 12345678910HashMap map = new HashMap(); Boolean reference1 = map != null ? (Boolean)map.get(&quot;test&quot;) : (Boolean)map.get(&quot;test2&quot;); System.out.print(&quot;reference1\\n&quot;); System.out.print(reference1 + &quot;\\n&quot;); Boolean reference2 = map != null ? (Boolean)map.get(&quot;test&quot;) : null; System.out.print(&quot;reference2\\n&quot;); System.out.print(reference2 + &quot;\\n&quot;); Boolean reference3 = map != null ? Boolean.valueOf(true) : (Boolean)map.get(&quot;test&quot;); System.out.print(&quot;reference3\\n&quot;); System.out.print(reference3 + &quot;\\n&quot;); 根据reference3可知即使是原始类型true也将会根据S2做装箱操作. 参考内容: [1]https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.25 [2]http://www.hollischuang.com/archives/58 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/12/6/ternary/"},{"title":"java中关键字","text":"1. 访问控制private私有的private 关键字是访问控制修饰符，可以应用于类、方法或字段（在类中声明的变量）。 只能在声明 private（内部）类、方法或字段的类中引用这些类、方法或字段。在类的外部或者对于子类而言，它们是不可见的。 所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。 protected受保护的protected 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。可以在声明 protected 类、方法或字段的类、同一个包中的其他任何类以及任何子类（无论子类是在哪个包中声明的）中引用这些类、方法或字段。所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。 public公共的public 关键字是可以应用于类、方法或字段（在类中声明的变量）的访问控制修饰符。 可能只会在其他任何类或包中引用 public 类、方法或字段。所有类成员的默认访问范围都是 package 访问，也就是说，除非存在特定的访问控制修饰符，否则，可以从同一个包中的任何类访问类成员。 2. 类、方法和变量修饰符abstract声明抽象abstract关键字可以修改类或方法。abstract类可以扩展（增加子类），但不能直接实例化。abstract方法不在声明它的类中实现，但必须在某个子类中重写。采用 abstract方法的类本来就是抽象类，并且必须声明为abstract。 class类class 关键字用来声明新的 Java 类，该类是相关变量和/或方法的集合。类是面向对象的程序设计方法的基本构造单位。类通常代表某种实际实体，如几何形状或人。类是对象的模板。每个对象都是类的一个实例。要使用类，通常使用 new 操作符将类的对象实例化，然后调用类的方法来访问类的功能。 extends继承、扩展extends 关键字用在 class 或 interface 声明中，用于指示所声明的类或接口是其名称后跟有 extends 关键字的类或接口的子类。子类继承父类的所有 public 和 protected 变量和方法。 子类可以重写父类的任何非 final 方法。一个类只能扩展一个其他类。 final最终、不可改变final 关键字可以应用于类，以指示不能扩展该类（不能有子类）。final 关键字可以应用于方法，以指示在子类中不能重写此方法。一个类不能同时是 abstract 又是 final。abstract 意味着必须扩展类，final 意味着不能扩展类。一个方法不能同时是 abstract 又是 final。abstract 意味着必须重写方法，final 意味着不能重写方法。 implements实现implements 关键字在 class 声明中使用，以指示所声明的类提供了在 implements 关键字后面的名称所指定的接口中所声明的所有方法的实现。类必须提供在接口中所声明的所有方法的实现。一个类可以实现多个接口。 interface接口interface 关键字用来声明新的 Java 接口，接口是方法的集合。 接口是 Java 语言的一项强大功能。任何类都可声明它实现一个或多个接口，这意味着它实现了在这些接口中所定义的所有方法。 实现了接口的任何类都必须提供在该接口中的所有方法的实现。一个类可以实现多个接口。 native 本地native 关键字可以应用于方法，以指示该方法是用 Java 以外的语言实现的。 new创建new 关键字用于创建类的新实例。 new 关键字后面的参数必须是类名，并且类名的后面必须是一组构造方法参数（必须带括号）。 参数集合必须与类的构造方法的签名匹配。 = 左侧的变量的类型必须与要实例化的类或接口具有赋值兼容关系。 static静态static 关键字可以应用于内部类（在另一个类中定义的类）、方法或字段（类的成员变量）。 通常，static 关键字意味着应用它的实体在声明该实体的类的任何特定实例外部可用。 static（内部）类可以被其他类实例化和引用（即使它是顶级类）。在上面的示例中，另一个类中的代码可以实例化 MyStaticClass 类，方法是用包含它的类名来限定其名称，如 MyClass.MyStaticClass。 static 字段（类的成员变量）在类的所有实例中只存在一次。 可以从类的外部调用 static 方法，而不用首先实例化该类。这样的引用始终包括类名作为方法调用的限定符。 模式：public final static varName = ; 通常用于声明可以在类的外部使用的类常量。在引用这样的类常量时需要用类名加以限定。在上面的示例中，另一个类可以用 MyClass.MAX_OBJECTS 形式来引用 MAX_OBJECTS 常量。 strictfp严格、精准strictfp的意思是FP-strict，也就是说精确浮点的意思。在Java虚拟机进行浮点运算时，如果没有指定strictfp关键字时，Java的编译器以及运行环境在对浮点运算的表达式是采取一种近似于我行我素的行为来完成这些操作，以致于得到的结果往往无法令人满意。而一旦使用了strictfp来声明一个类、接口或者方法时，那么所声明的范围内Java的编译器以及运行环境会完全依照浮点规范IEEE-754来执行。因此如果想让浮点运算更加精确，而且不会因为不同的硬件平台所执行的结果不一致的话，那就请用关键字strictfp。 可以将一个类、接口以及方法声明为strictfp，但是不允许对接口中的方法以及构造函数声明strictfp关键字 11) \\synchronized**线程、同步****synchronized 关键字可以应用于方法或语句块，并为一次只应由一个线程执行的关键代码段提供保护。 synchronized 关键字可防止代码的关键代码段一次被多个线程执行。 如果应用于静态方法，那么，当该方法一次由一个线程执行时，整个类将被锁定。 如果应用于实例方法，那么，当该方法一次由一个线程访问时，该实例将被锁定。 如果应用于对象或数组，当关联的代码块一次由一个线程执行时，对象或数组将被锁定。 12) \\transient **短暂****transient 关键字可以应用于类的成员变量，以便指出该成员变量不应在包含它的类实例已序列化时被序列化。 当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。 transient是Java语言的关键字，用来表示一个域不是该对象串行化的一部分。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 13) \\volatile **易失****volatile 关键字用于表示可以被多个线程异步修改的成员变量。 注意：volatile 关键字在许多 Java 虚拟机中都没有实现。 volatile 的目标用途是为了确保所有线程所看到的指定变量的值都是相同的。 Java 语言中的 volatile 变量可以被看作是一种 “程度较轻的 synchronized”；与 synchronized 块相比，volatile 变量所需的编码较少，并且运行时开销也较少，但是它所能实现的功能也仅是 synchronized 的一部分。 3. 程序控制语句1) \\break **跳出，中断****break 关键字用于提前退出 for、while 或 do 循环，或者在 switch 语句中用来结束 case 块。 break 总是退出最深层的 while、for、do 或 switch 语句。 2) \\continue **继续****continue 关键字用来跳转到 for、while 或 do 循环的下一个迭代。 continue 总是跳到最深层 while、for 或 do 语句的下一个迭代。 3) \\return **返回****return 关键字会导致方法返回到调用它的方法，从而传递与返回方法的返回类型匹配的值。 如果方法具有非 void 的返回类型，return 语句必须具有相同或兼容类型的参数。 返回值两侧的括号是可选的。 4) \\do **运行****do 关键字用于指定一个在每次迭代结束时检查其条件的循环。 do 循环体至少执行一次。 条件表达式后面必须有分号。 5) \\while **循环****while 关键字用于指定一个只要条件为真就会重复的循环。 6) \\if **如果****if 关键字指示有条件地执行代码块。条件的计算结果必须是布尔值。 if 语句可以有可选的 else 子句，该子句包含条件为 false 时将执行的代码。 包含 boolean 操作数的表达式只能包含 boolean 操作数。 7) \\else **否则****else 关键字总是在 if-else 语句中与 if 关键字结合使用。else 子句是可选的，如果 if 条件为 false，则执行该子句。 8) \\for **循环****for 关键字用于指定一个在每次迭代结束前检查其条件的循环。 for 语句的形式为 for(initialize; condition; increment) 控件流进入 for 语句时，将执行一次 initialize 语句。 每次执行循环体之前将计算 condition 的结果。如果 condition 为 true，则执行循环体。 每次执行循环体之后，在计算下一个迭代的 condition 之前，将执行 increment 语句。 9) \\instanceof **实例****instanceof 关键字用来确定对象所属的类。 10) \\switch **观察****switch 语句用于基于某个表达式选择执行多个代码块中的某一个。 switch 条件的计算结果必须等于 byte、char、short 或 int。 case 块没有隐式结束点。break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。 如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。 11) \\case **返回观察里的结果****case 用来标记 switch 语句中的每个分支。 case 块没有隐式结束点。break 语句通常在每个 case 块末尾使用，用于退出 switch 语句。 如果没有 break 语句，执行流将进入所有后面的 case 和/或 default 块。 12) \\default **默认****default 关键字用来标记 switch 语句中的默认分支。 default 块没有隐式结束点。break 语句通常在每个 case 或 default 块的末尾使用，以便在完成块时退出 switch 语句。 如果没有 default 语句，其参数与任何 case 块都不匹配的 switch 语句将不执行任何操作。 4. 错误处理1) \\try **捕获异常****try 关键字用于包含可能引发异常的语句块。 每个 try 块都必须至少有一个 catch 或 finally 子句。 如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。 2) \\catch **处理异常****catch 关键字用来在 try-catch 或 try-catch-finally 语句中定义异常处理块。 开始和结束标记 { 和 } 是 catch 子句语法的一部分，即使该子句只包含一个语句，也不能省略这两个标记。 每个 try 块都必须至少有一个 catch 或 finally 子句。 如果某个特定异常类未被任何 catch 子句处理，该异常将沿着调用栈递归地传播到下一个封闭 try 块。如果任何封闭 try 块都未捕获到异常，Java 解释器将退出，并显示错误消息和堆栈跟踪信息。 3) \\throw **抛出一个异常对象****throw 关键字用于引发异常。 throw 语句将 java.lang.Throwable 作为参数。Throwable 在调用栈中向上传播，直到被适当的 catch 块捕获。 引发非 RuntimeException 异常的任何方法还必须在方法声明中使用 throws 修饰符来声明它引发的异常。 4) \\throws **声明一个异常可能被抛出****throws 关键字可以应用于方法，以便指出方法引发了特定类型的异常。 throws 关键字将逗号分隔的 java.lang.Throwables 列表作为参数。 引发非 RuntimeException 异常的任何方法还必须在方法声明中使用 throws 修饰符来声明它引发的异常。 要在 try-catch 块中包含带 throws 子句的方法的调用，必须提供该方法的调用者。 5. 包相关1) \\import **引入****import 关键字使一个包中的一个或所有类在当前 Java 源文件中可见。可以不使用完全限定的类名来引用导入的类。 当多个包包含同名的类时，许多 Java 程序员只使用特定的 import 语句（没有“*”）来避免不确定性。 2) \\package **包****package 关键字指定在 Java 源文件中声明的类所驻留的 Java 包。 package 语句（如果出现）必须是 Java 源文件中的第一个非注释性文本。 例:java.lang.Object。 如果 Java 源文件不包含 package 语句，在该文件中定义的类将位于“默认包”中。请注意，不能从非默认包中的类引用默认包中的类。 6. 基本类型1) \\boolean **布尔型****1字节-8位-最大存储2^8 -1个对象 boolean 是 Java 原始类型。boolean 变量的值可以是 true 或 false。 boolean 变量只能以 true 或 false 作为值。boolean 不能与数字类型相互转换。 包含 boolean 操作数的表达式只能包含 boolean 操作数。 Boolean 类是 boolean 原始类型的包装对象类。 2) \\byte **字节型****1字节-8位-最大存储2^8 -1个对象 byte 是 Java 原始类型。byte 可存储在 [-128, 127] 范围以内的整数值。 Byte 类是 byte 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。 Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。 3) \\char **字符型****2字节-16位-最大存储2^16 -1个对象 char 是 Java 原始类型。char 变量可以存储一个 Unicode 字符。 可以使用下列 char 常量：\\b - 空格, \\f - 换页, \\n - 换行, \\r - 回车, \\t - 水平制表符, ' - 单引号, &quot; - 双引号, \\ - 反斜杠, \\xxx - 采用 xxx 编码的 Latin-1 字符。\\x 和 \\xx 均为合法形式，但可能引起混淆。 \\uxxxx - 采用十六进制编码 xxxx 的 Unicode 字符。 Character 类包含一些可用来处理 char 变量的 static 方法，这些方法包括 isDigit()、isLetter()、isWhitespace() 和 toUpperCase()。 char 值没有符号。 4) \\double **双精度****8字节-64位-最大存储2^64 -1个对象 double 是 Java 原始类型。double 变量可以存储双精度浮点值。 由于浮点数据类型是实际数值的近似值，因此，一般不要对浮点数值进行是否相等的比较。 Java 浮点数值可代表无穷大和 NaN（非数值）。Double 包装对象类用来定义常量 MIN_VALUE、MAX_VALUE、NEGATIVE_INFINITY、POSITIVE_INFINITY 和 NaN。 5) \\float **浮点****4字节-32位-最大存储2^32 -1个对象 float 是 Java 原始类型。float 变量可以存储单精度浮点值。 使用此关键字时应遵循下列规则： Java 中的浮点文字始终默认为双精度。要指定单精度文字值，应在数值后加上 f 或 F，如 0.01f。 由于浮点数据类型是实际数值的近似值，因此，一般不要对浮点数值进行是否相等的比较。 Java 浮点数值可代表无穷大和 NaN（非数值）。Float 包装对象类用来定义常量 MIN_VALUE、MAX_VALUE、NEGATIVE_INFINITY、POSITIVE_INFINITY 和 NaN。 6) \\int **整型****4字节-32位-最大存储2^32 -1个对象 int 是 Java 原始类型。int 变量可以存储 32 位的整数值。 Integer 类是 int 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。 Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。 7) \\long **长整型****8字节-64位-最大存储2^64 -1个对象 long 是 Java 原始类型。long 变量可以存储 64 位的带符号整数。 Long 类是 long 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。 Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。 8) \\short **短整型****2字节-16位-最大存储2^16 -1个对象 short 是 Java 原始类型。short 变量可以存储 16 位带符号的整数。 Short 类是 short 原始类型的包装对象类。它定义代表此类型的值的范围的 MIN_VALUE 和 MAX_VALUE 常量。 Java 中的所有整数值都是 32 位的 int 值，除非值后面有 l 或 L（如 235L），这表示该值应解释为 long。 9) \\null **空****null 是 Java 的保留字，表示无值。 将 null 赋给非原始变量相当于释放该变量先前所引用的对象。 不能将 null 赋给原始类型（byte、short、int、long、char、float、double、boolean）变量。 10) \\t**rue **真********true 关键字表示 boolean 变量的两个合法值中的一个。 11) \\false **假****false 关键字代表 boolean 变量的两个合法值之一。 7. 变量引用1) \\super **父类**,**超类********super 关键字用于引用使用该关键字的类的超类。 作为独立语句出现的 super 表示调用超类的构造方法。 super.() 表示调用超类的方法。只有在如下情况中才需要采用这种用法：要调用在该类中被重写的方法，以便指定应当调用在超类中的该方法。 2) \\this **本类****this 关键字用于引用当前实例。 当引用可能不明确时，可以使用 this 关键字来引用当前的实例。 3) \\void **无返回值****void 关键字表示 null 类型。 void 可以用作方法的返回类型，以指示该方法不返回值。 8. 保留字正确识别java语言的关键字（keyword）和保留字（reserved word）是十分重要的。Java的关键字对java的编译器有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等。保留字是为java预留的关键字，他们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。 识别java语言的关键字，不要和其他语言如c/c++的关键字混淆。 const和goto是java的保留字。 所有的关键字都是小写 1) \\goto **跳转****goto 保留关键字，但无任何作用。结构化程序设计完全不需要 goto 语句即可完成各种流程，而 goto 语句的使用往往会使程序的可读性降低，所以 Java 不允许 goto 跳转。 2) \\const **静态****const 保留字，是一个类型修饰符，使用const声明的对象不能更新。与final某些类似。 3) \\native **本地**** Java不是完美的，Java的不足除了体现在运行速度上要比传统的C++慢许多之外，Java无法直接访问到操作系统底层（如系统硬件等)，为此Java使用native方法来扩展Java程序的功能。 可以将native方法比作Java程序同Ｃ程序的接口，其实现步骤： １、在Java中声明native()方法，然后编译； ２、用javah产生一个.h文件； ３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）； ４、将第三步的.cpp文件编译成动态链接库文件； ５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/7/keyword/"},{"title":"java中对List的排序","text":"简介java中的排序本质上是实现对待排序对象的比较,即借助比较器实现排序,例如Comparator和Comparable等.当对象具备比较功能那么可以借助集合工具的排序算法来实现具体排序,例如Collections.sort以及stream.sort等.详细信息可参考[java中的比较器Comparable与Comparator] 具体方案测试模型 12345678910111213141516171819202122public class student implements Comparable&lt;student&gt;{ int age; int grade; //重写默认比较器---升序 @Override public int compareTo(student o){ // 入参o:可以理解为排序队列中的前一个对象,即被比较对象 // this:理解为排序队列的后一个对象,即比较对象 if(o.getAge() &gt; this.getAge()){ return -1; }else if(o.getAge() &lt; this.getAge()){ //解读:如果前一个对象小于后一个对象,那么符合我们的目标排序规则,则返回1 //因此我们可以想象一下,前小后大的序列是升序序列,以此我们可以理解降序序列 return 1; }else { return 0; } }} 先上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//创建测试数组 private List&lt;student&gt; students = Lists.newArrayList();@Test public void sortMethod() { //初始化测试数组 students.add(student.builder().age(10).build()); students.add(student.builder().age(30).build()); students.add(student.builder().age(50).build()); students.add(student.builder().age(10).build()); students.add(student.builder().age(20).build()); students.add(student.builder().age(40).build()); students.add(student.builder().age(60).build()); //Comparable实践 //1.借助student类中实现的Comparable接口完成排序 //Collections.sort(students); //students = students.stream().sorted(); //Comparator实践 //1.匿名内部类实现排序 Collections.sort(students, new Comparator&lt;student&gt;() { @Override public int compare(student o1, student o2) { // 入参o:可以理解为排序队列中的前一个对象,即被比较对象 // this:理解为排序队列的后一个对象,即比较对象 if (o1.getAge() &gt; o2.getAge()) { return -1; } else if (o1.getAge() &lt; o2.getAge()) { //解读:如果前一个对象小于后一个对象,那么符合我们的目标排序规则,则返回1 //因此我们可以想象一下,前小后大的序列是升序序列,以此我们可以理解降序序列 return 1; } else { return 0; } } }); //2.借助stream的sort //根据年龄排序 students = students.stream().sorted(Comparator.comparing(student::getAge)).collect(Collectors.toList()); //根据年龄排序-反序 students = students.stream().sorted(Comparator.comparing(student::getAge).reversed()).collect(Collectors.toList()); //先根据年龄排序-如果遇到相等则再根据分数排序 students = students.stream().sorted(Comparator.comparing(student::getAge).thenComparing(student::getGrade)).collect(Collectors.toList()); } 总结 排序的基础和前提是比较,若要实现比较则必须借助Comparator或Comparable(具体可参考[java中的比较器Comparable与Comparator]),在比较实现后可借助集合工具内置排序算法进行排序. var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/4/7/list_sort/"},{"title":"java中的string、stringbuilder、stringbuffer","text":"String String str=”hello world”和String str=new String(“hello world”)的区别，前者存放在运行时常量池，后者存放在堆中。 String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。 String类其实是通过char数组来保存字符串的 对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象 StringBuilder 为字符串操作提供更加便捷的方法 StringBuffer 为字符串操作提供更加便捷的方法 内部方法由synchronized修饰，即线程安全的 常见问题 下面这段代码的输出结果是什么？ String a = “hello2”; String b = “hello” + 2; System.out.println((a == b)); 输出结果为：true。原因很简单，”hello”+2在编译期间就已经被优化成”hello2”，因此在运行期间，变量a和变量b指向的是同一个对象。 2.下面这段代码的输出结果是什么？ String a = “hello2”; String b = “hello”; String c = b + 2; System.out.println((a == c)); 输出结果为:false。由于有符号引用的存在，所以 String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。 3.下面这段代码的输出结果是什么？ String a = “hello2”; final String b = “hello”; String c = b + 2; System.out.println((a == c)); 输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。 4.String str = new String(“abc”)创建了多少个对象？ 这个问题在很多书籍上都有说到比如《Java程序员面试宝典》，包括很多国内大公司笔试面试题都会遇到，大部分网上流传的以及一些面试书籍上都说是2个对象，这种说法是片面的。 很显然，new只调用了一次，也就是说只创建了一个对象。 而这道题目让人混淆的地方就是这里，这段代码在运行期间确实只创建了一个对象，即在堆上创建了”abc”对象。而为什么大家都在说是2个对象呢，这里面要澄清一个概念 该段代码执行过程和类的加载过程是有区别的。在类加载的过程中，确实在运行时常量池中创建了一个”abc”对象，而在代码执行过程中确实只创建了一个String对象。 因此，这个问题如果换成 String str = new String(“abc”)涉及到几个String对象？合理的解释是2个。 个人觉得在面试的时候如果遇到这个问题，可以向面试官询问清楚”是这段代码执行过程中创建了多少个对象还是涉及到多少个对象“再根据具体的来进行回答。 5.下面这段代码输出结果为： 123456789101112public class Main { public static void main(String[] args) { String a = &quot;hello2&quot;; final String b = getHello(); String c = b + 2; System.out.println((a == c)); } public static String getHello() { return &quot;hello&quot;; }} 输出结果为false。这里面虽然将b用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定，因此a和c指向的不是同一个对象。 6.下面这段代码的输出结果是什么？ 123456789101112 public static void main(String[] args) { String a = &quot;hello&quot;; String b = new String(&quot;hello&quot;); String c = new String(&quot;hello&quot;); String d = b.intern(); System.out.println(a==b); System.out.println(b==c); System.out.println(b==d); System.out.println(a==d); }} False false false true 这里面涉及到的是String.intern方法的使用。在String类中，intern方法是一个本地方法，在JAVA SE6之前，intern方法会在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。因此，a和d指向的是同一个对象。 7.下面这段代码1）和2）的区别是什么？ 12345678public class Main { public static void main(String[] args) { String str1 = &quot;I&quot;; //str1 += &quot;love&quot;+&quot;java&quot;; 1) str1 = str1+&quot;love&quot;+&quot;java&quot;; //2) }} 1）的效率比2）的效率要高，1）中的”love”+”java”在编译期间会被优化成”lovejava”，而2）中的不会被优化。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/7/java-string/"},{"title":"java中的引用","text":"Java中的引用，有点像C++的指针。通过引用，可以对堆中的对象进行操作。在某函数中，当创建了一个对象，该对象被分配在堆中，通过这个对象的引用才能对这个对象进行操作。 123String str=new String(&quot;abc&quot;); // 强引用（abc被存放到堆中，str存放到栈中）SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str); // 软引用WeakReference&lt;String&gt; abcWeakRef = new WeakReference&lt;String&gt;(str);//弱引用 强引用：可以直接访问目标对象，任何时候都不会被JVM回收。显式地设置str为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。举例说明：方法中的str在方法执行完成后就会出栈，则引用内容的引用不存在，这个Object会被回收。 软引用：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 弱引用：在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来标记此对象。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/7/reference/"},{"title":"java中的时间精度","text":"一 前言今天线上业务发现了一个问题,业务需求是获取最新更新的XX一条记录(XX记录可能会有多条并且由于后面业务的影响XX记录的集合可能新增\\减少\\更新),因此通过sql语句查询并以updateTime做倒叙排序取第一条即可.然而事情并没有这么简单,实际使用发现获取最新一条数据并不稳定,仔细筛查发现数据库DateTime精度过低只精确到秒,这样有很大机率在updateTime上相同. 基于此需要提高updateTime的精度,如精确到毫秒(3)\\微妙(6),通过调整datetime精度即可 1ALTER TABLE `fulfill_shipping_contract` MODIFY COLUMN `updated_date` DATETIME(6) NOT NULL COMMENT '更新时间' ; 仅仅设置数据库时间精度还不够,需要编程语言支持高精度时间,以java为例进行java时间精度介绍. 二 时间基础 毫秒 millisecond 1ms 1毫秒=0.001秒=10-3秒 微秒 microsecond 1μs 1微秒=0.000001=10-6秒 纳秒 nanosecond 1ns 1纳秒=0.0000000001秒=10-9秒 皮秒 picosecond 1ps 1皮秒=0.0000000000001秒=10-12秒 飞秒 femtosecond 1fs 1飞秒=0.000000000000001秒=10-15秒 三 java中的时间精度3.1获取时间java.util.Date作为java日期对象的顶级类提供对时间的基本操作. 12System.out.print(&quot;时间测试\\n&quot;);System.out.print(new Date() + &quot;\\n&quot;); 继续观察我们可以发现Date()初始化于当前时间戳 123456789/** * Allocates a &lt;code&gt;Date&lt;/code&gt; object and initializes it so that * it represents the time at which it was allocated, measured to the * nearest millisecond. * * @see java.lang.System#currentTimeMillis() */public Date() { this(System.currentTimeMillis());} 3.2获取毫秒System.currentTimeMillis() 起始时间是基于 1970.1.1 0:00:00 这个确定的时间 123456Long milliseconds = System.currentTimeMillis();System.out.print(&quot;毫秒测试-毫秒\\n&quot;);System.out.print(milliseconds + &quot;\\n&quot;);System.out.print(&quot;毫秒测试-毫秒时间\\n&quot;);System.out.print(new Date(milliseconds) + &quot;\\n&quot;); 一般情况下保存到数据库中的时间精确到毫秒即可 3.3获取微秒1ms=1000us(一毫秒等于一千微秒),微秒在java中没有具体的方法提供,但是我们可以借助java提供的纳秒通过差值来计算微秒数值. 1234567Long nanoTimeStart = System.nanoTime();Long nanoTimeEnd = System.nanoTime();System.out.print(&quot;微妙测试-微妙\\n&quot;);System.out.print(nanoTimeEnd - nanoTimeStart + &quot;\\n&quot;); //得到六位数字,如166400System.out.print((nanoTimeEnd - nanoTimeStart)/1000L + &quot;\\n&quot;); //得到三位数字,如166System.out.print(&quot;微妙测试-毫秒转换成微秒\\n&quot;);System.out.print(milliseconds * 1000 + (nanoTimeEnd - nanoTimeStart) / 1000L + &quot;\\n&quot;); 得到的微秒结果将会是三位长整型数字,如166,但是以上代码可能会有风险,因为我们是通过纳秒差值来计算的微秒,而纳秒本身是继续cpu核心的原子钟周期来计时的,在多核处理器中这种分开取纳秒的方式很可能取自不同的内核,从而造成计算错误. 微秒无法通过现有手段直接获得,需要借助纳秒差值进行计算获得 微秒本质上代表的是两个时间上的微秒差异,因此并不会很精确 可以将毫秒转换成微秒,但是无法将转换后的结果生成日期时间对象 数据库支持微秒(即精度达到6,如2019-10-28 17:24:25.123456,其中123代表毫秒,456代表微秒)但是微秒无法转换为java中的日期对象,因此不能通过Date直接赋值的形式完成.针对此有两种解决方案: 将Date类型替换为字符类型并进行拼接如”2019-10-28 17:24:25.123456”,再更新至数据库 将毫秒时间与微秒时间存储在数据库表不同属性中,分别记录 3.4获取纳秒1s=1000000000ns System.nanoTime()此方法只能用于测量已过的时间，与系统或钟表时间的其他任何时间概念无关 返回值表示从某一固定但任意的时间算起的纳秒数（或许从以后算起，所以该值可能为负） System.nanoTime()是基于cpu核心的时钟周期来计时,它的开始时间是不确定的,因此纳秒的取值与操作系统有关 纳秒适合计算相对时间段,无法换算成具体时间 123Long nanoseconds = System.nanoTime();System.out.print(&quot;纳秒测试-纳秒\\n&quot;);System.out.print(nanoseconds + &quot;\\n&quot;); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2019/12/4/javatime/"},{"title":"java中的比较器Comparable与Comparator","text":"简介我们在java编码的过程中不可避免的会使用java中提供的集合对象,例如List,ArrayList等等,那么在使用集合的过程中有很大的几率会用到排序.回想一下在学习c语言的时候排序是如何实现的?没错,就是通过手写各种基础的排序算法实现排序(当然现在也有各种c语言的基础包可用),例如选择\\冒泡\\插入\\希尔\\二分法等等.在Java中我们当然也可以自己写排序算法实现排序,但是JDK已经提供一些基础的基于集合的排序接口供我们使用,因此无需特意自写算法.本文将介绍两种排序的实现方式Comparable与Comparator. Comparable首先我们举一个简单的例子，如下： 12345678910111213141516171819@Test public void integerSort(){ List&lt;Integer&gt; integers = Lists.newArrayList(); integers.add(5); integers.add(6); integers.add(1); integers.add(3); integers.add(4); integers.add(9); //排序前 printUtil.printList(integers); //排序--通过集合工具类Arrays Collections.sort(integers); //排序后 printUtil.printList(integers); } 执行结果如下： 125,6,1,3,4,9,1,3,4,5,6,9, 看到这里大家或许会有疑问？我们什么都没有做为什么代码自动实现了排序？ 那是因为我们的包装类型Integer内部已经继承并重写了comparable 123456789101112131415161718192021222324252627282930313233343536public final class Integer extends Number implements Comparable&lt;Integer&gt; { /** * Compares two {@code Integer} objects numerically. * * @param anotherInteger the {@code Integer} to be compared. * @return the value {@code 0} if this {@code Integer} is * equal to the argument {@code Integer}; a value less than * {@code 0} if this {@code Integer} is numerically less * than the argument {@code Integer}; and a value greater * than {@code 0} if this {@code Integer} is numerically * greater than the argument {@code Integer} (signed * comparison). * @since 1.2 */ public int compareTo(Integer anotherInteger) { return compare(this.value, anotherInteger.value); } /** * Compares two {@code int} values numerically. * The value returned is identical to what would be returned by: * &lt;pre&gt; * Integer.valueOf(x).compareTo(Integer.valueOf(y)) * &lt;/pre&gt; * * @param x the first {@code int} to compare * @param y the second {@code int} to compare * @return the value {@code 0} if {@code x == y}; * a value less than {@code 0} if {@code x &lt; y}; and * a value greater than {@code 0} if {@code x &gt; y} * @since 1.7 */ public static int compare(int x, int y) { return (x &lt; y) ? -1 : ((x == y) ? 0 : 1); }} 我们再来举例一个稍微复杂的例子： 12345678910111213141516171819202122public class student implements Comparable&lt;student&gt;{ int age; int grade; //重写默认比较器---升序 @Override public int compareTo(student o){ // 入参o:可以理解为排序队列中的前一个对象,即被比较对象 // this:理解为排序队列的后一个对象,即比较对象 if(o.getAge() &gt; this.getAge()){ return -1; }else if(o.getAge() &lt; this.getAge()){ //解读:如果前一个对象小于后一个对象,那么符合我们的目标排序规则,则返回1 //因此我们可以想象一下,前小后大的序列是升序序列,以此我们可以理解降序序列 return 1; }else { return 0; } }} 123456789101112131415161718192021222324@Test public void studentSortByAge(){ List&lt;student&gt; students = Lists.newArrayList(); students.add(student.builder().age(10).build()); students.add(student.builder().age(30).build()); students.add(student.builder().age(50).build()); students.add(student.builder().age(20).build()); students.add(student.builder().age(40).build()); students.add(student.builder().age(60).build()); //排序前 printUtil.printList(students); //排序--通过集合工具类Collections(底层是利用二分法实现的排序) Collections.sort(students); //排序--通过stream //students = students.stream().sorted().collect(Collectors.toList()); //排序后 printUtil.printList(students); } 输出结果如下： 1234排序前student(age=10, grade=0),student(age=30, grade=0),student(age=50, grade=0),student(age=20, grade=0),student(age=40, grade=0),student(age=60, grade=0)排序后student(age=10, grade=0),student(age=20, grade=0),student(age=30, grade=0),student(age=40, grade=0),student(age=50, grade=0),student(age=60, grade=0) 针对这种复杂的自定义模型排序我们需要模型自己继承和重写compareTo方法，很多人第一次接触该方法或许会感到疑惑，返回值只有三种（1、-1、0）分别代表什么含义？为什么这种纯数字的返回值就可以实现排序呢？ 首先要解答的是为什么返回1、-1、0就可以实现排序？ 答：comparable接口本质上是为类提供的比较接口，可以为类附加比较功能，比较的结果要么相等要么存在大小关系。借助比较结果，第三方就可以实现排序功能，例如Collections.sort(）就是利用二分法实现的排序，stream().sorted()利用的流处理进行排序，无论是哪一种排序归根揭底必须借助comparable接口提供的比较功能。 其次我们要理解1、-1、0分别代表什么含义？ 上文代码注释中已经有比较详细的解答，大家可以思考和领悟一下。这里做一下简单的叙述：简单来说无论我们希望倒叙排序还是正序排序只需要调整好o.getAge()与this.getAge()的大小关系即可。想象一下有一列数组，o表示数组中的前一位，this代表数组中的后一位，如果我们希望升序排序，只需要设定o.getAge()&lt;this.getAge()时返回1即可，同样若需要降序排序则只需要设定o.getAge()&gt;this.getAge()时返回1即可。说到这里大家应该明白数字的含义了，本质上就是比较结果的标记。 总结 我们现在来总结一下Comparable的作用和用法，其作为接口为类提供了内部比较功能，使继承了该接口的类不用去依赖外部的比较器就可以实现同类对象的比较。由于实现了类的比较那么我们可以轻而易举的实现类的排序。 Comparator老样子,想要讲解透彻用法还是要代码举例,我们先把必要的比较器对象创建好,具体如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//创建测试数组private List&lt;student&gt; students = Lists.newArrayList();//创建内部比较器对象--降序Comparator&lt;student&gt; studentComparator_desc = new Comparator&lt;student&gt;() { @Override public int compare(student o1, student o2) { // 入参o1:可以理解为排序队列中的后一个对象,即比较对象 // 入参o2:理解为排序队列的前一个对象,即被比较对象 if (o1.getAge() &gt; o2.getAge()) { return -1; } else if (o1.getAge() &lt; o2.getAge()) { //解读:如果后一个对象小于前一个对象,那么符合我们的目标排序规则,则返回1 //因此我们可以想象一下,前大后小的序列是降序序列,以此我们可以理解升序序列 return 1; } else { return 0; } }};//创建内部比较器对象--升序Comparator&lt;student&gt; studentComparator_asc = new Comparator&lt;student&gt;() { @Override public int compare(student o1, student o2) { // 入参o1:可以理解为排序队列中的后一个对象,即比较对象 // 入参o2:理解为排序队列的前一个对象,即被比较对象 if (o1.getAge() &gt; o2.getAge()) { //解读:如果后一个对象大于前一个对象,那么符合我们的目标排序规则,则返回1 //因此我们可以想象一下,前小后大的序列是升序序列,以此我们可以理解降序序列 return 1; } else if (o1.getAge() &lt; o2.getAge()) { return -1; } else { return 0; } }};//创建内部比较器对象--升序Comparator&lt;student&gt; studentComparator_grade_asc = new Comparator&lt;student&gt;() { @Override public int compare(student o1, student o2) { // 入参o1:可以理解为排序队列中的后一个对象,即比较对象 // 入参o2:理解为排序队列的前一个对象,即被比较对象 if (o1.getGrade() &gt; o2.getGrade()) { //解读:如果后一个对象大于前一个对象,那么符合我们的目标排序规则,则返回1 //因此我们可以想象一下,前小后大的序列是升序序列,以此我们可以理解降序序列 return 1; } else if (o1.getGrade() &lt; o2.getGrade()) { return -1; } else { return 0; } }};//创建内部比较器对象--降序Comparator&lt;Integer&gt; studentComparator_grade_desc = new Comparator&lt;Integer&gt;() { @Override public int compare(Integer o1, Integer o2) { // 入参o1:可以理解为排序队列中的后一个对象,即比较对象 // 入参o2:理解为排序队列的前一个对象,即被比较对象 if (o1 &lt; o2) { //解读:如果后一个对象大于前一个对象,那么符合我们的目标排序规则,则返回1 //因此我们可以想象一下,前小后大的序列是升序序列,以此我们可以理解降序序列 return 1; } else if (o1 &gt; o2) { return -1; } else { return 0; } }}; 接下来我们编写测试代码一窥究竟,先从简单比较方式开始,具体如下: 1234567891011121314151617181920212223242526272829303132333435@Test public void publicSortMethod() { //初始化测试数组 students.add(student.builder().age(10).build()); students.add(student.builder().age(30).build()); students.add(student.builder().age(50).build()); students.add(student.builder().age(10).build()); students.add(student.builder().age(20).build()); students.add(student.builder().age(40).build()); students.add(student.builder().age(60).build()); //排序前 printUtil.printList(students); //排序--通过集合工具类Collections(既是student类已经默认实现comprartable比较器接口,并实现升序,这里也会按照降序比较器排序) //Collections.sort(students,studentComparator); //排序--通过集合工具类Arrays //Arrays.sort(); //排序--通过stream(既是student类已经默认实现comprartable比较器接口,并实现升序,这里也会按照降序比较器排序) students = students.stream().sorted(studentComparator_desc).collect(Collectors.toList()); //排序--通过stream(当前比较器的反向顺序) //students = students.stream().sorted(studentComparator_desc.reversed()).collect(Collectors.toList()); //排序和排重--通过stream(因为比较器中已经定义两对象相等的情况即return 0,因此可以直接直用distinct()) //students = students.stream().sorted(studentComparator_desc).distinct().collect(Collectors.toList()); //排序多比较器--通过stream(这里只是简单举例升序,降序,实际业务中应该是根据不同属性进行不同排序) //students = students.stream().sorted(studentComparator_desc).sorted(studentComparator_asc).collect(Collectors.toList()); //排序后 printUtil.printList(students); } Comparator的高级用法如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Test public void otherSortMethod() { //初始化测试数组 students.add(student.builder().age(10).grade(200).build()); students.add(student.builder().age(30).build()); students.add(student.builder().age(50).build()); students.add(student.builder().age(10).build()); students.add(student.builder().age(20).grade(500).build()); students.add(student.builder().age(40).build()); students.add(student.builder().age(60).build()); //排序前 printUtil.printList(students); //1.thenComparing用法--针对相等情况下使用另一种比较器(年龄相等按照分数升序排序) //students = students.stream().sorted(studentComparator_desc.thenComparing(studentComparator_grade_asc)).collect(Collectors.toList()); //直接利用grade排序 //students.sort(studentComparator_desc.thenComparing(e-&gt;e.getGrade())); //利用grade指定比较器排序,注意指定的比较器不在是student对象 //students.sort(studentComparator_desc.thenComparing(e -&gt; e.getGrade(), studentComparator_grade_desc)); //2.thenComparingInt实现对int对象的比较,入参为函数表达式 //students.sort(studentComparator_desc.thenComparingInt(e -&gt; e.getGrade())); //3.reversed用法--反向比较器 //students.sort(studentComparator_desc.reversed()); //4.naturalOrder用法-按照自然顺序排序(本例中按照age升序排序) //students.sort(Comparator.naturalOrder()); //5.reverseOrder用法-按照反自然顺序排序(本例中按照age降序排序) //students.sort(Comparator.reverseOrder()); //6.nullsFirst与nullsLast用法-解决如果排序的字段为null的情况下这条记录怎么排序的问题。nullsFirst是说将null记录排在最前面，而nullsLast是说将null记录排序在最后面。 //students.sort(Comparator.nullsLast(studentComparator_desc)); //7.comparing用法-直接指定用于定义比较规则的比较器对象或者函数 //students.sort(Comparator.comparing(e -&gt; e.getAge())); //students.sort(Comparator.comparing(e -&gt; e.getGrade(), studentComparator_grade_desc)); students.sort(Comparator.comparingInt(e -&gt; e.getAge())); //排序后 printUtil.printList(students); } 总结 以上两段测试代码已经将Comparator讲解的比较透彻,总的来说Comparator是用来定义比较器对象的,适合原本不支持比较的类对象实现比较功能.对比较器(1,0,-1)的详细解说可参考[1] 参考: [1]https://www.cnblogs.com/maozp/p/11153403.html var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/4/7/compare/"},{"title":"java偏向锁/轻量级锁/自旋锁/重量级锁","text":"java中锁在宏观中可以分为乐观锁、悲观锁，在实现上有偏向锁、轻量级锁、自旋锁、重量级锁等，其中涉及到锁升级，本文对以上四种锁及其实现原理做浅显介绍。 乐观锁与悲观锁乐观锁：乐观锁认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败就重复，读-比较-写的操作。Java中的乐观锁基本都是通过CAS操作实现的，CAS是一种原子性的更新操作，比较当前值跟传入值是否一样，一样则更新，否则失败。 悲观所：悲观所就是悲观思想，即认为写多于读，遇到并发写的可能性很高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人向读写这个数据久会block直到拿到锁。而synchronized就是其中的代表。 java对象头java对象头是实现synchronized的锁对象的基础，synchronized使用的锁对象是存储在Java对象头里的。 对象头包含两部分： Mark Word：存储对象hashcode、锁信息、分代年龄、GC信息等 Class Metadata Address：类型指针指向类的类元数据，jvm通过类原数据来确定类的实例 其中Mark Word在默认情况下存储结构如下图 由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如32位JVM下，除了上述列出的Mark Word默认存储结构外，还有如下可能变化的结构： 偏向锁偏向锁是JDK6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。 偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。 当锁对象第一次被线程获取的时候，线程使用CAS操作把这个线程的ID记录在对象Mark Word之中，同时置偏向标志位01。 以后该线程再进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的ID。如果测试成功，表示线程已经获得了锁。 当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定或轻量级锁定状态。 轻量级锁轻量级锁提升程序同步性能的依据是：对于绝大部分的锁，在整个同步周期内都是不存在竞争的（区别于偏向锁）。这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢。 轻量级锁加锁过程 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”） 当前线程栈帧中创建Local Record空间 拷贝对象头中的Mark Word复制到锁记录（Lock Record）中 虚拟机使用CAS操作尝试将锁对象的Mark Word更新为指向Lock Record的指针，并将线程栈帧中的Lock Record里的owner指针指向Object的 Mark Word。 如果CAS成功则线程获得该对象的锁，并且对象Mark Word的锁标志位设置为“00” 如果CAS失败则检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 自旋锁与自适应自旋锁Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间，对于代码简单的同步块（如被synchronized修饰的getter()和setter()方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。 虚拟机的开发团队注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下“，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。 自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK1.6中已经变为默认开。自旋等待不能代替阻塞。自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会浪费处理器资源。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当使用传统的方式去挂起线程了。 JDK1.6中引入自适应的自旋锁，自适应意味着自旋的时间不在固定。而是有虚拟机对程序锁的监控与预测来设置自旋的次数。 自旋是在轻量级锁中使用的 重量级锁重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。 每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。 当多个线程同时访问一段同步代码时，首先会进入 Entry Set 当线程获取到对象的monitor 后进入 The Owner 区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1 若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒 若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。 由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因。 锁升级锁可以升级但不可以降级，具体过程如下： 对象实例化后遇到第一个访问线程，则偏向第一个访问线程并设定偏向锁，CAS操作修改对象头偏向锁标记为01，对象头中ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。 当有第二个线程访问该对象，检查偏向锁指向线程是否存活 如果未存活则第二个线程获取偏向锁 如果存活则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁 如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向 轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁 当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。 参考资料： [1]https://www.cnblogs.com/deltadeblog/p/9559035.html var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/8/9/java-lock/"},{"title":"java对象的深浅复制","text":"基本概念浅拷贝：假设对象内部除基本数据类型外还引用有外部对象实例，则浅拷贝复制对象本身及外部应用对象的引用（并非对象） 深拷贝：假设对象内部除基本数据类型外还引用有外部对象实例，则深拷贝复制对象本身及外部引用对象 如何实现深浅拷贝实现浅拷贝clone()方法是object对象中提供的方法，java中任何引用类型对象均具备clone()方法。在不重写clone的情况下使用clone方法就可以实现浅拷贝。 实现深拷贝 如果需要实现深拷贝则不仅初始对象需要实现cloneable接口并重写clone方法，内部所引用的对象也需要一并实现cloneable接口并重写clone方法。 通过java中的反序列化也可以实现深拷贝 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/8/java-copy/"},{"title":"java的垃圾回收器","text":"垃圾回收器的实现，跟厂商有很大关系。这里主要讨论基于JDK1.7 Update14之后的HotSpot虚拟机。新生代收集器使用的收集器：Serial、PraNew、Parallel Scaveng；老年代收集器使用的收集器：Serial Old、Parallel Old、CMS；以及G1收集器。 1、Serial收集器（复制算法) 1234适用于新生代单线程收集器：它只会使用一个CPU和一条收集线程去完成垃圾收集工作垃圾收集时暂停所有用户线程Serial收集器由于没有线程交互的开销，专心做垃圾收集可以获得最高的单线程收集效率 2、ParNew收集器(复制算法) 适用于新生代 多线程收集器：Serial收集器的多线程版本 可以和老年代的CMS收集器配合 单核cup下效率不过，由于存在线程切换开销 3、Parallel Scavenge收集器(复制算法) 适用于新生代 多线程收集器：它追求的是达到可控的吞吐量。即吞吐量=运行用户代码时间/(运行用户代码时间+GC线程时间) 参数解析： 1）Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGcPauseMillis，以及直接设置吞吐量大小的-XX:GCTimeRatio。 -XX:MaxGcPauseMillis参数允许一个大于0的毫秒数，收集器尽可能保证内存回收时间不超过设定值。但是这个时间的缩短是以牺牲吞吐量和新生代空间来换取的，过度缩小会导致垃圾收集更频繁，停顿时间减少，但吞吐量也会降低。 -XX:GCTimeRatio参数的值应该是一个大于0小于100的整数，也就是运行用户代码时间和垃圾收集时间的比例。比如设置为19，表示运行用户代码时间：GC时间=19，所以吞吐量是19/(19+1)。参数默认值是99，也就是99%的吞吐量。 2）收集器还有 “GC自适应调节策略”的开关参数-XX:+UseAdaptiveSizePolicy。参数打开后，不需要指定新生代大小(-Xmn)、Eden与Survivor比例(-XX:SurvivorRatio)、晋升老年代的对象大小(-XX:PretenureSizeThreshold)等细节参数，虚拟机会根据当前系统的允许情况、收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量。 4、Serial Old收集器(标记-整理算法) 适用于年老代 单线程收集器 使用标记-整理算法 5、Parallel Old收集器(标记-整理算法) 适用于年老代 多线程收集器 Parallel Scavenge收集器的老年代版本 标记-整理算法。 在吞吐量优先的场合，优先考虑Parallel Scavenge收集器+ Parallel Old收集器的组合 6、CMS收集器（标记-清除算法） 以获取最短回收停顿时间为目标的收集器 1）初始标记：需要“Stop the World”，用于标记GC Roots能直接关联的对象，速度很快； 2）并发标记：不需要“Stop the World”，进行GC RootsTracing的过程； 3）重新标记；需要“Stop the World”，修正并发标记期间因用户继续运作而导致标记产生变动的那一部分对象的标记记录，停顿时间略长于初始标记，但远远短于并发标记的时间； 4）并发清除：不需要“Stop the World”。 由于整个过程中耗时最长的并发标记和并发清除过程，收集器线程都可以与用户线程以前工作，所以，总体来说，CMS收集器的内存回收过程是与用户线程以前并发执行的。 CMS收集器的缺点： 1）CMS对CPU资源非常敏感： 在并发阶段，CMS虽然不会导致用户线程停顿，但是还会因为占用了部分CPU资源导致应用程序变慢，总吞吐量降低。CMS默认启动的线程数是(CPU线程数+3)/4。 2）CMS无法处理浮动垃圾，可能出现“Concurrent Mode Failure”而导致另一次Full GC： 浮动垃圾，指的是并发清理阶段产生的垃圾。因为并发清理阶段用户程序也在运行，产生的垃圾在标记过程之后，所以本次清理过程不会被清理，并且CMS还必须预留一部分空间提供给并发收集时的程序运作使用。要是CMS运行期间预留的内存无法满足程序需要，就会触发“Concurrent Mode Failure”，虚拟机将启动后备预案，临时启用Serial Old收集器，但停顿时间会明显增加。 CMS提供了参数-XXCMSInitiatingOccupancyFraction来控制触发CMS的内存使用占比，设置太低会导致CMS触发过于频繁，设置太高则很容易出现大量的“Concurrent Mode Failure”。 3）基于标记-清除算法，收集结束会产生大量空间碎片： 为解决这个问题，CMS提供了-XX:+UseCMSCompactAtFullCollection开关参数，默认打开。这个参数用于在CMS快要进行FullGC时开启内存碎片的合并整理过程，内存的整理过程无法并发，虽然减少了空间碎片，但是也增加了停顿时间。 CMS还提供了参数-XX:CMSFullGCsBeforeCompaction，这个参数用于设置执行多少次不压缩的FullGC后，执行一次带碎片整理的FullGC。默认是0，表示每次Full GC都需要进行碎片整理。 7、G1收集器 面向服务端应用的收集器 一款并行与并发收集器 能建立可预测的停顿时间模型 不需要和其他收集器配合 G1将内存分成多个大小相等的独立区域，虽然还保留着新生代和老年代的概念，但是新生代和老年代不再是物理隔离的，它们都是一部分Region(不需要连续)的集合。 G1回收器优点： 1）空间整合： G1从整体看是基于标记-整理算法实现的收集器，从局部看是基于复制算法。这两种算法都意味着G1运行期间不会产生大量内存空间碎片。 2）可预测的停顿： 降低停顿时间是G1和CMS共同关注的，但G1能建立可预测的停顿时间模型，让使用者明确指定在一个长度为M毫秒的时间片段内，GC的时间不得超过N毫秒。 3）有计划的垃圾回收： G1可以有计划的在Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆的价值大小(回收所获得的空间大小，以及回收所需要的时间)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这就是Garbage-First的由来。 参考资料： [1]https://blog.csdn.net/weixin_38569499/article/details/85645867 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/8/31/garbage-collection/"},{"title":"java范型","text":"什么是范型范型的本质是参数化数据类型，也就是说操作的数据类型被指定为一个参数，代码可以应用于多种数据类型。一般如果数据类型不确定可以使用范型来简化代码。 123class Point&lt;T&gt;{ private T x ; } 范型的优点范型的最大优点是提供了编译时类型安全检测机制，该机制允许程序员在编译时监测到非法的类型。 1234567891011121314151617181920class ObjectPoint{ private Object x ; private Object y ; public void setX(Object x){ this.x = x ; } public void setY(Object y){ this.y = y ; } public Object getX(){ return this.x ; } public Object getY(){ return this.y ; } } ObjectPoint floatPoint = new ObjectPoint(); floatPoint.setX(new Float(100.12f)); String floatX = (String)floatPoint.getX(); floatPoint.getX()返回的类型是Object，所以编译时将Object强转成String是成立的不会报错，但是运行时会报类型转换错误。 1234567891011121314151617181920class Point&lt;T&gt;{ private T x ; private T y ; public void setX(T x){ this.x = x ; } public void setY(T y){ this.y = y ; } public T getX(){ return this.x ; } public T getY(){ return this.y ; } }; //IntegerPoint使用 Point&lt;Integer&gt; p = new Point&lt;Integer&gt;() ; p.setX(new Integer(100)) ; System.out.println(p.getX()); 范型不存在强制转换，如果传入类型有问题会在编辑时报错 范型的种类 范型类定义：class Point{}，T表示派生自Object类的任何类，T只是一个代号可以用其它大些字母表示。 多范型变量：class MorePoint&lt;T,U&gt;{ } 范型接口：interface Info{ }有兴趣可以自行研究用法 范型函数： 123456public static &lt;T&gt; void StaticMethod(T a){ Log.d(&quot;harvic&quot;,&quot;StaticMethod: &quot;+a.toString()); } StaticFans.StaticMethod(&quot;adfdsa&quot;);//使用方法一 隐式传递类型StaticFans.&lt;String&gt;StaticMethod(&quot;adfdsa&quot;);//使用方法二 显式传递类型(推荐使用) 返回值中存在范型如下案例 1234public static &lt;T&gt; List&lt;T&gt; parseArray(String response,Class&lt;T&gt; object){ List&lt;T&gt; modelList = JSON.parseArray(response, object); return modelList; } class类传递 123456789public static &lt;T&gt; List&lt;T&gt; parseArray(String response,Class&lt;T&gt; object){ List&lt;T&gt; modelList = JSON.parseArray(response, object); return modelList; } //Class&lt;T&gt; object来传递类的class对象，Class&lt;T&gt;也是一泛型，它是传来用来装载类的class对象的，它的定义如下：public final class Class&lt;T&gt; implements Serializable { ………… } 范型数组 123public static &lt;T&gt; T[] fun1(T...arg){ // 接收可变参数 return arg ; // 返回泛型数组 } var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/5/28/java-generics/"},{"title":"jvm内存模型","text":"简介 程序计数器，虚拟机栈，本地方法栈是线程私有的 堆是线程共有的 方法区可以被各个线程共享 线程共享堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个*线程共享**的内存区域，该内存区域存放了对象实例及数组（但不是所有的对象实例都在堆中）***。 方法区 也称”永久代“，用于**存储虚拟机加载的类信息、常量、静态变量** 默认最小值为16MB，最大值为64MB（64位JVM由于指针膨胀，默认是85M） 它是**一片连续的堆空间**，并与堆空间连续 垃圾收集是和老年代(old generation)捆绑在一起的，无论谁满了都会一起回收 从JDK7**开始移除永久代（但并没有移除）** 运行时常量池 是方法区的一部分 用于**存放编译器生成的各种符号引用** 元数据区 JDK8开始使用元空间（Metaspace），方法区存在于元空间 元空间不再与堆连续，而是存在于本地内存 本地内存（Native memory），也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。 默认情况下元空间是可以无限使用本地内存的，但是也可以通过参数进行设置 线程私有 程序计数器：记录当前线程所执行的字节码的行号 本地方法栈： 为Native方法服务(栈的空间大小远远小于堆) 虚拟机栈：描述的是**java方法执行的内存模型** 虚拟机栈 每个方法被执行的时候都会创建一个”栈帧” 每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程 栈帧生命周期与线程相同，是线程私有的 栈帧组成 局部变量区：以一个字长为单位、从0开始计数的数组。用于存储局部变量表，通过索引来访问 操作数栈：以一个字长为单位、从0开始计数的数组。通过入栈和出栈来访问 帧数据区：存储数据用来支持常量池解析、正常方法返回以及异常派发机制 局部变量表 存放了编译器可知的各种基本数据类型、对象引用(引用指针，并非对象本身) 局部变量表所需的内存空间在编译期间完成分配 在运行期间*栈帧*不会改变局部变量表的大小空间 直接内存JVM控制内存之外的本机内存。 jdk的NIO引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/18/memory/"},{"title":"jvm堆调优","text":"内存设置 整个JVM内存大小=堆内存+ 非堆内存 堆（heap）：是Java代码可用的内存，是留给开发人员使用的； 非堆（non-heap）：是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。 JDK1.8之前:堆内存=年轻代+年老代+持久代.JDK18之后：堆内存=年轻代+年老代 堆内存分配堆的大小一般不超过现有空闲内存的80% -Xmx：yound代加上old代总和的初始最大值 -Xms：yound代加上old代总和的最小值 -XX:NewSize=[g|m|k] 设置年轻代的初始值和最小值（NewSize与MaxNewSize必须同时设置） -XX:MaxNewSize=[g|m|k] 设置年轻代的最大值（NewSize与MaxNewSize必须同时设置） -Xmn[g|m|k] 固定年轻代始终为该大小，Sun官方推荐配置为整个堆的3/8 old代需要借助yound来设置（总量-yound） 非堆内存分配一般不去设置持久代而是通过JVM自动调整 -XX:PermSize=[g|m|k] 设置permanent代的初始值和最小值 -XX:MaxPermSize=[g|m|k] 设置permanent代的最大值 其它辅助设置 -XX:NewRatio=4:设置年轻代与年老代的比值。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6 -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/18/heap/"},{"title":"org.springframework.boot.autoconfigure注解详解","text":"@SpringBootApplication详情可查看“Springboot体系结构及实现原理” 1234567891011121314151617181920212223242526272829303132333435363738@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = {@Filter(type = FilterType.CUSTOM,classes = {TypeExcludeFilter.class}), @Filter(type = FilterType.CUSTOM,classes = {AutoConfigurationExcludeFilter.class})})public @interface SpringBootApplication {@AliasFor(annotation = EnableAutoConfiguration.class)Class&lt;?&gt;[] exclude() default {};@AliasFor(annotation = EnableAutoConfiguration.class)String[] excludeName() default {};@AliasFor(annotation = ComponentScan.class,attribute = &quot;basePackages&quot;)String[] scanBasePackages() default {};@AliasFor(annotation = ComponentScan.class,attribute = &quot;basePackageClasses&quot;)Class&lt;?&gt;[] scanBasePackageClasses() default {};} exclude:可以设置根据类路径排除自动配置 excludeName:可以设置根据类名称排除自动配置 scanBasePackages：针对ComponentScan注解类型进行扫描和注入，添加别名basePackages scanBasePackageClasses：针对ComponentScan注解类型进行扫描和注入，添加别名basePackageClasses var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/30/autoconfigureboot/"},{"title":"org.springframework.boot.web.servlet注解详解","text":"@ServletComponentScan通常标注在启动类上，用于设置servlet容器组建的扫描，被设定的范围内 Servlet、Filter、Listener可以直接通过@WebServlet、@WebFilter、@WebListener注解自动注册，无需其他代码 12345678910111213@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Import({ServletComponentScanRegistrar.class})public @interface ServletComponentScan {@AliasFor(&quot;basePackages&quot;)String[] value() default {};@AliasFor(&quot;value&quot;)String[] basePackages() default {};Class&lt;?&gt;[] basePackageClasses() default {};} value与basePackages互设置别名 basePackageClasses：可以通过其来设置需扫描的包类路径 12345678@SpringBootApplication@ServletComponentScan(&quot;com.test&quot;)public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 12345678910111213package com.test@WebServlet(name=&quot;TestServlet&quot;,urlPatterns=&quot;/test&quot;)public class TestServlet extends HttpServlet { private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;test&quot;); }} 参考资料： [1]https://blog.csdn.net/m0_37739193/article/details/85097477 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/30/annotationServlet/"},{"title":"org.springframework.context.annotation注解详解","text":"@ImportResource用在springboot的启动类，用于将外部xml文件进行解析和注入bean 123456789101112@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})@Documentedpublic @interface ImportResource {@AliasFor(&quot;locations&quot;)String[] value() default {};@AliasFor(&quot;value&quot;)String[] locations() default {};Class&lt;? extends BeanDefinitionReader&gt; reader() default BeanDefinitionReader.class;} value和locations互设别名 BeanDefinitionReader：设置需解析xml文件内部bean对象的解析器，默认为BeanDefinitionReader.class @Bean用于标注在方法实例、配置类上，标识改对象为Bean对象可以被spring扫描，但是如果spring未扫描该标注对象所处路径则不会注入到spring容器。（通常结合@Component与@Configuration使用） 12345678910111213141516@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Bean {@AliasFor(&quot;name&quot;)String[] value() default {};@AliasFor(&quot;value&quot;)String[] name() default {};Autowire autowire() default Autowire.NO;String initMethod() default &quot;&quot;;String destroyMethod() default &quot;(inferred)&quot;;} value与name互设别名 autowire：设置是否自动织入（即注入），默认为否，如果设置是则无需扫描自动实现注入到spring容器 initMethod：指定初始化方法，默认为空 destroyMethod：指定销毁方法，默认为(inferred) @ComponentScan通常与@configuration一起使用用于标注在配置类、启动类上，设定扫描范围并实现注入。（ @Component, @Repository, @Service, @Controller,@Bean，@Configuration等可以实现被ComponentScan默认识别但不扫描不会自动注入因此需要扫描） 12345678910111213141516171819202122232425262728293031323334353637383940414243@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE})@Documented@Repeatable(ComponentScans.class)public @interface ComponentScan {@AliasFor(&quot;basePackages&quot;)String[] value() default {};@AliasFor(&quot;value&quot;)String[] basePackages() default {};Class&lt;?&gt;[] basePackageClasses() default {};Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class;Class&lt;? extends ScopeMetadataResolver&gt; scopeResolver() default AnnotationScopeMetadataResolver.class;ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;String resourcePattern() default &quot;**/*.class&quot;;boolean useDefaultFilters() default true;ComponentScan.Filter[] includeFilters() default {};ComponentScan.Filter[] excludeFilters() default {};boolean lazyInit() default false;@Retention(RetentionPolicy.RUNTIME)@Target({})public @interface Filter {FilterType type() default FilterType.ANNOTATION;@AliasFor(&quot;classes&quot;)Class&lt;?&gt;[] value() default {};@AliasFor(&quot;value&quot;)Class&lt;?&gt;[] classes() default {};String[] pattern() default {};}} 该标注被标注为@Repeatable即可以实现重复标注 value与basePackages互设别名用于设定扫描路径 basePackageClasses用于指定扫描类路径 nameGenerator：用于设置Bean名称生成器 scopeResolver：用于设置元数据解析器 scopeProxy：用于设置范围代理 resourcePattern：用于设置资源路径，默认为“*/.class” userDefaultFilters：设置是否使用默认扫描路径过滤器 includeFilters：用于设置包含过滤器对象，类型为ComponentScan.Filter[]数组 excludeFilters：用于设置排除过滤器对象，类型为ComponentScan.Filter[]数组 lazyInit：设置是否lazy初始化 Filter：ComponentScan内部过滤器注解，type：标识过滤器类型，value与classes互设别名，pattern设置路径表达式，案例如下： 123456@Configuration@ComponentScan(basePackages = &quot;org.example&quot;,includeFilters = @Filter(type = FilterType.REGEX, pattern = &quot;.*Stub.*Repository&quot;),excludeFilters = @Filter(Repository.class))public class AppConfig {...} filter类型以及适用范围如下： @Configuration通常与@Bean结合使用，用于标注配置类，其具备@Component的特性，必须被扫描才可以实现注入 12345678910@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Configuration {@AliasFor(annotation = Component.class)String value() default &quot;&quot;;} 简单来看@Configuration为特殊的@Component value针对Component设置别名 @PropertySource通常与@Configuration等结合使用，用于引入外部配置文件实现解析和注入。加载指定的属性文件（*.properties）到 Spring 的 Environment 中. 123456789101112131415@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(PropertySources.class)public @interface PropertySource {String name() default &quot;&quot;;String[] value();boolean ignoreResourceNotFound() default false;String encoding() default &quot;&quot;;Class&lt;? extends PropertySourceFactory&gt; factory() default PropertySourceFactory.class;} name：属性资源名称，默认为空 value：String数组，表示外部资源路径 ignoreResourceNotFound：设置为发现指定路径资源时是否忽略，默认忽略 edcoding：指定编码方式，默认为空 PropertySourceFactory：指定属性资源工厂类 1234567891011121314@Configuration@PropertySource(value = {&quot;classpath:/com/${my.placeholder:default/path}/app.properties&quot;})public class AppConfig {@AutowiredEnvironment env;@Beanpublic TestBean testBean() {TestBean testBean = new TestBean();testBean.setName(env.getProperty(&quot;testbean.name&quot;));return testBean;}} 或者与@Value配合使用 12345678910111213141516171819package com.huang.pims.demo.props;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;@Component@PropertySource(value = {&quot;test/props/test.properties&quot;})public class ReadByPropertySourceAndValue { @Value(&quot;${test.name}&quot;) private String name; @Value(&quot;${test.sex}&quot;) private int sex; @Value(&quot;${test.type}&quot;) private String type;} var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/30/annotationSpring/"},{"title":"org.springframework.core.annotation注解详解","text":"@AliasFor注解在Spring的众多注解中，经常会发现很多注解的不同属性起着相同的作用，比如@RequestMapping的value属性和path属性，这就需要做一些基本的限制，比如value和path的值不能冲突，比如任意设置value或者设置path属性的值，都能够通过另一个属性来获取值等等。为了统一处理这些情况，Spring创建了@AliasFor标签。即别名注解 方式一：在同一注解内使用123456789101112@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping {@AliasFor(&quot;path&quot;)String[] value() default {};@AliasFor(&quot;value&quot;)String[] path() default {};//...} 注意：互为别名的属性值类型、默认值都需要相同。必须成对配置，必须设置默认值。 方式二：显式覆盖元注解属性1234567@Retention(RetentionPolicy.RUNTIME)@ContextConfigurationpublic @interface STC {@AliasFor(value = &quot;classes&quot;, annotation = ContextConfiguration.class)//针对ContextConfiguration.class类型注解内的classes设置别名Class&lt;?&gt;[] cs() default {};} 方式三：隐士声明别名123456789101112@ContextConfigurationpublic @interface MyTestConfig {@AliasFor(annotation = ContextConfiguration.class, attribute = &quot;locations&quot;)String[] value() default {};@AliasFor(annotation = ContextConfiguration.class, attribute = &quot;locations&quot;)String[] groovyScripts() default {};@AliasFor(annotation = ContextConfiguration.class, attribute = &quot;locations&quot;)String[] xmlFiles() default {};} 相当于value、groovyScripts和xmlFiles也互为别名 方式四：别名传递123456789@MyTestConfigpublic @interface GroovyOrXmlTestConfig {@AliasFor(annotation = MyTestConfig.class, attribute = &quot;groovyScripts&quot;)String[] groovy() default {};@AliasFor(annotation = ContextConfiguration.class, attribute = &quot;locations&quot;)String[] xml() default {};} GroovyOrXmlTestConfig把 @MyTestConfig（参考上一个案例）作为元注解； 定义了groovy属性，并作为MyTestConfig中的groovyScripts属性的别名； 定义了xml属性，并作为ContextConfiguration中的locations属性的别名； 因为MyTestConfig中的groovyScripts属性本身就是ContextConfiguration中的locations属性的别名；所以xml属性和groovy属性也互为别名； 参考资料： [1]https://www.jianshu.com/p/869ed7037833 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2020/6/30/annotationcore/"},{"title":"volatile底层实现","text":"作用 Java关键字 内存可见性：多线程共享变量，对于每个线程来说都是内存可见的 禁止指令重排序：为了提高程序执行的性能，编译器和执行器(处理器)通常会对指令做一些优化(重排序) 什么是重排序本质上是为了提高程序的执行效率 重排序可以分为： 1、编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序； 2、处理器重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序； java中的重排序happen-before原则保证了程序的“有序性”，它规定如果两个操作的执行顺序无法从happens-before原则中推到出来，那么他们就不能保证有序性，可以随意进行重排序。（在不影响单线程运行结果的前提下java会进行重排序） 多线程下，重排序会造成指令执行顺序的不可控，影响到多线程执行的正确性。 Java提供给我们禁止重排序能力的操作——就是volatile。 禁止重排序的原理 volatile变量在字节码级别没有任何区别，在汇编级别使用了lock指令前缀。 lock后就是一个原子操作。原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。 当使用 LOCK 指令前缀时，它会使 CPU 宣告一个 LOCK# 信号，这样就能确保在多处理器系统或多线程竞争的环境下互斥地使用这个内存地址。当指令执行完毕，这个锁定动作也就会消失。 volatile底层使用多核处理器实现的lock指令，更底层，消耗代价更小 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/16/multithread/"},{"title":"原子操作类型","text":"简介被定义为原子操作类型的对象在多线程中是线程安全的 底层实现是通过CAS原理 类型种类原子操作基本类型 AtomicBoolean：原子更新布尔类型。 AtomicInteger：原子更新整型。 AtomicLong：原子更新长整型。 原子操作数组 AtomicIntegerArray：原子更新整型数组里的元素。 AtomicLongArray：原子更新长整型数组里的元素。 AtomicReferenceArray：原子更新引用类型数组里的元素。 原子操作引用类型 AtomicReference：原子更新引用类型。 AtomicReferenceFieldUpdater：原子更新引用类型里的字段。 AtomicMarkableReference：原子更新带有标记位的引用类型。 原子操作更新字段 AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。 AtomicLongFieldUpdater：原子更新长整型字段的更新器。 AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/17/atomic/"},{"title":"反射机制","text":"什么是反射首先大家应该先了解两个概念，编译期和运行期，编译期就是编译器帮你把源代码翻译成机器能识别的代码，比如编译器把java代码编译成jvm识别的字节码文件，而运行期指的是将可执行文件交给操作系统去执行。 JAVA反射机制是在运行状态中 反射机制允许程序在运行时取得任何一个已知名称的class的内部信息 能够知道这个类的所有属性和方法(即使是私有的) 可以调用它的任意方法和属性，甚至改变属性 这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制 java如何实现反射众所周知Java有个Object 类，是所有Java 类的继承根源，其内声明了数个应该在所有Java 类中被改写的方法：hashCode()、equals()、clone()、toString()、getClass()等。其中getClass()返回一个Class 对象。 这个Class 类十分特殊，当一个类被加载JVM 便自动产生一个Class 对象。 的到class有三种方式： 123456789101112//1、通过对象调用 getClass() 方法来获取,通常应用在：比如你传过来一个 Object// 类型的对象，而我不知道你具体是什么类，用这种方法 Person p1 = new Person(); Class c1 = p1.getClass();//2、直接通过 类名.class 的方式得到,该方法最为安全可靠，程序性能更高// 这说明任何一个类都有一个隐含的静态成员变量 class Class c2 = Person.class;//3、通过 Class 对象的 forName() 静态方法来获取，用的最多，// 但可能抛出 ClassNotFoundException 异常 Class c3 = Class.forName(&quot;com.ys.reflex.Person&quot;); Class类提供了大量的实例方法来获取该Class对象所对应的详细信息,我们只是做简单的介绍,详细请参考JDK文档，这边提供一个在线的中文文档给大家如下： 这边列了下Class类其中的部分方法, 1234567891011获取公共构造器 getConstructors()获取所有构造器 getDeclaredConstructors获取包含的方法 getMethod()获取包含的属性 getField(String name)获取内部类 getDeclaredClasses()获取外部类 getDeclaringClass()获取所实现的接口 getInterfaces()获取修饰符 getModifiers()获取所在包 getPackage()获取类名包含包路径 getName()类名不包含包路径 getSimpleName() 反射的用途注解的使用：java中注解功能的实现就是通过反射机制 编写基础框架：反射机制是很多java框架的基础，如spring的ioc容器的实现 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/10/reflect/"},{"title":"并发容器简介","text":"ConcurrentHashMap详情请看“ConcurrentHashMap原理” ConcurrentLinkedQueue 使用链表作为数据结构 采用乐观锁CAS实现同步 非阻塞线程安全队列，无界，故不太适合做生产者消费者模式，而LinkedBlockingQueue是阻塞线程安全队列，可以做到有界，通常用于生产者消费者模式 CopyOnWriteArrayListCopyOnWriteArrayList读取操作不用加锁，且是安全的；写操作时，先copy一份原有数据数组，再对复制数据进行写入操作，最后将复制数据替换原有数据，从而保证写操作不影响读操作。 ConcurrentSkipListMap可以查看“ConcurrentSkipListMap原理” var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/16/j-concurrent/"},{"title":"序列化与反序列化","text":"基本概念 Java序列化是指把Java对象转换为字节序列的过程；而Java反序列化是指把字节序列恢复为Java对象的过程。 序列化的目的：实现对象远程传输、实现对象持久化保存 如何序列化 只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） Serializable 是一个空接口，用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。 序列化类的属性没有实现 Serializable 那么在序列化就会报错 在反序列化过程中，它的父类如果没有实现序列化接口，那么将需要提供父类的无参构造函数来重新创建对象，否则会报错 一个实现 Serializable 接口的子类也是可以被序列化的。 静态成员变量是不能被序列化 transient 标识的对象成员变量不参与序列化 序列化代码示例： 12345BlackCat black = new BlackCat();ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILE_PATH));oos.writeObject(black);oos.flush();oos.close(); 序列化IDserialVersionUID主要影响反序列化，在进行反序列化时，JVM会把传进来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。 serialVersionUID 发生改变有三种情况： 手动去修改导致当前的 serialVersionUID 与序列化前的不一样。 没有指定时 JVM 内部会根据类结构去计算得到这个 serialVersionUID 值，在类结构发生改变时(属性增加，删除或者类型修改了)这种也是会导致 serialVersionUID 发生变化。 假如类结构没有发生改变，并且没有定义 serialVersionUID ，但是反序列和序列化操作的虚拟机不一样也可能导致计算出来的 serialVersionUID 不一样。 注意事项： serialVersionUID可以手动指定也可以借助工具生成 JVM 规范强烈建议我们手动声明一个版本号，最好是 private 和 final 的保证不变。 序列化步骤是什么 将对象实例相关的类元数据输出 递归地输出类的超类描述直到不再有超类 类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值 从上至下递归输出实例的数据 如何反序列化代码示例： 123ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_PATH));BlackCat black = (BlackCat) ois.readObject();ois.close(); 序列化单例问题：程序中有一个单例的对象。如果对其进行序列化，再反序列化，则得到了另一个对象。破坏了其单例性。 解决方法是在类中定义readResolve方法： 12345678public final class Singleton implements Serializable {private Singleton() {}private static final Singleton INSTANCE = new Singleton();public static Singleton getInstance() { return INSTANCE; }private Object readResolve() throws ObjectStreamException { return INSTANCE;}} 这样，当反序列化时，就会调用这个readResolve方法返回我们制定好的对象。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/8/serializable/"},{"title":"类加载器","text":"什么是类加载器就是负责把磁盘上的.class文件 ，加载到JVM内存中，并生成java.lang.Class类的一个实例。 java程序写好以后是以.java（文本文件）的文件存在磁盘上，我们通过(bin/javac.exe)编译命令把.java文件编译成.class文件（字节码文件），并存在磁盘上。但是程序要运行，首先一定要把.class文件加载到JVM内存中才能使用的。 JVM并不是一开始就会将所有的类加载到内存，而是用到某个类，才会去加载，只加载一次。 java中类加载的过程类加载过程分为三个步骤：装载（Load），链接（Link）和初始化(Initialize) 加载：将.class文件的二进制字节流读入内存(JDK1.7及之前为JVM内存，JDK1.8及之后为本地内存)，并在堆内存中为之创建Class对象，作为.class进入内存后的数据的访问入口 连接 验证：确保字节流中包含信息符合JVM要求，不会危害JVM自身安全。主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 准备：为类的类变量开辟空间并赋默认值 解析：虚拟机常量池内的符号引用替换为直接引用的过程。（比如String s =”aaa”,转化为 s的地址指向“aaa”的地址） 初始化：执行类构造器方法的过程。类构造器方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。即静态属性赋值和静态代码块初始化。 注意事项： 遇到父类未初始化时会先加载父类再加载子类，以此类推，object类一定是先被加载。 虚拟机会保证一个类的构造器方法在多线程环境中被正确加锁和同步 当访问一个java类的静态域时，只有真正声明这个静态变量的类才会被初始化。 JVM中两个class对象是否相等必须满足两个条件：第一是完整类名必须一致，包括包名，第二类的加载器必须相同。 类加载器层次结构引导类加载器（bootstrap class loader）： 它用来加载 Java 的核心库(jre/lib/rt.jar)，是用原生C++代码来实现的，在java中获取不到，其是扩展类加载器的父加载器。 扩展类加载器（extensions class loader）： 它用来加载 Java 的扩展库(jre/ext/*.jar)。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类，其是系统类加载器的父加载器。 系统类加载器（app class loader）： 它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它，其是自定义类加载器的父加载器。 自定义类加载器（custom class loader）： 除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。 双亲委派机制 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托交给父类加载器，父类加载器又将加载任务向上委托，直到最父类加载器，如果最父类加载器可以完成类加载任务，就成功返回，如果不行就向下传递委托任务，由其子类加载器进行加载。 好处是保证java核心库的安全性（例如：如果用户自己写了一个java.lang.String类就会因为双亲委派机制不能被加载，不会破坏原生的String类的加载） 自定义类加载器应用场景 资源隔离：自定义路径**中的class类文件的加载以及网络传输过来的class加载，我们需要自己的ClassLoader（不同的ClassLoader实例对象都拥有不同的独立的类名称空间，所以加载的class对象也会存在不同的类名空间中） 代码保护：有时我们不一定是从类文件中读取类，可能是从网络的输入流中读取类，这就需要做一些加密和解密操作，这就需要自己实现加载类的逻辑，当然其他的特殊处理也同样适用。 可以通过findClass读取URL中的字节码，然后加密，最后把字节数组交给defineClass()加载 热部署：在运行时更新java类文件 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/11/classloader/"},{"title":"线程池","text":"线程池的作用如果某业务场景需要创建大量的线程且线程实际的工作时间短暂，那么势必会耗费大量的资源在线程的创建、切换、销毁等上面。线程池的作用就是减少资源浪费，统筹管理多线程。java中的线程池为ThreadPoolExecutor。 线程池运行状态线程池字段 1234567891011//ctl是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3;//表示位数，此时为29private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;//线程池内有效线程的数量 (workerCount)上线，大约是5亿// runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; RUNNING：运行。能接受新的任务也能处理阻塞队列中的任务 SHUTDOWN：关闭。不接受新任务但能处理阻塞队列中的任务 STOP：停止。不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。 TIDYING：整理。线程池进入该状态后会调用terminated() 方法进入终止态。 TERMINATED：终止。 状态转换如下： RUNNING-(调用shutdown())-&gt;SHUTDOWN-(阻塞队列为空且工作线程数量为0)-&gt;TIDYING-(调用terminated方法)-&gt;TERMINATED RUNNING-(调用shutdownNow())-&gt;STOP-(工作线程数量为0)-&gt;TIDYING-(调用terminated方法)-&gt;TERMINATED ThreadPoolExecutor构造方法123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;} corePoolSize：核心线程数量，当有新任务在execute()方法提交时，会执行以下判断： 如果运行的线程少于 corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的； 如果线程池中的线程数量大于等于 corePoolSize 且小于 maximumPoolSize，则只有当workQueue满时才创建新的线程去处理任务； 如果设置的corePoolSize 和 maximumPoolSize相同，则创建的线程池的大小是固定的，这时如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲的线程去从workQueue中取任务并处理； 如果运行的线程数量大于等于maximumPoolSize，这时如果workQueue已经满了，则通过handler所指定的策略来处理任务； 所以，任务提交时，判断的顺序为 corePoolSize –&gt; workQueue –&gt; maximumPoolSize。 maximumPoolSize：最大线程数，这个参数会根据你使用的workQueue任务队列的类型，决定线程池会开辟的最大线程数量。需要注意的是只有当workQueue队列填满时才会创建多于corePoolSize的线程 workQueue：阻塞队列，存放着等待执行的Runnable任务对象。它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列、延迟队列几种。 123456789SynchronousQueue：同步队列，它没有容量，m每执行一个插入操作就会阻塞，需要再执行一个删除操作才会被唤醒，反之每一个删除操作也都要等待对应的插入操作。 使用SynchronousQueue队列，提交的任务不会被保存，总是会马上提交执行。如果用于执行任务的线程数量小于maximumPoolSize，则尝试创建新的进程，如果达到maximumPoolSize设置的最大值，则根据你设置的handler执行拒绝策略。因此这种方式你提交的任务不会被缓存起来，而是会被马上执行，在这种情况下，你需要对你程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量，否则很容易就会执行拒绝策略；ArrayBlockingQueue：数组阻塞队列，底层数据结构是数组，需要指定队列的大小。若有新的任务需要执行时，线程池会创建新的线程，直到创建的线程数量达到corePoolSize时，则会将新的任务加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，则继续创建线程，直到线程数量达到maximumPoolSize设置的最大线程数量，若大于maximumPoolSize，则执行拒绝策略。LinkedBlockingQueue：链式阻塞队列，底层数据结构是链表，默认大小是Integer.MAX_VALUE，也可以指定大小。线程池创建的最大线程数量就是corePoolSize设置的数量，也就是说在这种情况下maximumPoolSize这个参数是无效的，哪怕你的任务队列中缓存了很多未执行的任务，当线程池的线程数达到corePoolSize后，就不会再增加了；若后续有新的任务加入，则直接进入队列等待，当使用这种任务队列模式时要特别注意内存泄漏问题。PriorityBlockingQueue：基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是非公平锁。它其实是一个特殊的无界队列，它其中无论添加了多少个任务，线程池创建的线程数也不会超过corePoolSize的数量，只不过其他队列一般是按照先进先出的规则处理任务，而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。DelayQueue：延迟队列，是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。注入其中的元素必须实现 java.util.concurrent.Delayed接口。 keepAliveTime：非核心线程最大存活时长。非核心线程如果处于闲置状态超过该值，就会被销毁.注意当corePoolSize=maxPoolSize时，keepAliveTime参数也就不起作用了(因为不存在非核心线程) unit：keepAliveTime的单位。 threadFactory：它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设置了线程的名称。 handler：它是RejectedExecutionHandler类型的变量，表示线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。线程池提供了4种策略： AbortPolicy：直接抛出异常，这是默认策略； CallerRunsPolicy：用调用者所在的线程来执行任务； DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； DiscardPolicy：直接丢弃任务； ThreadPoolExecutor扩展ThreadPoolExecutor扩展主要是围绕beforeExecute()、afterExecute()和terminated()三个接口实现的， 1、beforeExecute：线程池中任务运行前执行 2、afterExecute：线程池中任务运行完毕后执行 3、terminated：线程池退出后执行 worker类线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，看一下Worker的定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private final class Worker extends AbstractQueuedSynchronizer implements Runnable { /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ final Thread thread; /** Initial task to run. Possibly null. */ Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) { setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); } /** Delegates main run loop to outer runWorker */ public void run() { runWorker(this); } // Lock methods // // The value 0 represents the unlocked state. // The value 1 represents the locked state. protected boolean isHeldExclusively() { return getState() != 0; } protected boolean tryAcquire(int unused) { if (compareAndSetState(0, 1)) { setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } protected boolean tryRelease(int unused) { setExclusiveOwnerThread(null); setState(0); return true; } public void lock() { acquire(1); } public boolean tryLock() { return tryAcquire(1); } public void unlock() { release(1); } public boolean isLocked() { return isHeldExclusively(); } void interruptIfStarted() { Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) { try { t.interrupt(); } catch (SecurityException ignore) { } } } } firstTask用它来保存传入的任务 thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程 四种常见线程池 newCachedThreadPool可缓存线程池 这是一个线程只要空闲60秒就会被回收的线程池，适用于短时间高并发的处理业务，而在峰值过后并不会占用系统资源。 12345public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());} newFixedThreadPool定长线程池 核心线程数量和总线程数量相等，都是传入的参数nThreads，因为LinkedBlockingQueue阻塞队列的大小默认是Integer.MAX_VALUE，如果使用不当，很可能导致内存溢出。 12345public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());} newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行，这是一个支持延时任务执行的线程池。 123456789public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize);}public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, //注意这里使用延迟队列 new DelayedWorkQueue());} newSingleThreadExecutor 有且仅有一个核心线程的线程池( corePoolSize == maximumPoolSize=1)，使用了LinkedBlockingQueue(容量很大)，所以，不会创建非核心线程。所有任务按照先来先执行的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。 123456public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));} var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/5/28/thread-pool/"},{"title":"语法糖","text":"什么是语法糖是让程序更加简洁，有更高的可读性的一种代码写法。 解语法糖Java虚拟机并不支持语法糖，在编译阶段就会被还原成简单的基础语法结构，这个过程就是解语法糖 有哪些语法糖 switch支持string和枚举类型 泛型 自动装箱与拆箱：如自动将int转为integer类型 方法变长参数 枚举 内部类 条件编译：希望只对其中一部分内容进行编译 断言 数字字面量：不管是整数还是浮点数，都允许在数字之间插入任意多个下划线。这些下划线不会对字面量的数值产生影响，目的就是方便阅读 for-each lambda表达式 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/10/java-sugar/"},{"title":"阻塞队列","text":"为什么会有阻塞队列非阻塞队列不会对当前线程产生阻塞，那么在面对类似消费者-生产者的模型时，就必须额外地实现同步策略以及线程间唤醒策略。 通过可重入锁实现同步，内部实现了线程等待和唤醒功能。 几种主要的阻塞队列 ArrayBlockingQueue：基于数组实现，先进先出，有界队列，可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列。 LinkedBlockingQueue：基于链表实现，先进先出，有界队列，默认大小为Integer.MAX_VALUE PriorityBlockingQueue：按照优先级对元素进行排序，按照优先级顺序出队，无界队列 DelayQueue：延时阻塞队列，无界队列 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/16/block-queue/"},{"title":"集合框架","text":"集合框架Java集合主要可以划分为4个部分：List列表（4个实现类）、Set集合（2个实现类）、Map映射（4个实现类）、工具类(Iterator迭代器、Enumeration枚举类、Arrays和Collections)。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/12/collection/"},{"title":"apollo简介","text":"什么是配置中心配置中心将配置从应用中剥离出来，统一管理，优雅的解决了配置的动态变更、持久化、运维成本等问题。应用自身既不需要去添加管理配置接口，也不需要自己去实现配置的持久化，更不需要引入“定时任务”以便降低运维成本。总得来说，配置中心就是一种统一管理各种应用配置的基础服务组件。 Apollo简介Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。 统一管理不同环境、不同集群的配置 配置修改实时生效（热发布） 版本发布管理 灰度发布 权限管理、发布审核、操作审计 客户端配置信息监控 提供 Java和.Net原生客户端 提供开放平台 API Config Service提供配置的读取、推送等功能，服务对象是Apollo客户端 Admin Service提供配置的修改、发布等功能，服务对象是Apollo Portal（管理界面） Config Service和Admin Service都是多实例、无状态部署，所以需要将自己注册到Eureka中并保持心跳 在Eureka之上架了一层Meta Server用于封装Eureka的服务发现接口 Client通过域名访问Meta Server获取Config Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Client侧会做load balance、错误重试 Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port），而后直接通过IP+Port访问服务，同时在Portal侧会做load balance、错误重试 为了简化部署，我们实际上会把Config Service、Eureka和Meta Server三个逻辑角色部署在同一个JVM进程中 Admin Service 提供配置管理接口 提供配置修改、发布等接口 接口服务对象为Portal Config Service 提供配置获取接口 提供配置更新推送接口（基于Http long polling） 服务端使用Spring DeferredResult实现异步化，从而大大增加长连接数量 目前使用的tomcat embed默认配置是最多10000个连接（一个应用实例只会发起一个长连接）。 接口服务对象为Apollo客户端 Meta Server Portal通过域名访问Meta Server获取Admin Service服务列表（IP+Port） Client通过域名访问Meta Server获取Config Service服务列表（IP+Port） Meta Server从Eureka获取Config Service和Admin Service的服务信息，相当于是一个Eureka Client 增设一个Meta Server的角色主要是为了封装服务发现的细节，对Portal和Client而言，永远通过一个Http接口获取Admin Service和Config Service的服务信息，而不需要关心背后实际的服务注册和发现组件 Meta Server只是一个逻辑角色，在部署时和Config Service是在一个JVM进程中的，所以IP、端口和Config Service一致 Eureka 基于Eureka和Spring Cloud Netflix提供服务注册和发现 Config Service和Admin Service会向Eureka注册服务，并保持心跳 为了简单起见，目前Eureka在部署时和Config Service是在一个JVM进程中的（通过Spring Cloud Netflix） 为什么我们采用Eureka作为服务注册中心，而不是使用传统的zk、etcd呢？我大致总结了一下，有以下几方面的原因： 它提供了完整的Service Registry和Service Discovery实现 首先是提供了完整的实现，并且也经受住了Netflix自己的生产环境考验，相对使用起来会比较省心。 和Spring Cloud无缝集成 我们的项目本身就使用了Spring Cloud和Spring Boot，同时Spring Cloud还有一套非常完善的开源代码来整合Eureka，所以使用起来非常方便。 另外，Eureka还支持在我们应用自身的容器中启动，也就是说我们的应用启动完之后，既充当了Eureka的角色，同时也是服务的提供者。这样就极大的提高了服务的可用性。 为了提高配置中心的可用性和降低部署复杂度，我们需要尽可能地减少外部依赖。 Open Source 最后一点是开源，由于代码是开源的，所以非常便于我们了解它的实现原理和排查问题。 Portal 提供Web界面供用户管理配置 通过Meta Server获取Admin Service服务列表（IP+Port），通过IP+Port访问服务 在Portal侧做load balance、错误重试 Client Apollo提供的客户端程序，为应用提供配置获取、实时更新等功能 通过Meta Server获取Config Service服务列表（IP+Port），通过IP+Port访问服务 在Client侧做load balance、错误重试 定时拉取配置 这是一个fallback机制，为了防止推送机制失效导致配置不更新 客户端定时拉取会上报本地版本，所以一般情况下，对于定时拉取的操作，服务端都会返回304 - Not Modified 定时频率默认为每5分钟拉取一次，客户端也可以通过在运行时指定System Property: apollo.refreshInterval来覆盖，单位为分钟。 长轮训拉取配置Config Service配置服务端 用户在Portal操作配置发布 Portal调用Admin Service的接口操作发布 Admin Service在配置发布后会往ReleaseMessage表插入一条消息记录，消息内容就是配置发布的AppId+Cluster+Namespace。 Config Service有一个线程会每秒扫描一次ReleaseMessage表，看看是否有新的消息记录， Config Service如果发现有新的消息记录，那么就会通知到所有的消息监听器（ReleaseMessageListener），如NotificationControllerV2 NotificationControllerV2得到配置发布的AppId+Cluster+Namespace后，会通知对应的客户端 client客户端 客户端会发起一个Http请求到Config Service的notifications/v2接口 NotificationControllerV2不会立即返回结果，而是通过Spring DeferredResult把请求挂起。DeferredResult字面意思就是推迟结果，是在servlet3.0以后引入了异步请求之后，spring封装了一下提供了相应的支持，也是一个很老的特性了。 DeferredResult技术中会把当前的客户端访问的线程hold住，如果在60秒内没有该客户端关心的配置发布，那么会返回Http状态码304给客户端。客户端继续轮训重复以上步骤。 如果有该客户端关心的配置发布，NotificationControllerV2会调用DeferredResult的setResult方法，传入有配置变化的namespace信息，同时该请求会立即返回。如果配置有变更，就会返回变更信息，然后向定时任务线程池提交一个任务，任务内容是执行 sync 方法。 客户端从Apollo配置中心服务端获取到应用的最新配置后，会保存在内存中 客户端会把从服务端获取到的配置在本地文件系统缓存一份 在遇到服务不可用，或网络不通的时候，依然能从本地恢复配置 总结一下： 为什么不使用消息系统？太复杂，杀鸡用牛刀。 为什么不用 TCP 长连接？对网络环境要求高，容易推送失败。且有双写问题。 为什么使用 HTTP 长轮询？性能足够，结合 Servlet3 的异步特性。直接使用 Servlet 的 HTTP 协议，比单独用 TCP 连接方便。HTTP 请求/响应模式，保证了不会出现双写的情况。默认情况下apollo的长轮询是基于http的异步响应的，一个tomcat的默认最大连接数是10000，所以一个configservice进程支持最大10000个连接是没有问题的。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2021/10/27/apollo-base/"},{"title":"管理心得","text":"前言整理带领团队、处理项目等过程中的一些管理心得。 心得小点项目管理的精髓是什么？协调各方资源，在有限时间内，高效率低成本的实现既定目标。其实重点是如何更好的协调各方资源？如何做到高效且低成本？ 如何更好的协调各方资源？简单来说就是画饼，无论是精神上的还是物质上的。通俗来讲就是给到各方想要的东西，让大家目标一致的做一件事，有认同感和成就感。其实资源说到底就是人，协调资源本质上就是搞定各种人。 如何做到高效且低成本？其实这个的难度仅次于协调各方资源，也是更考验管理技术的地方。比如简单来讲涉及步骤及做法如下： 方案设计：充分的了解上才能进行设计 方案评审与落地：让主要相关方参与，短平快的推进 进度跟踪：甘特图，每日站会，敏捷模式等 风险识别：做好阶段性总结与前瞻性评估 突发情况处理：突发情况预案，相关方参与 项目交付：相关方参与，资料文档整理交付 运维与支持：适当的资源投入 管理者应该具备的品质有哪些？ 目标识别 目标分解 前瞻性思维 良好的沟通能力 良好的语言表达能力 明确你重要的服务对象是谁 标准制定 举重若轻的平常心 对待下属：能画饼，多关心，尽可能的争取利益 对待同级：多沟通，给他们想要的 对待上级：多相处，做好服务者的角色 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/5/15/manage_exp/"},{"title":"Rest和Restful","text":"什么是RESTREST是 Representational State Transfer的缩写，即表现层状态转移，不是标准只是一种设计风格。 总结：URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。 什么是RESTful诞生：前后端分离趋势下，RESTful风格的api为各种前端提供统一服务。 自身特点： 路径设计：URL中只使用名词指定资源，不用动词，且推荐使用复数。例如“https://api.example.com/v1/zoos” HTTP动词设计：通过HTTP动词来实现资源的状态扭转，例如规定api是GET\\POST\\PUT\\DELEE等 状态码：RESTful的api需要使用规范的返回状态码，常用的有404，200，500，400等等。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/8/restful/"},{"title":"hash函数与冲突解决","text":"什么是Hash？一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。 什么是散列表？它是基于快速存取的角度设计的，也是一种典型的“空间换时间”的做法。顾名思义，该数据结构可以理解为一个线性表，但是其中的元素不是紧密排列的，而是可能存在空隙。散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 碰撞的产生？我们知道通过hash函数来生成的固定长度散列值，通过散列值找到散列表中对用的数据以实现快速访问。但散列值产生的质量高低由散列函数决定，理论上存在完美散列函数（即针对不同输入产生不同输出）但实际上做不到，因此可能会出现不同输入产生相同散列值的情况，此时碰撞发生。 碰撞的解决方法？1、开放地址法： 当发生地址冲突的时候，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止 2、链表法： 将所有关键字为同义词的记录存储在同一线性链表中 3、公共溢出区法： 一旦发生冲突，都填入溢出表 4、再hash法：当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/7/hash/"},{"title":"maven基础知识","text":"本文针对《maven实战》阅读之后的知识点整理，主要是重点的罗列和简单讲解，意在描绘一个比较全面的maven，详细的技术细节不进行设计，读者可以自行查阅资料。 maven用途 项目构建工具 项目依赖管理工具 项目信息管理工具 坐标作用：唯一定位一个maven项目 组成： 1234&lt;groupId&gt;com.company.test&lt;/groupId&gt; 公司级的软件项目组，采用逗号描述路径&lt;artifactId&gt;service-api&lt;/artifactId&gt; maven子项目名称&lt;version&gt;1.0.1-SNAPSHOT&lt;/version&gt; maven子项目版本&lt;packaging&gt;jar&lt;/packaging&gt; maven子项目打包方式，可以没有，默认为jar 依赖 依赖范围：元素用于定义依赖范围。 test：测试依赖范围。仅在测试范围有效 compile：编译依赖范围。在测试、编译、运行是依赖都有效 runtime：运行时依赖范围。在测试、运行有效。 provided：已提供依赖范围。在测试、编译有效。 system：系统依赖范围。与provided相同，但是必须显式的制定依赖包的路径，不建议使用。 传递性依赖与调节：依赖是可传递的，A-&gt;B-&gt;C依次依赖，则A也依赖C。依赖冲突调解原则： 最短路径原则：例如BC中都有依赖D，但是版本不同，那么A最终采用B中的依赖D版本 第一声明者优先原则：如果路径相同则优先加载在pom中顺序靠前的依赖 可选依赖：用标注的依赖为可选依赖，这样的依赖不会被传递 仓库自行百度，属于软件安装与配置教程。 类型：本地仓库、远程仓库、中央仓库、私有仓库 镜像 生命周期与插件 什么是生命周期？项目构建的过程就是生命周期 生命周期种类：clean\\validate（验证）\\compile\\test\\package\\verify\\install\\site（生成站点）\\deploy 插件目标：帮助快速便捷的构建项目和管理项目 插件绑定：maven命令的底层实现就是依赖默认的maven插件，即命令即插件。同理插件可用具体的命令进行绑定，执行命令就相当于执行插件。 插件配置：不同的插件支持的功能和命令不同，可以对插件与命令进行绑定，将复杂的插件命令进行简单化 从命令行调用插件：插件与命令绑定后执行maven命令即可执行插件 聚合与继承 聚合：建立聚合项目，在项目的pom中通过modules元素聚合子maven项目，这样只要在聚合项目执行构建命令就可以操作子项目，无需组个构建。 继承：建立父项目，在父项目pom中设定好依赖、属性、插件等信息，在子项目中通过来依赖父项目的配置。 可继承的pom元素： groupid（重点） version（重点） description organization inceptionyear url developers contributors distributionmanagement issuemanagement cimanagement scm mailinglists properties（重点） dependencies（重点） dependencymanagement（重点）父项目使用此配置依赖后，依赖不会被子项目继承，但是子项目可以自行添加父配置中的依赖，可以省略组id和项目id，减少配置。 repositories（重点） build（重点） Reporting 聚合与继承的关系：聚合与继承虽然作用不同，但是方便起见一般配置到一个pom中 其他内容 nexus私服 maven测试 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/11/3/maven-base/"},{"title":"函数式编程","text":"有哪些编程范式 命令式编程：告诉计算机要做什么。代表语言有：C, C++, Java, Javascript, BASIC,Ruby 声明式编程：以数据结构的形式来表达程序执行的逻辑。代表语言有：SQL，HTML，CSS 函数式编程：将函数作为编程中的“一等公民”，关注于流程而非具体实现。代表语言有：JAVA（8以上），js（ES6），C#，Scala，python等 什么是函数式编程编程是以函数作为单元来处理各个业务逻辑，函数既可以当做参数传递也可以作为返回值，可以把函数理解一个值到另一个值得映射关系，即数学领域的函数概念。 优缺点优点： 代码简洁，开发速度快 适合数据运算、大数据处理等 易于理解，抽象度高 缺点： 调试上相对命令式要困难 由于函数内数据不变原则，导致的资源占用 java中的函数式编程可以简单概括为：lambda + 方法引用 + stream API = java函数式编程 基本函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class FunctionDemo { public static void main(String[] args) { //断言型// predicate(); //消费型// consumer(); //一元函数 输入输出不同// function(); //提供型// supplier(); //一元函数 输入输出类型相同// unaryOperator(); //二元函数 输入输出不同// biFunction(); //二元函数 输入输出相同 binaryOperator(); } /** * */ public static void predicate(){ Predicate&lt;Integer&gt; predicate = i -&gt; i &gt; 0; IntPredicate intPredicate = i -&gt; i &gt; 0; System.out.print(predicate.test(6)); System.out.print(intPredicate.test(-1)); } public static void consumer(){ Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s); consumer.accept(&quot;我是一个消费者&quot;); } public static void function(){ Function&lt;Integer,String&gt; function = x -&gt; &quot;数字是：&quot;+ x; System.out.println(function.apply(88)); } public static void supplier(){ Supplier&lt;String&gt; supplier = () -&gt; &quot;我是一个提供者&quot;; System.out.println(supplier.get()); } public static void unaryOperator(){ UnaryOperator&lt;Integer&gt; unaryOperator = x -&gt; ++x; System.out.println(unaryOperator.apply(1)); } public static void biFunction(){ BiFunction&lt;Integer,Double,Double&gt; biFunction = (x,y) -&gt; { ++x; ++y; return x+y; }; System.out.println(biFunction.apply(1,2.3)); } public static void binaryOperator(){ IntBinaryOperator intBinaryOperator = (x,y) -&gt; x + y; System.out.println(intBinaryOperator.applyAsInt(2,3)); }} lambda表达式可以搜索参考“java8新特性-lambda表达式” 方法引用直接使用两个冒号::来调用方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MethodReferenceDemo { public static void main(String[] args) { //消费者 方法引用模式// consumer(); //静态方法引用// callStaticMethod(); //非静态 实例方法引用// callMethod(); //非静态 类方法引用// callMethodByClass(); //构造函数方法引用// callConstructorMethod(); //数据不变模式 callMethod2(); } public static void consumer(){ Consumer&lt;String&gt; consumer = System.out::println; consumer.accept(&quot;我是一个消费者&quot;); } private static void callStaticMethod() { Consumer&lt;Dog&gt; consumer = Dog::bark; consumer.accept(new Dog()); } private static void callMethod() { Dog dog = new Dog(); Function&lt;Integer,Integer&gt; function = dog::eat; System.out.println(&quot;还剩[&quot; + function.apply(3) + &quot;]斤狗粮&quot;); } private static void callMethodByClass() { BiFunction&lt;Dog,Integer,Integer&gt; biFunction = Dog::eat; System.out.println(&quot;还剩[&quot; + biFunction.apply(new Dog(),4) + &quot;]斤狗粮&quot;); } private static void callConstructorMethod() { Supplier&lt;Dog&gt; supplier = Dog::new; System.out.println(&quot;new 了一个对象&quot; + supplier.get()); } private static void callMethod2() { Dog dog = new Dog(); Function&lt;Integer,Integer&gt; function = dog::eat; //函数声明 dog = null; System.out.println(&quot;还剩[&quot; + function.apply(3) + &quot;]斤狗粮&quot;); }} Stream流API可以搜索参考“Java8中的Stream详解” var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/10/fun-pro/"},{"title":"常见技术框架清单","text":"前言本文对市面上常见的且自己用到过的一些技术/框架/工具做简要整理介绍，目的是对繁杂的框架做个书签性质的梳理，便于有目的的针对性学习。 框架梳理 spring：Java体系技术框架，是一个统称，内部技术细分很广。 maven：依赖包管理工具 git:代码版本管理工具 eureka：注册和发现中心 apollo：配置中心 redis：缓存数据库 rabbit mq：消息队列 mybatis：关系型数据库 xxljob：定时任务工具 Elasticsearch：分布式搜索引擎 RPA：机器处理自动化技术 canal：mysql增量数据订阅和消费工具 cat：调用链监控系统 docker：容器化工具 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/5/15/com_tech_list/"},{"title":"幂等性","text":"什么是幂等？在数学上简单来说数s与自身运算还是自己，那么称这个数具备幂等性。 在软件领域，在相同入参下重复调用某接口，结果不会因为次数的变动而改变，称此接口具备幂等性。 幂等性的实现方式？中心思想:根据业务情况排除重复操作对数据的影响。 1、借助全局唯一标识 例如token,uuid等，进行判断如果有记录则不处理，无记录则处理并记录。适合增，删，改，复合场景等 2、借助业务主键 根据业务主键有无进行判断。将业务主键单独记录某数据表，并设置主键不可自增，接口访问时插入数据，如果失败则证明存在，如果成功则证明不存在。适合增，改，复合场景等。 3、借助数据库主键 适合删除场景。利用主键进行删除而不是通过其他模糊条件。 4、借助乐观锁 适合修改场景。数据表增加version字段，更新指定版本或者大于指定版本的数据 5、借助分布式锁 借助redis的setnx命令设置分布式锁 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/2/idempotent/"},{"title":"正向代理与反向代理","text":"客户端代理（前向代理、正向代理）我们在国内上不了google、facebook，那我们实际可以在香港建个代理服务器，我们通过代理服务器就可以访问google与facebook了，这就叫前向代理，代理的是使用者； 服务端代理（反转代理、反向代理）比如我们公司提供5个不同服务，我们部署在5个节点上的，但用户访问时不用直接请求我们5个节点上的服务，只需要访问我们的代理服务器就行了，代理服务器根据请求内容分发到不同服务器节点。这仅是一种使用场景，当然还可以做负载均衡等。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/8/forward-proxy/"},{"title":"算法的时间复杂度与空间复杂度","text":"什么是算法的时间复杂度在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。 算法的时间复杂度，记作：T(n)= O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，简称为时间复杂度。**其中f(n)是问题规模n的某个函数**。（问题规模与代码数量无关） 举例说明时间复杂度常数阶123int sum = 0, n = 100;printf(“I love you.com\\n”);sum = (1+n)*n/2; 计算一次就可以解决问题，因此问题规模是1，算法的时间复杂度为O(1) 线性阶线性阶就是随着问题规模n的扩大，对应计算次数呈直线增长 12345int i , n = 100, sum = 0;for( i=0; i &lt; n; i++ ){sum = sum + i;} 计算次数是n，算法时间复杂度为O(n) 平方阶12345678int i, j, n = 100;for( i=0; i &lt; n; i++ ){for( j=0; j &lt; n; j++ ){printf(“I love FishC.com\\n”);}} 计算次数是n^2,所以时间复杂度为O(n^2) 对数阶12345int i = 1, n = 100;while( i &lt; n ){i = i * 2;} 由计算次数x与问题n的关系2^x = n得到x = log(2)n，所以这个循环的时间复杂度为O(logn) 常用的时间复杂度所耗费的时间从小到大依次是： O(1) &lt; O(logn) &lt; (n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n) 什么是算法的空间负责度算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，**f(n)为语句关于n所占存储空间的函数**。 通常，我们都是用“时间复杂度”来指运行时间的需求，是用“空间复杂度”指空间需求。 当直接要让我们求“复杂度”时，通常指的是时间复杂度。 显然对时间复杂度的追求更是属于算法的潮流！ var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/11/alg-com/"},{"title":"线程","text":"什么是线程线程是程序执行流的最小单元，是处理器调度和分派的基本单位。 一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成 并行：多个cpu实例同时分别执行多段处理逻辑，一个cpu对应一个 并发：利用cpu调度算法，单个cup执行多段处理逻辑 特点 一个进程中至少有一个线程 多线程是为了提高资源使用效率 多线程与多核 多核(心)处理器是指在一个处理器上集成多个运算核心，每一个处理核心对应一个内核线程 内核线程就是直接由操作系统内核支持的线程 一般一个处理核心对应一个内核线程，但也可以有多个，比如常听到的“四核八线程” 轻量级进程：程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口 轻量级进程就是我们通常意义上所讲的线程(我们在这称它为用户线程) 每个轻量级进程都由一个内核线程支持 多线程下传统的操作系统（windows、linux）采用“时间片轮训”的方式进行用户线程调度。（执行一段等待一定时间再执行） 生命周期 创建 就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来； 运行：此线程正在执行，正在占用时间片； 阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完； 退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源。 java中的线程状态切换新建（New） ：使用new Thread() 创建 运行（Runnable） ：使用Thread.start() 无限等待（waiting） ：需要等待其他线程显式地唤醒才能运行 调用Thread.join() 方法。将会一直等待上一个线程的执行结束，然后被上一个线程唤醒。 调用Object.wait() 方法。将会一直等待，直到其他线程中使用了notify()、notifyAll()进行唤醒。 有限等待（timed waiting） ：可以被其他线程显式地唤醒，也可以在一定时间后由系统自动唤醒 调用Thread.sleep(timeout) 方法。该方法不会释放持有的对象锁。 调用Object.wait(timeout) 方法。该方法会释放持有的锁。 调用Thread.join(timeout) 方法。 阻塞（blocked） ：阻塞是在等待获取一个排它锁 由synchronized 修饰的代码块、方法。使得线程之间有并行变成串行执行以保证同步效果，如火车订票。 IO操作，也是串行执行。 结束（terminated） ：当线程的run() 方法执行结束后 线程与锁 二元信号量：一种最简单的锁，它有两种状态：占用和非占用 信号量：多元信号量允许多个线程访问同一个资源，简称信号量，对于允许多个线程并发访问的资源 互斥量：类似二元信号量资源仅允许一个线程访问，不同的是互斥量要求哪个线程获取了该互斥量锁就由哪个线程释放 临界区：临界区的作用范围仅限于本进程，其它的进程无法获取该锁。除此之处，临界区与互斥量的性质相同 读写锁：允许多个线程同时对同一个数据进行读操作，而只允许一个线程进行写操作 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/17/thread/"},{"title":"软件设计模式","text":"一、设计模式分类总体来说设计模式分为三大类： 五种创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 七种结构型模式：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 十一种行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 二、设计模式概述创建模式1、简单工厂方法 创建产品接口/抽象类 创建产品接口实现类/抽象类实现类 创建工厂类：通过工厂类可以实现对各种实现类的实例化并向上转型为接口/抽象类对象 优点：对象创建和使用实现了解耦，符合面向对象原则和面向接口编程 缺点：违背了开闭原则（软件中的对象应该对于扩展是开放的，但是对于修改是封闭的），新接口方法的实现必须依赖工厂 2、工厂方法 创建产品接口类 创建产品接口实现类：各个实现类有不同的实现 创建工厂接口类：接口方法的返回值是产品接口 创建工厂接口实现类：各实现类创建不同的产品类，返回对象是产品接口 优点：功能拓展不在受限于工厂接口类，工厂实现类可以自由实现 缺点：如果有新的产品接口方法增加，工厂类也需要跟着增加 3、抽象工厂 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。 与工厂方法的区别是抽象产品由一个变为多个，抽象工厂（工厂接口类）有多个生产不同抽象产品的接口 4.单例模式 单例模式能保证一个类仅有一个实例，并提供一个访问它的全局访问点，同时在类内部创造单一对象，通过设置权限，使类外部无法再创造对象。 5.构建者模式 Product: 最终要生成的对象，例如 Computer实例。 Builder： 构建者的抽象基类（有时会使用接口代替）。其定义了构建Product的抽象步骤，其实体类需要实现这些步骤。其会包含一个用来返回最终产品的方法Product getProduct()。 ConcreteBuilder: Builder的实现类。 Director: 决定如何构建最终产品的算法. 其会包含一个负责组装的方法void Construct(Builder builder)， 在这个方法中通过调用builder的方法，就可以设置builder，等设置完成后，就可以通过builder的 getProduct() 方法获得最终的产品。 6.原型模式 原型模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用原型模式。 原型接口类：规定了具体原型对象必须实现的接口，例如clone接口。 具体原型类：实现抽象原型类的 clone() 方法,返回对象就是自身。 访问类：使用具体原型类中的 clone() 方法来复制新的对象。 结构性模式7、适配器模式 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作 Target：客户端client所使用的目标接口，可以是接口或抽象类。 Adaptee：需要适配的类接口。 Adapter：适配器，负责Adaptee的接口与Target接口进行适配。 Client：与符合Target接口的对象协调的类。 1234567891011121314151617181920212223242526272829303132package adapter;//目标接口interface Target{ public void request();}//适配者接口class Adaptee{ public void specificRequest() { System.out.println(&quot;适配者中的业务代码被调用！&quot;); }}//类适配器类class ClassAdapter extends Adaptee implements Target{ public void request() { specificRequest(); }}//客户端代码public class ClassAdapterTest{ public static void main(String[] args) { System.out.println(&quot;类适配器模式测试：&quot;); Target target = new ClassAdapter(); target.request(); }} 优点：目标类与适配器类进行解藕，解决两者不一致的问题 缺点：提高系统复杂度，降低代码阅读性 8.装饰模式 装饰器模式是动态地给一个对象添加一些额外的职责，给一个对象增加一些新的功能，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。除了动态的增加，也可以动态的撤销，要做到动态的形式，不可以用继承实现，因为继承是静态的。 9.代理模式 代理模式是为其他对象提供一种代理以控制对这个对象的访问，也就是创建类的代理类，间接访问被代理类的过程中，对其功能加以控制。它和装饰器模式的区别在于，装饰器模式为了增强功能，而代理模式是为了加以控制。代理模式就是多一个代理类出来，替原对象进行一些操作，例如买火车票不一定在火车站买，也可以去代售点。再比如打官司需要请律师，因为律师在法律方面有专长，可以替我们进行操作。 10.外观模式 外观模式是为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。在客户端和复杂系统之间再加一层，提供一个容易使用的外观层。外观模式是为了解决类与类之家的依赖关系的，外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，比如搜狐门户网站，就利用了外观模式。 11.桥接模式 桥接模式是将抽象部分与实现部分分离，使它们都可以独立的变化。桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化（突然联想到了mvc模式）。将抽象化与实现化解耦，使得二者可以独立变化，就好比现在常说的mvc模式，view和model之间通过control来控制，达到高内聚低耦合来解耦的目的。 12.组合模式 组合模式是将对象组合成树形结构以表示”部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。创建了一个包含自己对象组的类，并提供修改对象组的方法。在系统的文件和文件夹的问题上就使用了组合模式，文件下不可以有对象，而文件夹下可以有文件对象或者文件夹对象。 13.享元模式 享元模式是运用共享技术有效地支持大量细粒度的对象。享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，重用现有的同类对象，若未找到匹配的对象，则创建新对象，这样可以减少对象的创建，降低系统内存，提高效率。 行为型模式14.策略模式 策略模式是定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换，且算法的变化不会影响到使用算法的客户。。是为了统一接口下的一系列算法类（也就是多种策略），用一个类将其封装起来，使这些策略可动态切换。策略模式属于行为型模式，是为了使这些策略可以相互切换，是为了选择不同的行为。 15.模版方法模式 模板方法模式是定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。该模式就是在一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤，将一些固定步骤、固定逻辑的方法封装成模板方法。调用模板方法即可完成那些特定的步骤。 16.观察者模式 观察者模式是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。也就是当被观察者状态变化时，通知所有观察者，这种依赖方式具有双向性，在QQ邮箱中的邮件订阅和RSS订阅，当我们浏览一些博客时，经常会看到RSS图标，意思就是，当你订阅了该文章，如果后续有更新，会及时通知你。这种现象即是典型的观察者模式。 Subject：就是“被观察”的角色，它将所有观察者对象的引用保存在一个集合中。 Observer：是抽象的“观察”角色，它定义了一个更新接口，使得在被观察者状态发生改变时通知自己。 ConcreteObserver：具体的观察者。 17.迭代器模式 迭代器模式是提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。在Java当中，将聚合类中遍历各个元素的行为分离出来，封装成迭代器，让迭代器来处理遍历的任务；使简化聚合类，同时又不暴露聚合类的内部，在我们经常使用的JDK中各个类也都是这些基本的东西。 18.责任链模式 责任链模式是避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求。在生活中学生进行请假的过程中，会涉及到，学生请假会一级一级往上批，最终处理，具体由谁批准可能不清楚。在程序当中，现在使用的struts拦截器即用到了责任链模式。 19.命令模式 命令模式是将一个请求封装成一个对象，从而使发出者可以用不同的请求对客户进行参数化。模式当中存在调用者、接收者、命令三个对象，实现请求和执行分开；调用者选择命令发布，命令指定接收者。举个例子，司令员下令让士兵去干件事情，司令员的作用是发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。司令士兵命令三者相互解耦，任何一方都不用去依赖其他人。其实struts框架也涉及到命令模式的思想。 20.备忘录模式 备忘录模式是在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。创建一个备忘录类，用来存储原始类的信息；同时创建备忘录仓库类，用来存储备忘录类，主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，也就是做个备份。在系统当中使用的撤销操作，即是使用了备忘录模式，系统可以保存有限次数的文件状态，用户可以进行上几个状态的恢复，也就是用到了备忘录模式。 21.状态模式 状态模式是允许对象在内部状态发生改变时改变它的行为。对象具有多种状态，且每种状态具有特定的行为。在网站的积分系统中，用户具有不同的积分，也就对应了不同的状态；还有QQ的用户状态有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态。 22.访问者模式 访问者模式主要是将数据结构与数据操作分离。在被访问的类里面加一个对外提供接待访问者的接口，访问者封装了对被访问者结构的一些杂乱操作，解耦结构与算法，同时具有优秀的扩展性。通俗来讲就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。 23.中介者模式 中介者模式是用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。例如，MVC模式中control就是model和view的中介者。与适配器区别在于，适配器是为了兼容不同的接口，而中介者是为了将显示和操作分离。 24.解释器模式 解释器模式是给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子，基本也就用在这个范围内，适用面较窄，例如：正则表达式的解释等。 参考资料： https://blog.csdn.net/varyall/article/details/82355964 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/8/soft-design-model/"},{"title":"进程","text":"什么是进程进程是一段程序的执行过程，在传统的操作系统中,进程即是基本的分配单元，也是基本的执行单元。 进程一般由程序、数据集合和进程控制块三部分组成 特点 进程本身不会运行，是线程的容器。线程不能单独执行，必须组成进程 一个程序至少有一个进程，一个进程至少有一个线程 声明周期 创建：分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间； 就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来； 运行：此线程正在执行，正在占用时间片； 阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完； 退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?2f798e6b269c8a40f12bef25d7f1876d\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 版权声明：本文为博主原创文章，欢迎转载，转载请注明作者、原文超链接，感谢各位看官!!! 本文出自：monkeyGeek 座右铭：生于忧患，死于安乐 欢迎志同道合的朋友一起交流、探讨！ monkeyGeek","link":"/2022/6/17/process/"}],"tags":[{"name":"UiPath","slug":"UiPath","link":"/tags/UiPath/"},{"name":"RPA","slug":"RPA","link":"/tags/RPA/"},{"name":"RPA组件库","slug":"RPA组件库","link":"/tags/RPA%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"activiti","slug":"activiti","link":"/tags/activiti/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"key","slug":"key","link":"/tags/key/"},{"name":"mq","slug":"mq","link":"/tags/mq/"},{"name":"rabbitmq","slug":"rabbitmq","link":"/tags/rabbitmq/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"php语言","slug":"php语言","link":"/tags/php%E8%AF%AD%E8%A8%80/"},{"name":"php基础","slug":"php基础","link":"/tags/php%E5%9F%BA%E7%A1%80/"},{"name":"experienceShare","slug":"experienceShare","link":"/tags/experienceShare/"},{"name":"分布式","slug":"分布式","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"数据一致性","slug":"数据一致性","link":"/tags/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"},{"name":"事务","slug":"事务","link":"/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"BASE理论","slug":"BASE理论","link":"/tags/BASE%E7%90%86%E8%AE%BA/"},{"name":"CAP理论","slug":"CAP理论","link":"/tags/CAP%E7%90%86%E8%AE%BA/"},{"name":"XA规范","slug":"XA规范","link":"/tags/XA%E8%A7%84%E8%8C%83/"},{"name":"Saga","slug":"Saga","link":"/tags/Saga/"},{"name":"成长","slug":"成长","link":"/tags/%E6%88%90%E9%95%BF/"},{"name":"职业发展","slug":"职业发展","link":"/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/"},{"name":"所感","slug":"所感","link":"/tags/%E6%89%80%E6%84%9F/"},{"name":"网络协议","slug":"网络协议","link":"/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"janusGraph","slug":"janusGraph","link":"/tags/janusGraph/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"标准与规范","slug":"标准与规范","link":"/tags/%E6%A0%87%E5%87%86%E4%B8%8E%E8%A7%84%E8%8C%83/"},{"name":"理财","slug":"理财","link":"/tags/%E7%90%86%E8%B4%A2/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"分布式一致性","slug":"分布式一致性","link":"/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/"},{"name":"eureka","slug":"eureka","link":"/tags/eureka/"},{"name":"ribbon","slug":"ribbon","link":"/tags/ribbon/"},{"name":"feign","slug":"feign","link":"/tags/feign/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"系统装机","slug":"系统装机","link":"/tags/%E7%B3%BB%E7%BB%9F%E8%A3%85%E6%9C%BA/"},{"name":"读后感","slug":"读后感","link":"/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"name":"锁","slug":"锁","link":"/tags/%E9%94%81/"},{"name":"java集合","slug":"java集合","link":"/tags/java%E9%9B%86%E5%90%88/"},{"name":"并发容器","slug":"并发容器","link":"/tags/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"},{"name":"jvm","slug":"jvm","link":"/tags/jvm/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"annotation注解","slug":"annotation注解","link":"/tags/annotation%E6%B3%A8%E8%A7%A3/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"java语法基础","slug":"java语法基础","link":"/tags/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"},{"name":"apollo","slug":"apollo","link":"/tags/apollo/"}],"categories":[{"name":"UiPath","slug":"UiPath","link":"/categories/UiPath/"},{"name":"aboutme","slug":"aboutme","link":"/categories/aboutme/"},{"name":"activiti","slug":"activiti","link":"/categories/activiti/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"mq","slug":"mq","link":"/categories/mq/"},{"name":"php语言","slug":"php语言","link":"/categories/php%E8%AF%AD%E8%A8%80/"},{"name":"redis","slug":"redis","link":"/categories/redis/"},{"name":"experienceShare","slug":"experienceShare","link":"/categories/experienceShare/"},{"name":"分布式架构","slug":"分布式架构","link":"/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/"},{"name":"成长","slug":"成长","link":"/categories/%E6%88%90%E9%95%BF/"},{"name":"所感","slug":"所感","link":"/categories/%E6%89%80%E6%84%9F/"},{"name":"网络协议","slug":"网络协议","link":"/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"标准与规范","slug":"标准与规范","link":"/categories/%E6%A0%87%E5%87%86%E4%B8%8E%E8%A7%84%E8%8C%83/"},{"name":"理财","slug":"理财","link":"/categories/%E7%90%86%E8%B4%A2/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"spring","slug":"spring","link":"/categories/spring/"},{"name":"系统装机","slug":"系统装机","link":"/categories/%E7%B3%BB%E7%BB%9F%E8%A3%85%E6%9C%BA/"},{"name":"职业","slug":"职业","link":"/categories/%E8%81%8C%E4%B8%9A/"},{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"java基础","slug":"java基础","link":"/categories/java%E5%9F%BA%E7%A1%80/"},{"name":"配置中心","slug":"配置中心","link":"/categories/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"name":"管理","slug":"管理","link":"/categories/%E7%AE%A1%E7%90%86/"},{"name":"软件技术","slug":"软件技术","link":"/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"}]}